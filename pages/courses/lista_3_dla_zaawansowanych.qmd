---
title: "Notki z listy 3 dla zaawansowanych"

toc: true
toc-depth: 3
toc-expand: true

about:
  template: marquee
---

## Zadanie 2

Kluczem do pisania szybkiego kodu w Pythonie jest jak najczestsze kożystanie z wbudowanych funkcji, które wykonywane sa bezposrednio w języku niskopoziomowym.

Przykładowo, to zadanie można elegancko rozwiazac za pomoca wbudowaniej biblioteki `itertools`. Składaja się na nia pomocnicze funkcje rozwiazujace często potrzebne funkcjonalności dookoła iteratorów:

```{python}
from itertools import accumulate
L = list(accumulate((-1) ** i / (i) for i in range(1, 101)))
print(L)
```
Stosujemy tu potrójne złożenie generatorów. Generatory to obiekty, po których możemy iterować, a zwaracaja wartości pojedynczo. Często wykonywane jest to leniwie, dopiero kiedy sa o to zapytane.

* `range(1, 101)` tworzy generator liczb od 1 do 100, nie trzyma tych liczb od razu w pamięci, tylko wie która jest następna.
*  `(func(n) for n in range(1, 101))` tworzy generator liczb od 1 do 100, a potem wykona operacje na nich.
*  `accumulate` bierze coś po czym moźna iterować i operator binarny (domyślnie `+`) i zwraca generator częściowych wartości używania tego operatora na wszystkich elementach generatora.
*  `list` tworzy listę zawierajaca elementy złożonego generatora, zmusza do materializacji wynikow. Wszystko powyżej było tworzone leniwie.

## Zadanie 5

Iterowanie się po wszystkich elementach zbioru często da się zastapić za pomoca matematycznych operacji na zbiorach, które sa dobrze zoptymalizowane.

```{python}
S = {"dolnośląskie", "lubuskie", "wielkopolskie"}
M = {"Wrocław", "Opole", "Zielona Góra", "Gorzów Wielkopolski"}
D = {
    "dolnośląskie": {"Wrocław"},
    "kujawsko-pomorskie": {"Bydgoszcz", "Toruń"},
    "lubelskie": {"Lublin"},
    "lubuskie": {"Gorzów Wielkopolski", "Zielona Góra"},
    "łódzkie": {"Łódź"},
    "małopolskie": {"Kraków"},
    "mazowieckie": {"Warszawa"},
    "opolskie": {"Opole"},
    "podkarpackie": {"Rzeszów"},
    "podlaskie": {"Białystok"},
    "pomorskie": {"Gdańsk"},
    "śląskie": {"Katowice"},
    "świętokrzyskie": {"Kielce"},
    "warmińsko-mazurskie": {"Olsztyn"},
    "wielkopolskie": {"Poznań"},
    "zachodniopomorskie": {"Szczecin"},
}

print(set.union(*D.values()))
print({key for key, value in D.items() if value.intersection(M)})
```

## Zadanie 6

W Pythonie 3.8+ jest to możliwe za pomoca operatora `:=` (walrus operator). Pozwala na tworzenie zmiennych pomocniczych wewnatrz wyrażeń języka.

```{python}
from math import sin, cos, radians

n = 101
punkty = {
    (angle:=i * 360 / n): (cos(radians(angle)), sin(radians(angle)))
    for i in range(n)
}
print(punkty)
```
    Inna metoda jest użycie generatora wewnatrz listy składanej.

```{python}
punkty = {
    angle: (cos(radians(angle)), sin(radians(angle)))
    for angle in (i * 360 / n for i in range(n))
}
print(punkty)
```

Pluse użycia generatora, a nie osobnej listy jest to, że jest on leniwie ewaluowany - jeden element na raz. Nie trzymamy katów w pamieci dwa razy.
