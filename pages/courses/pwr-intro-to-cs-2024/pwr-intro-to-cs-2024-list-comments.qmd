---
title: "Listy Python (PWr Zima 2024)"

about:
  template: marquee
---


### Lista 1

Python lista 1 - wyrażenia matematyczne

[Lista zadań](https://alfa.im.pwr.edu.pl/~giniew/lib/exe/fetch.php?media=rok2425:zimowy:wstep_-_lista_1.ipynb)

- Zamiast
  ```{python}
  import math
  pole = math.pi * 10**2
  ```
  warto użyć
  ```{python}
  from math import pi
  pole = pi * 10**2
  ```
  Zmniejszamy ilość pisania przy wielokrotnym użyciu, a sam import jest wydajniejszy co może mieć znaczenie przy bardziej zaawansowanych zadaniach.

- Funkcje pierwiastka kwadratowego i podnoszenia do potęgi $1/2$ są oczywiście równoważne, natomiast polecana jest `math.sqrt`. Mniej ogólne algorytmy są zazwyczaj lepiej zoptymalizowane (przy naszych zastosowaniach nie ma to jednak znaczenia).
  ```{python}
  from math import sqrt
  x = 2
  y = sqrt(x)
  z = x**0.5
  print(y, z, y == z)
  ```

- W *zadaniu 4* występuje funkcja podłoga $ \lfloor x \rfloor $.  Jest to największa liczba całkowita mniejsza niż $x$. W Pythonie można używać funkcji `math.floor`.
  ```{python}
  from math import floor
  x = 2.5
  y = 2.9
  z = -3.1
  print(floor(x), floor(y), floor(z))
  ```

- *Zadanie 5* pokazuje, jak ważne jest umiejetne korzystanie ze zmiennych pomocniczych.
  ```{python}
  from math import sqrt, pi

  suma_w_nawiasie = 5 ** 4 + 53 * sqrt(89)

  mianownik = 80 * sqrt(15) * suma_w_nawiasie ** (3/2)
  licznik = 3308 * suma_w_nawiasie - 3 * sqrt(89)
  pi_przyblizenie = mianownik / licznik

  print(round(pi_przyblizenie, 10))
  print(round(pi_przyblizenie, 10) == round(pi, 10))
  ```
  W powyższym kodzie dużo łatwiej wyłapac bład niż w jednolinijkowym gigancie.

- Do *zadania 6* wrócimy jeszcze raz po funkcjach i pętlach aby zaimplemetować dużo czytelniejsze rozwiązanie.

### Lista 2

Python lista 2 - napisy

[Lista zadań](https://alfa.im.pwr.edu.pl/~giniew/lib/exe/fetch.php?media=rok2425:zimowy:wstep_-_lista_2.ipynb)

- W razie gdy chcemy sprawdzić, gdzie w systemie zapisany jest dany plik Python albo zeszyt Jupyter poniższe drukuje obecna ścieżkę robocza (Current Working Directory).
  ```{python}
  import os
  print(os.getcwd())
  ```


### Lista 3

Python lista 3 - listy i słowniki

[Lista zadań](https://alfa.im.pwr.edu.pl/~giniew/lib/exe/fetch.php?media=rok2425:zimowy:wstep_-_lista_3.ipynb)


Komentarze dla zaawansowanych:

**Zadanie 2**

Kluczem do pisania szybkiego kodu w Pythonie jest jak najczestsze kożystanie z wbudowanych funkcji, które wykonywane sa bezposrednio w języku niskopoziomowym.

Przykładowo, to zadanie można elegancko rozwiazac za pomoca wbudowaniej biblioteki `itertools`. Składaja się na nia pomocnicze funkcje rozwiazujace często potrzebne funkcjonalności dookoła iteratorów:

```{python}
from itertools import accumulate
L = list(accumulate((-1) ** i / (i) for i in range(1, 101)))
print(L)
```
Stosujemy tu potrójne złożenie generatorów. Generatory to obiekty, po których możemy iterować, a zwaracaja wartości pojedynczo. Często wykonywane jest to leniwie, dopiero kiedy sa o to zapytane.

* `range(1, 101)` tworzy generator liczb od 1 do 100, nie trzyma tych liczb od razu w pamięci, tylko wie która jest następna.
*  `(func(n) for n in range(1, 101))` tworzy generator liczb od 1 do 100, a potem wykona operacje na nich.
*  `accumulate` bierze coś po czym moźna iterować i operator binarny (domyślnie `+`) i zwraca generator częściowych wartości używania tego operatora na wszystkich elementach generatora.
*  `list` tworzy listę zawierajaca elementy złożonego generatora, zmusza do materializacji wynikow. Wszystko powyżej było tworzone leniwie.

**Zadanie 5**

Iterowanie się po wszystkich elementach zbioru często da się zastapić za pomoca matematycznych operacji na zbiorach, które sa dobrze zoptymalizowane.

```{python}
S = {"dolnośląskie", "lubuskie", "wielkopolskie"}
M = {"Wrocław", "Opole", "Zielona Góra", "Gorzów Wielkopolski"}
D = {
    "dolnośląskie": {"Wrocław"},
    "kujawsko-pomorskie": {"Bydgoszcz", "Toruń"},
    "lubelskie": {"Lublin"},
    "lubuskie": {"Gorzów Wielkopolski", "Zielona Góra"},
    "łódzkie": {"Łódź"},
    "małopolskie": {"Kraków"},
    "mazowieckie": {"Warszawa"},
    "opolskie": {"Opole"},
    "podkarpackie": {"Rzeszów"},
    "podlaskie": {"Białystok"},
    "pomorskie": {"Gdańsk"},
    "śląskie": {"Katowice"},
    "świętokrzyskie": {"Kielce"},
    "warmińsko-mazurskie": {"Olsztyn"},
    "wielkopolskie": {"Poznań"},
    "zachodniopomorskie": {"Szczecin"},
}

print(set.union(*D.values()))
print({key for key, value in D.items() if value.intersection(M)})
```

**Zadanie 6**

W Pythonie 3.8+ jest to możliwe za pomoca operatora `:=` (walrus operator). Pozwala na tworzenie zmiennych pomocniczych wewnatrz wyrażeń języka.

```{python}
from math import sin, cos, radians

n = 101
punkty = {
    (angle:=i * 360 / n): (cos(radians(angle)), sin(radians(angle)))
    for i in range(n)
}
print(punkty)
```
    Inna metoda jest użycie generatora wewnatrz listy składanej.

```{python}
punkty = {
    angle: (cos(radians(angle)), sin(radians(angle)))
    for angle in (i * 360 / n for i in range(n))
}
print(punkty)
```

Plusem użycia generatora, a nie osobnej listy jest to, że jest on leniwie ewaluowany - jeden element na raz. Nie trzymamy katów w pamieci dwa razy.

### Lista 4

Python lista 4 - funkcje.

[Lista zadań](https://alfa.im.pwr.edu.pl/~giniew/lib/exe/fetch.php?media=rok2425:zimowy:wstep_-_lista_4.ipynb)

* Na zajęciach zobaczyliśy jak zapisać zadanie Fizz Buzz bez porównania modulo 15:

  ```{python}
  def fizz_buzz(
      liczba: int,
  ) -> str:
      """Wyznacz FizzBuzz dla liczby."""
      msg = ""
      if liczba % 3 == 0:
          msg += "Fizz"
      if liczba % 5 == 0:
          msg += "Buzz"
      return msg or str(liczba)


  print([fizz_buzz(i) for i in range(1, 16)])
  ```

  Jest to szczególnie istotne, jeżeli dodamy dodatkowo `Mizz` dla liczb podzielnych przez 7 i `Duzz` dla liczb podzielnych przez 8. Funkcję można wtedy jeszcze bardziej uprościć za pomoca słownika i listy składanej:

  ```{python}
  def fizz_buzz(
      liczba: int,
  ) -> str:
      """Wyznacz FizzBuzz dla liczby."""
      msg = ""
      mapa = {
          3: "Fizz",
          5: "Buzz",
          7: "Mizz",
          8: "Duzz",
      }
      lista_slow = [mapa[i] for i in mapa if liczba % i == 0]
      msg = "".join(lista_slow)
      return msg or str(liczba)

  print([fizz_buzz(i) for i in range(1, 16)])
  ```

  Sprawdzanie wszystkich podzielności miesznych było by bardzo niekomfortowe.

### Lista 5

Python lista 5 - numpy, matplotlib.

[Lista zadań](https://alfa.im.pwr.edu.pl/~giniew/lib/exe/fetch.php?media=rok2425:zimowy:wstep_-_lista_5.ipynb)

### Lista 6

Python lista 6 - testowanie, wyjatki

[Lista zadań](https://alfa.im.pwr.edu.pl/~giniew/lib/exe/fetch.php?media=rok2425:zimowy:wstep_-_lista_6.ipynb)
