---
title: "Programowanie (PWr Lato 2025) Ćwiczenia projektowe"

about:
  template: marquee

execute:
  freeze: true  # never re-render during project render
---



## Zarzadzanie środowiskami

Wyjaśniliśmy, dlaczego warto używać środowisk wirtualnych. Na labolatoriach korzystamy z anacondy, dla przypomnienia komendy które mogą się przydać:
```{powershell}
# tworzymy nowe środowisko
# w tym przypadku z pythonem 3.12
conda create -n programowanie-2025 python=3.12
# sprawdzamy czy środowisko się utworzyło, i jakie mamy środowiskam
# obecne środowisko jest oznaczone *
conda info --envs
# aktywujemy środowisko
conda activate programowanie-2025
# instalujemy pakiety
conda install numpy pandas matplotlib rich
# tworzymy plik requirements.txt
conda list -e > requirements.txt
```

Najbardziej waniliowym sposobem na zarządzanie środowiskami jest `venv`. Wtedy robimy to tak:
```{powershell}
# tworzymy nowe środowisko
python -m venv programowanie-2025
# aktywujemy środowisko
programowanie-2025\Scripts\activate
# instalujemy pakiety
pip install numpy pandas matplotlib rich
# tworzymy plik requirements.txt
pip freeze > requirements.txt
```

Innymi sposobami na zarządzanie środowiskami są [`poetry`](https://python-poetry.org/docs/) i [`uv`](https://docs.astral.sh/uv/getting-started/).
W szczególności `poetry` jest bardzo wygodne, `uv` jest bardziej skomplikowane, ale daje więcej możliwości i jest znacznie szybsze.


## Logowanie

Używamy tej [recepty](https://docs.python.org/3/howto/logging-cookbook.html#multiple-handlers-and-formatters) wzbogaconej o pakiet [`rich`](https://rich.readthedocs.io/en/stable/introduction.html) do ustawienia logowania w projekcie.
Dostajemy wtedy kolorowe logi na poziomie  `INFO` i wyżej w terminalu, a dodatkowe informacje na poziomie `DEBUG` w pliku `log.txt`.

```{python}
import logging
from rich.logging import RichHandler

logger = logging.getLogger("simple_example")
logger.setLevel(logging.DEBUG)

# logger jest tworzony tylko raz, więc nie dodajemy handlerów więcej niż raz
if not logger.hasHandlers():
    # zapisujemy logi DEBUG i wyżej do pliku
    fh = logging.FileHandler("simple_example.log")
    fh.setLevel(logging.DEBUG)
    # ustalamy format logów
    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )
    # dodajemy formatter do handlera
    fh.setFormatter(formatter)
    # dodajemy handler do loggera
    logger.addHandler(fh)

    # wypisujemy logi INFO i wyżej do terminala
    # używamy RichHandler do kolorowych  czytelnych logów
    ch = RichHandler()
    ch.setLevel(logging.INFO)
    logger.addHandler(ch)

# przykładowe logi
logger.debug("debug message")
logger.info("info message")
logger.warning("warn message")
logger.error("error message")
```

W pliku dostajemy logi w formacie:

```
2025-05-03 14:36:52,989 - simple_example - DEBUG - debug message
2025-05-03 14:36:52,989 - simple_example - INFO - info message
2025-05-03 14:36:52,991 - simple_example - WARNING - warn message
2025-05-03 14:36:52,992 - simple_example - ERROR - error message
```

## Liczby dualne

Implementujemy [liczby dualne](https://www.wikiwand.com/en/articles/Dual_number) w Pythonie. Nasza implementacja powinna być napisana w pliku `dual_numbers.py`.

Celem tego zadania jest zaimplementowanie klasy `DualNumber` w Pythonie. Liczby dualne są rozszerzeniem liczb rzeczywistych o specjalny element 'ε' (epsilon), taki że ε² = 0. Są one używane w automatycznym różniczkowaniu.

**Liczba dualna:** Liczba postaci a + bε, gdzie 'a' i 'b' są liczbami rzeczywistymi, a ε jest jednostką nieskończenie małą.

**Instrukcje:**

1.  **Definicja klasy:**
    * Utwórz klasę o nazwie `DualNumber`.
    * Konstruktor `__init__` powinien przyjmować dwa argumenty, `real` i `dual`, reprezentujące odpowiednio 'a' i 'b' w a + bε. Oba powinny domyślnie wynosić 0.
    * Zapisz te wartości jako atrybuty `self.real` i `self.dual`.

2.  **Reprezentacja jako napis:**
    * Zaimplementuj metody `__str__` i `__repr__`, aby zapewnić przyjazną dla użytkownika reprezentację łańcuchową liczby dualnej. Powinna ona wyglądać odpowiednio jak "a + bε" lub "a - bε".

3.  **Operacje arytmetyczne:**
    * Zaimplementuj następujące operacje arytmetyczne, aby umożliwić obliczenia na liczbach dualnych:
        * `__add__` (+): (a + bε) + (c + dε) = (a + c) + (b + d)ε
        * `__sub__` (-): (a + bε) - (c + dε) = (a - c) + (b - d)ε
        * `__mul__` (*): (a + bε) * (c + dε) = ac + (ad + bc)ε
        * `__truediv__` (/): (a + bε) / (c + dε) = (a/c) + ((bc - ad)/c²)ε  (Załóż, że c != 0)
        * `__pow__` (**): (a + bε)^n = a^n + n*a^(n-1)*bε
        * `__neg__` (-): -(a + bε) = -a - bε
    * Zaimplementuj prawostronne wersje tych operacji, aby obsługiwać przypadki takie jak 2 + (a + bε):
        * `__radd__`
        * `__rsub__`
        * `__rmul__`
        * `__rtruediv__`
        * `__rpow__`

4.  **Operacje porównania:**
    * Zaimplementuj następujące operacje porównania:
        * `__eq__` (==): (a + bε) == (c + dε) jeśli a == c i b == d
        * `__ne__` (!=): (a + bε) != (c + dε) jeśli a != c lub b != d

5.  **Konwersja na int i float:**
    * Zaimplementuj metody `__int__` i `__float__`, aby umożliwić konwersję liczby dualnej na typy `int` i `float`.  Konwersja powinna zwracać tylko część rzeczywistą liczby dualnej.

6.  **Dodatkowe funkcje matematyczne (opcjonalne):**
    * Zaimplementuj inne funkcje matematyczne jako metody klasy:
        * `sqrt(z)`: Pierwiastek kwadratowy liczby dualnej.
        * `exp(z)`: Funkcja wykładnicza liczby dualnej.
        * `sin(z)`: Sinus liczby dualnej.
        * `cos(z)`: Cosinus liczby dualnej.


Poniżej znajduje się przykład użycia klasy `DualNumber`, (kod kliencki). Twoja implementacja powinna umożliwić poprawne działanie tego kodu.

```{python}
# | eval: false

from dual_numbers import Dual, epsilon


funcje_zaimplementowane = False

# Utwórz kilka liczb dualnych
a = DualNumber(2, 3)  # 2 + 3ε
b = DualNumber(1, 4)  # 1 + 4ε
c = DualNumber(5, 0)  # 5 + 0ε (odpowiednik liczby rzeczywistej 5)
d = 1 + 2 * epsilon  # 1 + 2ε

# Wypisz liczby dualne
print("Liczba dualna a:", a)
print("Liczba dualna b:", b)
print("Epsilon:", epsilon)

# Podstawowe operacje arytmetyczne
print("Dodawanie:", a + b)
print("Odejmowanie:", a - b)
print("Mnożenie:", a * b)
print("Dzielenie:", a / b)
print("Potęgowanie:", a**2)
print("Negacja", -a)

# Operacje odzwierciedlone
print("Dodawanie prawe:", 1 + a)
print("Odejmowanie prawe:", 5 - a)
print("Mnożenie prawe:", 2 * a)
print("Dzielenie prawe:", 10 / a)
print("Potęgowanie prawe", 2**a)

# Operacje porównania
print("Równość:", a == b)
print("Nierówność:", a != b)
print("Równość:", a == DualNumber(2, 3))

# Konwersja na int i float
print("Konwersja na int:", int(a))
print("Konwersja na float:", float(a))

# Opcjonalne funkcje na liczbach dualnych
if funcje_zaimplementowane:
    print("Pierwiastek kwadratowy z a:", DualNumber.sqrt(a))
    print("Funkcja wykładnicza z a:", DualNumber.exp(a))
    print("Sinus z a:", DualNumber.sin(a))
    print("Cosinus z a:", DualNumber.cos(a))

```
