[
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-game-of-life.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-game-of-life.html",
    "title": "Gra w Życie",
    "section": "",
    "text": "Conway’s Game of Life to symulacja automatu komórkowego, w której stan każdej komórki w siatce ewoluuje w czasie na podstawie prostych reguł dotyczących jej sąsiadów.\nZasady Gry\nGra toczy się na dwuwymiarowej siatce komórek, z których każda może być w jednym z dwóch stanów:\n\nŻywa (oznaczona kolorem zielonym w implementacji)\nMartwa (oznaczona kolorem czarnym w implementacji)\n\nStan komórki w następnej generacji zależy od stanu jej ośmiu sąsiadów w obecnej generacji, zgodnie z następującymi regułami:\n\nMartwa komórka z dokładnie trzema żywymi sąsiadami staje się żywa (narodziny).\nŻywa komórka z mniej niż dwoma żywymi sąsiadami umiera z powodu niedoludnienia.\nŻywa komórka z dwoma lub trzema żywymi sąsiadami pozostaje żywa.\nŻywa komórka z więcej niż trzema żywymi sąsiadami umiera z powodu przeludnienia."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-game-of-life.html#gra-w-życie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-game-of-life.html#gra-w-życie",
    "title": "Gra w Życie",
    "section": "",
    "text": "Conway’s Game of Life to symulacja automatu komórkowego, w której stan każdej komórki w siatce ewoluuje w czasie na podstawie prostych reguł dotyczących jej sąsiadów.\nZasady Gry\nGra toczy się na dwuwymiarowej siatce komórek, z których każda może być w jednym z dwóch stanów:\n\nŻywa (oznaczona kolorem zielonym w implementacji)\nMartwa (oznaczona kolorem czarnym w implementacji)\n\nStan komórki w następnej generacji zależy od stanu jej ośmiu sąsiadów w obecnej generacji, zgodnie z następującymi regułami:\n\nMartwa komórka z dokładnie trzema żywymi sąsiadami staje się żywa (narodziny).\nŻywa komórka z mniej niż dwoma żywymi sąsiadami umiera z powodu niedoludnienia.\nŻywa komórka z dwoma lub trzema żywymi sąsiadami pozostaje żywa.\nŻywa komórka z więcej niż trzema żywymi sąsiadami umiera z powodu przeludnienia."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-game-of-life.html#zadanie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-game-of-life.html#zadanie",
    "title": "Gra w Życie",
    "section": "Zadanie",
    "text": "Zadanie\nTwoim zadaniem jest uzupełnienie kodu symulacji Game of Life. Poniżej znajduje się szkielet kodu, który musisz wypełnić.\n\nUzupełnij funkcję draw_grid, rysując na ekranie siatkę komórek z odpowiednimi kolorami (zielony dla komórek żywych, czarny dla martwych).\nUzupełnij brakującą część pętli while w game_event_loop tak aby gra wyświetlała kolejne generacje oraz reagowała na zdarzenia użytkownika.\nDodatkowe wyzwanie: Zaimplementuj różne początkowe wzory (np. Glider, Gosper glider gun).\nDodatkowe wyzwanie: Dodaj kontrolę prędkości symulacji. Zaimplementuj możliwość przewijania generacji.\n\n\nPrzykładowe sterowanie\n\nSpacja: Wznawia/wstrzymuje symulację.\nR: Resetuje siatkę do losowego układu.\nC: Czyści siatkę (wszystkie komórki martwe).\nLewy Przycisk Myszy: Kliknięcie komórki przełącza jej stan (żywa/martwa), ale tylko gdy symulacja jest wstrzymana.\n\n\n\nPrzydatne zasoby:\n\npygame.init()\npygame.display.set_mode()\npygame.display.set_caption()\npygame.event.get()\npygame.event.EventType (np. pygame.MOUSEBUTTONDOWN)\npygame.key.get_pressed()\npygame.draw.rect()\npygame.display.flip()\npygame.time.Clock()\npygame.time.Clock.tick()\npygame.mouse.get_pos()\npygame.quit()\n\n\n\nPrzygotowanie środowiska\nDla tego zadania będziesz potrzebować zainstalować Pygame i NumPy. Możesz to zrobić za pomocą poleceń:\nconda create -n pygame-env python=3.12\nconda activate ppygame-env\nconda config --append channels conda-forge\nconda install numpy pygame\n\n\nSzkielet kodu\n\n#!/usr/bin/env python3\n\"\"\"Conway's Game of Life.\n\nImplementacja Gry w Życie Conwaya w Pythonie z użyciem Pygame i NumPy.\n\"\"\"\n\nimport numpy as np\nimport pygame\n\n# Stałe\nWIDTH = 800\nHEIGHT = 600\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nGREEN = (0, 200, 0)\nCELL_SIZE = 10\nGRID_WIDTH = WIDTH // CELL_SIZE\nGRID_HEIGHT = HEIGHT // CELL_SIZE\nDEFAULT_FPS = 10\n\n\ndef create_random_grid() -&gt; np.ndarray:\n    \"\"\"Tworzy losową siatkę złożoną z 0 i 1.\"\"\"\n    rng = np.random.default_rng()\n    return rng.integers(0, 2, size=(GRID_HEIGHT, GRID_WIDTH), dtype=np.int8)\n\n\ndef create_empty_grid() -&gt; np.ndarray:\n    \"\"\"Tworzy pustą siatkę złożoną z 0.\"\"\"\n    return np.zeros(\n        (GRID_HEIGHT, GRID_WIDTH),\n        dtype=np.int8,\n    )\n\n\ndef get_next_generation(grid: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Oblicza następne pokolenie Gry w Życie.\"\"\"\n    new_grid: np.ndarray = np.copy(grid)\n    for r in range(GRID_HEIGHT):\n        for c in range(GRID_WIDTH):\n            # Użyj max i min do obliczenia granic sąsiedztwa\n            r_start = max(0, r - 1)\n            r_end = min(GRID_HEIGHT, r + 2)\n            c_start = max(0, c - 1)\n            c_end = min(GRID_WIDTH, c + 2)\n            # Policz żywych sąsiadów\n            live_neighbors = np.sum(grid[r_start:r_end, c_start:c_end]) - grid[r, c]\n            # Zastosuj reguły Gry w Życie\n            if grid[r, c]:  # Komórka żywa\n                if live_neighbors not in (2, 3):\n                    new_grid[r, c] = 0  # Umiera\n            elif live_neighbors == 3:  # Komórka martwa\n                new_grid[r, c] = 1  # Ożywa\n    return new_grid\n\n\ndef draw_grid(screen: pygame.Surface, grid: np.ndarray) -&gt; None:\n    \"\"\"Rysuje siatkę na ekranie Pygame.\"\"\"\n    pass\n\n\ndef game_event_loop() -&gt; None:\n    \"\"\"Obsługuje główną pętlę gry, w tym zdarzenia, aktualizacje i rysowanie.\"\"\"\n    paused = True\n    running = True\n    clock: pygame.time.Clock = pygame.time.Clock()\n    current_grid: np.ndarray = create_random_grid()\n    fps = DEFAULT_FPS\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n\n    while running:\n        pass\n\n\ndef main() -&gt; None:\n    \"\"\"Główna funkcja uruchamiająca Grę w Życie.\"\"\"\n    pygame.init()\n    pygame.display.set_caption(\"Conway's Game of Life\")\n    game_event_loop()\n    pygame.quit()\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html",
    "title": "Ruff - narzędzie do analizy kodu",
    "section": "",
    "text": "conda install -c conda-forge ruff"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#instalacja",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#instalacja",
    "title": "Ruff - narzędzie do analizy kodu",
    "section": "",
    "text": "conda install -c conda-forge ruff"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#użycie-z-poziomu-terminala",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#użycie-z-poziomu-terminala",
    "title": "Ruff - narzędzie do analizy kodu",
    "section": "Użycie z poziomu terminala",
    "text": "Użycie z poziomu terminala\n# poprawia formatowanie kodu\nruff format\n# sprawdza kod\nruff check\n# sprawdza kod i poprawia błędy które można naprawić automatycznie\nruff check --fix --unsafe-fixes"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#dodatkowa-konfiguracja",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#dodatkowa-konfiguracja",
    "title": "Ruff - narzędzie do analizy kodu",
    "section": "Dodatkowa konfiguracja",
    "text": "Dodatkowa konfiguracja\nRuff można skonfigurować za pomocą pliku ruff.toml. Przykładowa konfiguracja:\nline-length    = 79\ntarget-version = \"py312\"\n\n[lint]\n    select = [\"ALL\"]\n    ignore = [\n        \"COM\",\n        \"D203\",\n        \"D211\",\n        \"D213\",\n        \"FA\",\n        \"ISC\",\n        \"T\",\n        \"TC\",\n    ]\n\n[format]\n    docstring-code-format = true\nAby użyć tej konfiguracji, należy uruchomić Ruff z odpowiednim argumentem:\nruff --config ruff.toml format\nruff --config ruff.toml check\nruff --config ruff.toml check --fix --unsafe-fixes"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#integracja-z-vscode",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#integracja-z-vscode",
    "title": "Ruff - narzędzie do analizy kodu",
    "section": "Integracja z VSCode",
    "text": "Integracja z VSCode\n\nInstalacja rozszerzenia [ruff].\nDodanie do pliku .vscode/settings.json następującej konfiguracji.\n\n{\n   \"[python]\": {\n        \"editor.codeActionsOnSave\": {\n            \"source.fixAll\": \"always\",\n            \"source.organizeImports\": \"always\"\n        },\n        \"editor.defaultFormatter\": \"charliermarsh.ruff\",\n        \"editor.formatOnSave\": true,\n        \"editor.formatOnType\": true,\n    },\n    \"ruff.configuration\": \"ruff.toml\",\n    \"ruff.configurationPreference\": \"filesystemFirst\",\n}"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#zadanie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-ruff.html#zadanie",
    "title": "Ruff - narzędzie do analizy kodu",
    "section": "Zadanie",
    "text": "Zadanie\nZainstaluj Ruff i skonfiguruj go w swoim folderze. Użyj go do sprawdzenia i poprawienia kodu rozwiązań z dowolnej listy zadań. Zrób to na kopii kodu, aby nie stracić oryginalnych rozwiązań.\nNajpierw popraw formatowanie kodu, a następnie sprawdź kod pod kątem błędów. Przeanalizuj błędy. Gdy jesteś pewny/a że je rozumiesz, użyj opcji --fix aby poprawić błędy, które można naprawić automatycznie. Popraw ręcznie błędy, które Ruff nie potrafił naprawić.\nPorównaj efekty przed i po użyciu Ruff."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-functions.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-functions.html",
    "title": "Hierarchia Funkcji",
    "section": "",
    "text": "Celem tego ćwiczenia jest praktyczne zastosowanie dziedziczenia w Pythonie do stworzenia hierarchii klas reprezentujących różne typy funkcji matematycznych. Zaimplementujesz klasy dla funkcji rzeczywistych, funkcji różniczkowalnych oraz konkretnych przypadków - funkcji wielomianowych, sinusoidalnych i eksponencjalnych.\n\nKlasa bazowa RealFunction:\n\nZdefiniuj klasę RealFunction.\nJej konstruktor (__init__) powinien przyjmować dwa argumenty:\n\nfunc: Obiekt wywoływalny (np. funkcja lambda lub zwykła funkcja Pythona), który reprezentuje daną funkcję matematyczną.\nname (opcjonalny): Ciąg znaków opisujący nazwę funkcji.\n\nZaimplementuj metodę __call__(self, x), która przyjmuje argument x (liczbę rzeczywistą) i zwraca wynik wywołania przechowywanej funkcji func z tym argumentem.\nZaimplementuj metodę __str__(self), która zwraca opis funkcji (np. jej nazwę).\n\nKlasa pochodna DifferentiableFunction:\n\nZdefiniuj klasę DifferentiableFunction, która dziedziczy po RealFunction.\nJej konstruktor (__init__) powinien zachowywać się tak samo jak konstruktor klasy bazowej, przekazując argumenty do super().__init__(func, name).\nZaimplementuj metodę derivative(self, h=1e-7), która przybliża wartość pochodnej funkcji w punkcie x przy użyciu symetrycznego ilorazu różnicowego:\n\\[\\frac{f(x + h) - f(x - h)}{2h}\\]\ngdzie \\(f\\) to funkcja reprezentowana przez instancję klasy, a \\(h\\) jest małą wartością kroku (domyślnie \\(10^{-7}\\)). Metoda ta powinna zwracać obiekt RealFunction odpowiadający przybliżonej wartości pochodnej w punkcie x.\n\nKlasa pochodna PolynomialFunction:\n\nZdefiniuj klasę PolynomialFunction, która dziedziczy po DifferentiableFunction.\nJej konstruktor (__init__) powinien przyjmować dwa argumenty:\n\ncoefficients: Lista liczb reprezentujących współczynniki wielomianu. Pierwszy element listy odpowiada współczynnikowi przy najwyższej potędze, a ostatni - wyrazowi wolnemu. Na przykład, dla wielomianu \\(3x^2 - 2x + 1\\), lista współczynników to [3, -2, 1].\nname (opcjonalny): Nazwa wielomianu.\n\nZaimplementuj metodę __call__(self, x), która oblicza wartość wielomianu dla danego x przy użyciu schematu Hornera. Zaimplementuj w tym celu pomocniczą (np. prywatną) metodę __evaluate_polynomial(self, x, coeffs).\nZaimplementuj metodę __str__(self), która zwraca opis wielomianu na podstawie jego współczynników. Powinna ona tworzyć łańcuch znaków reprezentujący wielomian w standardowej formie (np. 3x^2 - 2x + 1).\nZaimplementuj metodę derivative(self), która oblicza wartość pochodnej wielomianu w punkcie x i zwraca nowy obiekt klasy PolynomialFunction reprezentujący tę pochodną.\n\nKlasa pochodna SineFunction:\n\nZdefiniuj klasę SineFunction, która dziedziczy po DifferentiableFunction.\nJej konstruktor (__init__) powinien przyjmować następujące argumenty:\n\namplitude (opcjonalny): Amplituda funkcji sinus (domyślnie 1.0).\nfrequency (opcjonalny): Częstotliwość funkcji sinus (domyślnie 1.0).\nphase (opcjonalny): Faza funkcji sinus (domyślnie 0.0).\nname (opcjonalny): Nazwa funkcji sinus.\n\nZaimplementuj metodę __call__(self, x), która oblicza wartość funkcji sinus dla danego x przy użyciu funkcji z modułu math.\nZaimplementuj metodę __str__(self), która zwraca opis funkcji sinus na podstawie jej parametrów (amplituda, częstotliwość, faza).\nZaimplementuj metodę derivative(self), która oblicza wartość pochodnej funkcji sinus w punkcie x i zwraca nowy obiekt klasy SineFunction reprezentujący tę pochodną.\n\nKlasa pochodna ExponentialFunction:\n\nZdefiniuj klasę ExponentialFunction, która dziedziczy po DifferentiableFunction.\nJej konstruktor (__init__) powinien przyjmować następujące argumenty:\n\nbase (opcjonalny): Podstawa funkcji eksponencjalnej (domyślnie math.e).\nname (opcjonalny): Nazwa funkcji eksponencjalnej.\n\nZaimplementuj metodę __call__(self, x), która oblicza wartość funkcji eksponencjalnej dla danego x przy użyciu funkcji z modułu math.\nZaimplementuj metodę __str__(self), która zwraca opis funkcji eksponencjalnej na podstawie jej podstawy.\nZaimplementuj metodę derivative(self), która oblicza wartość pochodnej funkcji eksponencjalnej w punkcie x i zwraca nowy obiekt klasy ExponentialFunction reprezentujący tę pochodną.\n\n\nPrzykładowe użycie klas:\nPoniżej znajdują się przykłady użycia zdefiniowanych klas. Możesz je umieścić w jednej komórce kodu w Jupyter Notebook.\n\nfrom functions import (\n    RealFunction,\n    DifferentiableFunction,\n    PolynomialFunction,\n    SineFunction,\n    ExponentialFunction,\n)\nimport math\n\n# Przykłady użycia\n\n# Funkcja wielomianowa: 3x^2 - 2x + 1\np = PolynomialFunction([3, -2, 1], name=\"Wielomian Kwadratowy\")\nprint(p)\nprint(p(2))\npochodna_p = p.derivative()\nprint(pochodna_p)\nprint(pochodna_p(2))\n\n# Funkcja sinus: 2*sin(0.5*x + 0.3)\ns = SineFunction(amplitude=2, frequency=0.5, phase=0.3, name=\"Funkcja Sinus\")\nprint(s)\nprint(s(math.pi))\npochodna_s = s.derivative()\nprint(pochodna_s)\nprint(pochodna_s(math.pi))\n\n# Funkcja eksponencjalna: 2^x\ne = ExponentialFunction(base=2, name=\"Funkcja Eksponencjalna\")\nprint(e)\nprint(e(3))\npochodna_e = e.derivative()\nprint(pochodna_e(3))\n\n\n# Przykład użycia DifferentiableFunction z funkcją\ndef f(x):\n    return x**2 + 2 * x + 1\n\ndf = DifferentiableFunction(f, name=\"Funkcja kwadratowa\")\nprint(df(3))  # Wypisze 16\npochodna_df = df.derivative()\nprint(pochodna_df(3))  # Wypisze przybliżoną wartość pochodnej f(x) w x=3, czyli 8"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-functions.html#zadanie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-functions.html#zadanie",
    "title": "Hierarchia Funkcji",
    "section": "",
    "text": "Celem tego ćwiczenia jest praktyczne zastosowanie dziedziczenia w Pythonie do stworzenia hierarchii klas reprezentujących różne typy funkcji matematycznych. Zaimplementujesz klasy dla funkcji rzeczywistych, funkcji różniczkowalnych oraz konkretnych przypadków - funkcji wielomianowych, sinusoidalnych i eksponencjalnych.\n\nKlasa bazowa RealFunction:\n\nZdefiniuj klasę RealFunction.\nJej konstruktor (__init__) powinien przyjmować dwa argumenty:\n\nfunc: Obiekt wywoływalny (np. funkcja lambda lub zwykła funkcja Pythona), który reprezentuje daną funkcję matematyczną.\nname (opcjonalny): Ciąg znaków opisujący nazwę funkcji.\n\nZaimplementuj metodę __call__(self, x), która przyjmuje argument x (liczbę rzeczywistą) i zwraca wynik wywołania przechowywanej funkcji func z tym argumentem.\nZaimplementuj metodę __str__(self), która zwraca opis funkcji (np. jej nazwę).\n\nKlasa pochodna DifferentiableFunction:\n\nZdefiniuj klasę DifferentiableFunction, która dziedziczy po RealFunction.\nJej konstruktor (__init__) powinien zachowywać się tak samo jak konstruktor klasy bazowej, przekazując argumenty do super().__init__(func, name).\nZaimplementuj metodę derivative(self, h=1e-7), która przybliża wartość pochodnej funkcji w punkcie x przy użyciu symetrycznego ilorazu różnicowego:\n\\[\\frac{f(x + h) - f(x - h)}{2h}\\]\ngdzie \\(f\\) to funkcja reprezentowana przez instancję klasy, a \\(h\\) jest małą wartością kroku (domyślnie \\(10^{-7}\\)). Metoda ta powinna zwracać obiekt RealFunction odpowiadający przybliżonej wartości pochodnej w punkcie x.\n\nKlasa pochodna PolynomialFunction:\n\nZdefiniuj klasę PolynomialFunction, która dziedziczy po DifferentiableFunction.\nJej konstruktor (__init__) powinien przyjmować dwa argumenty:\n\ncoefficients: Lista liczb reprezentujących współczynniki wielomianu. Pierwszy element listy odpowiada współczynnikowi przy najwyższej potędze, a ostatni - wyrazowi wolnemu. Na przykład, dla wielomianu \\(3x^2 - 2x + 1\\), lista współczynników to [3, -2, 1].\nname (opcjonalny): Nazwa wielomianu.\n\nZaimplementuj metodę __call__(self, x), która oblicza wartość wielomianu dla danego x przy użyciu schematu Hornera. Zaimplementuj w tym celu pomocniczą (np. prywatną) metodę __evaluate_polynomial(self, x, coeffs).\nZaimplementuj metodę __str__(self), która zwraca opis wielomianu na podstawie jego współczynników. Powinna ona tworzyć łańcuch znaków reprezentujący wielomian w standardowej formie (np. 3x^2 - 2x + 1).\nZaimplementuj metodę derivative(self), która oblicza wartość pochodnej wielomianu w punkcie x i zwraca nowy obiekt klasy PolynomialFunction reprezentujący tę pochodną.\n\nKlasa pochodna SineFunction:\n\nZdefiniuj klasę SineFunction, która dziedziczy po DifferentiableFunction.\nJej konstruktor (__init__) powinien przyjmować następujące argumenty:\n\namplitude (opcjonalny): Amplituda funkcji sinus (domyślnie 1.0).\nfrequency (opcjonalny): Częstotliwość funkcji sinus (domyślnie 1.0).\nphase (opcjonalny): Faza funkcji sinus (domyślnie 0.0).\nname (opcjonalny): Nazwa funkcji sinus.\n\nZaimplementuj metodę __call__(self, x), która oblicza wartość funkcji sinus dla danego x przy użyciu funkcji z modułu math.\nZaimplementuj metodę __str__(self), która zwraca opis funkcji sinus na podstawie jej parametrów (amplituda, częstotliwość, faza).\nZaimplementuj metodę derivative(self), która oblicza wartość pochodnej funkcji sinus w punkcie x i zwraca nowy obiekt klasy SineFunction reprezentujący tę pochodną.\n\nKlasa pochodna ExponentialFunction:\n\nZdefiniuj klasę ExponentialFunction, która dziedziczy po DifferentiableFunction.\nJej konstruktor (__init__) powinien przyjmować następujące argumenty:\n\nbase (opcjonalny): Podstawa funkcji eksponencjalnej (domyślnie math.e).\nname (opcjonalny): Nazwa funkcji eksponencjalnej.\n\nZaimplementuj metodę __call__(self, x), która oblicza wartość funkcji eksponencjalnej dla danego x przy użyciu funkcji z modułu math.\nZaimplementuj metodę __str__(self), która zwraca opis funkcji eksponencjalnej na podstawie jej podstawy.\nZaimplementuj metodę derivative(self), która oblicza wartość pochodnej funkcji eksponencjalnej w punkcie x i zwraca nowy obiekt klasy ExponentialFunction reprezentujący tę pochodną.\n\n\nPrzykładowe użycie klas:\nPoniżej znajdują się przykłady użycia zdefiniowanych klas. Możesz je umieścić w jednej komórce kodu w Jupyter Notebook.\n\nfrom functions import (\n    RealFunction,\n    DifferentiableFunction,\n    PolynomialFunction,\n    SineFunction,\n    ExponentialFunction,\n)\nimport math\n\n# Przykłady użycia\n\n# Funkcja wielomianowa: 3x^2 - 2x + 1\np = PolynomialFunction([3, -2, 1], name=\"Wielomian Kwadratowy\")\nprint(p)\nprint(p(2))\npochodna_p = p.derivative()\nprint(pochodna_p)\nprint(pochodna_p(2))\n\n# Funkcja sinus: 2*sin(0.5*x + 0.3)\ns = SineFunction(amplitude=2, frequency=0.5, phase=0.3, name=\"Funkcja Sinus\")\nprint(s)\nprint(s(math.pi))\npochodna_s = s.derivative()\nprint(pochodna_s)\nprint(pochodna_s(math.pi))\n\n# Funkcja eksponencjalna: 2^x\ne = ExponentialFunction(base=2, name=\"Funkcja Eksponencjalna\")\nprint(e)\nprint(e(3))\npochodna_e = e.derivative()\nprint(pochodna_e(3))\n\n\n# Przykład użycia DifferentiableFunction z funkcją\ndef f(x):\n    return x**2 + 2 * x + 1\n\ndf = DifferentiableFunction(f, name=\"Funkcja kwadratowa\")\nprint(df(3))  # Wypisze 16\npochodna_df = df.derivative()\nprint(pochodna_df(3))  # Wypisze przybliżoną wartość pochodnej f(x) w x=3, czyli 8"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-functions.html#rozwiązanie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-functions.html#rozwiązanie",
    "title": "Hierarchia Funkcji",
    "section": "Rozwiązanie",
    "text": "Rozwiązanie\n\n#!/usr/bin/env python3\n\"\"\"Implementacja funkcji rzeczywistych w Pythonie.\"\"\"\n\nimport math\nfrom collections.abc import Callable\n\n\nclass RealFunction:\n    \"\"\"Klasa bazowa reprezentująca funkcję rzeczywistą.\"\"\"\n\n    def __init__(self, func: Callable[[float], float], name: str | None = None):\n        self.func = func\n        self.name = name\n\n    def __call__(self, x: float) -&gt; float:\n        return self.func(x)\n\n    def __str__(self) -&gt; str:\n        return self.name if self.name else \"Anonimowa funkcja\"\n\n\nclass DifferentiableFunction(RealFunction):\n    \"\"\"Klasa reprezentująca funkcję różniczkowalną.\"\"\"\n\n    def __init__(self, func: Callable[[float], float], name: str | None = None):\n        super().__init__(func, name)\n\n    def derivative(self, h: float = 1e-7) -&gt; \"RealFunction\":\n        \"\"\"Oblicza pochodną funkcji w punkcie x przy użyciu różnic centralnych.\"\"\"\n        return RealFunction(\n            lambda x: (self.func(x + h) - self.func(x - h)) / (2 * h),\n            name=f\"Pochodna {self.name}\" if self.name else None,\n        )\n\n\nclass PolynomialFunction(DifferentiableFunction):\n    \"\"\"Klasa reprezentująca funkcję wielomianową.\"\"\"\n\n    def __init__(self, coefficients: list[float], name: str | None = None):\n        super().__init__(lambda x: self._evaluate_polynomial(x, coefficients), name)\n        self.coefficients = coefficients\n\n    def _evaluate_polynomial(self, x: float, coeffs: list[float]) -&gt; float:\n        \"\"\"Oblicza wartość wielomianu dla danego x używając schematu Hornera.\"\"\"\n        result = 0\n        for coeff in coeffs:\n            result = result * x + coeff\n        return result\n\n    def __str__(self) -&gt; str:\n        terms = []\n        for i, coeff in enumerate(self.coefficients):\n            power = len(self.coefficients) - 1 - i\n            if coeff:\n                term = (\n                    f\"{'+' if coeff &gt; 0 and i &gt; 0 else ''}\"\n                    f\" {'-' if coeff &lt; 0 else ''}\"\n                )\n                if abs(coeff) != 1 or power == 0:\n                    term += str(abs(coeff))\n                if power &gt; 0:\n                    term += \"x\" + (f\"^{power}\" if power &gt; 1 else \"\")\n                terms.append(term)\n        return \"\".join(terms) or \"0\"\n\n    def derivative(self) -&gt; \"PolynomialFunction\":\n        \"\"\"Oblicza pochodną wielomianu i zwraca nowy obiekt PolynomialFunction.\"\"\"\n        if not self.coefficients:\n            return PolynomialFunction([])\n        derivative_coeffs = []\n        for i, coeff in enumerate(self.coefficients[:-1]):\n            derivative_coeffs.append(coeff * (len(self.coefficients) - 1 - i))\n        return PolynomialFunction(\n            derivative_coeffs,\n            name=f\"Pochodna {self.name}\" if self.name else None,\n        )\n\n\nclass SineFunction(DifferentiableFunction):\n    \"\"\"Klasa reprezentująca funkcję sinus.\"\"\"\n\n    def __init__(\n        self,\n        amplitude: float = 1.0,\n        frequency: float = 1.0,\n        phase: float = 0.0,\n        name: str | None = None,\n    ):\n        super().__init__(lambda x: amplitude * math.sin(frequency * x + phase), name)\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase = phase\n\n    def __str__(self) -&gt; str:\n        amplitude = f\"{self.amplitude} * \" if self.amplitude != 1 else \"\"\n        s = f\"{amplitude}sin({self.frequency}*x\"\n        if self.phase != 0:\n            s += f\"+{self.phase}\"\n        s += \")\"\n        return s\n\n    def derivative(self) -&gt; \"SineFunction\":\n        \"\"\"Oblicza pochodną funkcji sinus i zwraca nowy obiekt SineFunction.\"\"\"\n        # Pochodna amplitude * sin(frequency * x + phase)\n        # to amplitude * frequency * cos(frequency * x + phase)\n        return SineFunction(\n            amplitude=self.amplitude * self.frequency,\n            frequency=self.frequency,\n            phase=self.phase + math.pi / 2,\n            name=f\"Pochodna {self.name}\" if self.name else None,\n        )\n\n\nclass ExponentialFunction(DifferentiableFunction):\n    \"\"\"Klasa reprezentująca funkcję eksponencjalną.\"\"\"\n\n    def __init__(\n        self,\n        base: float = math.e,\n        scalar: float = 1.0,\n        name: str | None = None,\n    ):\n        super().__init__(lambda x: scalar * base**x, name)\n        self.base = base\n        self.scalar = scalar\n\n    def __str__(self) -&gt; str:\n        return (\n            f\"{self.scalar} * {self.base} ^ x\"\n            if self.scalar != 1.0\n            else f\"{self.base} ^ x\"\n        )\n\n    def derivative(self) -&gt; \"ExponentialFunction\":\n        \"\"\"Oblicza pochodną funkcji eksponencjalnej.\"\"\"\n        return ExponentialFunction(\n            base=self.base,\n            scalar=self.scalar * math.log(self.base),\n            name=f\"Pochodna {self.name}\" if self.name else None,\n        )"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025.html",
    "title": "Programowanie (PWr Lato 2025)",
    "section": "",
    "text": "Laboratoria komputerowe do wykładu Andrzeja Giniewicza."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025.html#terminy-zajęć",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025.html#terminy-zajęć",
    "title": "Programowanie (PWr Lato 2025)",
    "section": "Terminy zajęć",
    "text": "Terminy zajęć\nW maju i czerwcu czeka nas kilka zmian w planie zajęć. Poniżej lista naszych spotkań:\n\nGrupa PoniedziałkowaGrupa Czwartkowa\n\n\n\n\n5 maja 2025, Poniedziałek\n\n\n14 maja 2025, Środa\n\n\n19 maja 2025, Poniedziałek\n\n\n26 maja 2025, Poniedziałek (Excel lista formuły)\n\n2 czerwca 2025, Poniedziałek (Excel lista makra)\n10 czerwca 2025, Wtorek (sprawozdanie z Excela)\n23 czerwca 2025, Poniedziałek (prezentacje projektów)\n\n\n\n\n\n8 maja 2025, Czwartek\n\n\n15 maja 2025, Czwartek\n\n\n29 maja 2025, Czwartek (Python)\n\n5 czerwca 2025, Czwartek (Python)\n9 czerwca 2025, Poniedziałek (Excel lista formuły)\n17 czerwca 2025, Wtorek (Excel lista makra)\n25 czerwca 2025, Środa (sprawozdanie z Excela)\n26 czerwca 2025, Czwartek (prezentacje projektów)"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025.html#zasady-zaliczenia",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025.html#zasady-zaliczenia",
    "title": "Programowanie (PWr Lato 2025)",
    "section": "Zasady zaliczenia",
    "text": "Zasady zaliczenia\nOgólne zasady zaliczenia kursu można znaleźć na stronie kursu u wykładowcy.\nDoprecyzowania obowiazujace w moich grupach:\n\nListy zadańProjektSprawozdanieAktywność\n\n\nCo najmniej pierwsze 3 listy będziemy robić na zajęciach, w systemie deklaracyjnym. Po zajęciach proszę o przesłanie rozwiązań. Kolejne listy zadań będą w formie zadań domowych, do zrobienia i przesłania przed zajęciami. Rozwiązania będą omiawiane i wyrywkowo sprawdzane w trakcie zajęć.\n\n\nSzczegóły projektu na wykładzie. Na labach będziemy omawiać problemy i pytania wyrastające przy projekcie. Można będzie konsultować decyzje projektowe i techniczne. Na ochotnika przedstawiać sprytne rozwiązania zastosowane w programie, za punkty z aktywności.\nObowiązuje jeden update w trakcie oraz prezentacja na koniec. Będziecie głosować na najciekawszy merytorycznie projekt. Ja wybiorę jeden projekt najlepszy technicznie. Oba dostaną dodatkowe punkty.\nZespoły mogą być łączone pomiędzy moimi dwoma grupami, natomiast na prezentację końcową musi pojawić się cała grupa w jednym terminie.\n\n\nSprawozdanie tworzone na arkuszu Excel, z wykorzystaniem VBA. Z powodów technicznych będzie robione na zajęciach.\n\n\nMożna zdobyć maks 10 punktów z poza puli na części z list zadań i maks 10 na części projektowej."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025.html#materiały-z-zajęć",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025.html#materiały-z-zajęć",
    "title": "Programowanie (PWr Lato 2025)",
    "section": "Materiały z zajęć",
    "text": "Materiały z zajęć\n\nKomentarze do list zadań\nZarządzanie środowiskami\nLogowanie\nLiczby dualne\nHierarchia funkcji\nGra w Życie\nPythonw - tryb oknowy\nRuff - narzędzie do analizy kodu\nLeetCode - zadania programistyczne"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025.html#polecane-źródła",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025.html#polecane-źródła",
    "title": "Programowanie (PWr Lato 2025)",
    "section": "Polecane źródła",
    "text": "Polecane źródła\n\nPython mniej poważnie. Zabawne projekty programistyczne, które zwiększą Twoje umiejętności, Lee Vaughan\nMatematyka konkretna, Graham Ronald L., Knuth Donald E., Oren Patashnik\nWprowadzenie do algorytmów, Cormen Thomas H., Leiserson Charles E., Rivest Ronald L, Clifford Stein\nCzysty kod w Pythonie, Sunil Kapil"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html",
    "title": "Programowanie (PWr Lato 2025) Komentarze do list",
    "section": "",
    "text": "Nazwa pliku z rozwiązaniami listy x powinna być następująca {nr_indeksu}_lista_{x}.py. Struktura pliku poniższa:\n\n# Funkcje pomocnicze do zadania 1\n\ndef zadanie_1(): ...\n\n# Funkcje pomocnicze do zadania 2\n\ndef zadanie_2(): ...\n\n# Funkcje pomocnicze do zadania 3\n\ndef zadanie_3(): ...\n\nif __name__ == \"__main__\"\":\n    zadanie_1()\n    zadanie_2()\n    zadanie_3()"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#format-rozwiązań",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#format-rozwiązań",
    "title": "Programowanie (PWr Lato 2025) Komentarze do list",
    "section": "",
    "text": "Nazwa pliku z rozwiązaniami listy x powinna być następująca {nr_indeksu}_lista_{x}.py. Struktura pliku poniższa:\n\n# Funkcje pomocnicze do zadania 1\n\ndef zadanie_1(): ...\n\n# Funkcje pomocnicze do zadania 2\n\ndef zadanie_2(): ...\n\n# Funkcje pomocnicze do zadania 3\n\ndef zadanie_3(): ...\n\nif __name__ == \"__main__\"\":\n    zadanie_1()\n    zadanie_2()\n    zadanie_3()"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#lista-1",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#lista-1",
    "title": "Programowanie (PWr Lato 2025) Komentarze do list",
    "section": "Lista 1",
    "text": "Lista 1\nKomentarze i ciekawostki:\n\nZdefiniowana funkcja “zna” swoją nazwę (i wie dużo więcej o sobie). Poniższa funkcja ma też docstring oraz zdefinowane typy wejścia i wyjścia. Zarówno anotacje, jak i magiczne metody zaczynające się od __ pojawią się dalej na wykładzie.\n\n\ndef minimum(lista: list[int]) -&gt; int:\n    \"\"\"Szukamy minimum.\"\"\"\n    return min(lista)\n\n\ndef maksimum(lista: list[int]) -&gt; int:\n    \"\"\"Szukamy maksimum.\"\"\"\n    return max(lista)\n\n\nfor funkcja in [maksimum, minimum]:\n    print(funkcja.__name__)\n    print(funkcja.__doc__)\n    print(funkcja.__annotations__)\n\nmaksimum\nSzukamy maksimum.\n{'lista': list[int], 'return': &lt;class 'int'&gt;}\nminimum\nSzukamy minimum.\n{'lista': list[int], 'return': &lt;class 'int'&gt;}\n\n\n\nW pythonie dobrą praktyką są krótkie linijki, maks 88 znaków. Łatwiej wtedy czyta się kod. Są do tego formattery, które robią to za nas. Ja polecam Ruff, dostępny jako wtyczka do VSC. Zamiast tego:\n\n\ndef generuj_liste_napisow_AB(dlugosc, dlugosc_napisu):\n    return [''.join(random.choices(['A', 'B'], weights=[95, 5], k=dlugosc_napisu)) for _ in range(dlugosc)]\n\nDostajemy:\n\ndef generuj_liste_napisow_AB(dlugosc, dlugosc_napisu):\n    return [\n        \"\".join(\n            random.choices(\n                [\"A\", \"B\"],\n                weights=[95, 5],\n                k=dlugosc_napisu,\n            )\n        )\n        for _ in range(dlugosc)\n    ]\n\n\nNie robimy tak:\n\n\ndef czy_jednomodalna(A):\n    maksima = maksima_lokalne(A)\n    if len(maksima) == 1:\n        return True\n    else:\n        return False\n\nTylko tak:\n\ndef czy_jednomodalna(A):\n    return len(maksima_lokalne(A)) == 1\n\n\nBiblioteka string posiada dużo pomocniczych opcji w zakresie napisów. Nie musimy wymieniać liter alfabetu, wystarczy użyć:\n\n\nimport string\n\nprint(string.ascii_lowercase)\n\nabcdefghijklmnopqrstuvwxyz\n\n\nPrzykładowe podejście do zadania 2, inne od wykładowego. Definujemy funkcję bisekcji oraz dekorator do pomiaru czasu:\n\nimport math\nfrom time import perf_counter_ns\n\nimport matplotlib.pyplot as plt\n\n\ndef measure_time(func, repeat=1):\n    \"\"\"Mierzy czas wykonania funkcji.\n\n    Zwraca funkcję owiniętą w pętlę powtórzeń.\n    Funkcja wynikowa zwraca listę czasów.\n    \"\"\"\n    def worker(*args, **kwargs):\n        times = []\n        for _ in range(repeat):\n            start_time = perf_counter_ns()\n            _ = func(*args, **kwargs)\n            end_time = perf_counter_ns()\n            times.append(end_time - start_time)\n        return sorted(times)\n\n    return worker\n\n\ndef bisection(\n    func, a: float, b: float, tol: float = 1e-6, max_iter: float = 1_000\n) -&gt; float:\n    if func(a) * func(b) &gt;= 0:\n        return None  # Brak gwarancji istnienia miejsca zerowego\n\n    for _ in range(max_iter):\n        c = (a + b) / 2\n        if abs(func(c)) &lt; tol:\n            return c\n        if func(c) * func(a) &lt; 0:\n            b = c\n        else:\n            a = c\n    return None\n\nMierzymy czas:\n\nimport math\n\n\ndef atan_minus_1(x):\n    return math.atan(x) - 1\n\n\nn_max = 1_000\nrepeat = 100\nns = list(range(1, n_max + 1))\nmeasure_bisection_time = measure_time(bisection, repeat=repeat)\ntime_lists = [(n, measure_bisection_time(atan_minus_1, 0.0, 10.0 * n)) for n in ns]\ntime_points = [\n    (float(n), time)\n    for n, times in time_lists\n    for time in times[repeat // 2 - 5 : repeat // 2 + 5]\n]\n\nPrzedstawiamy na wykresie:\n\nimport numpy as np\n\nx, y = zip(*time_points)\nfig, ax = plt.subplots()\nax.plot(x, y, \"o\", color=\"blue\")"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#lista-2",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#lista-2",
    "title": "Programowanie (PWr Lato 2025) Komentarze do list",
    "section": "Lista 2",
    "text": "Lista 2\n\nW opowiastce o Alfredzie, wczytując się dokładnie, mógł on się także cofać, co oznacza przyzwolenie na ujemne rozwiązania. Przyjmowałem też rozwiązania zakładające jedynie dodatnią ilośc skoków.\nNie robimy tak:\n\n\ndef moja_funkcja(k):\n    return k\n\n\nnazwa = \"moja_funkcja\"\nwynik = eval(nazwa)(1)\nprint(f\"Funkcja {nazwa} daje {wynik=}\")\n\nFunkcja moja_funkcja daje wynik=1\n\n\nFunkcja eval ma bardzo mało rozsądnych zastosowań, jest niebezpieczna, najlepiej zapomniec że istnieje. Zamiast tego:\n\nfunkcja = moja_funkcja\nwynik = moja_funkcja(1)\nprint(f\"Funkcja {funkcja.__name__} daje {wynik=}\")\n\nFunkcja moja_funkcja daje wynik=1\n\n\n\nStaramy się o czyste i jasne importy z modułów. Możemy robić tak:\n\n\nfrom math import ceil, gcd, lcm\n\nprint(lcm(gcd(10, 6), ceil(10 / 3)))\n\n4\n\n\n(kolejność funkcji alfabetyczna) lub tak\n\nimport math\n\nprint(math.lcm(math.gcd(10, 6), math.ceil(10 / 3)))\n\nStaramy się nie robić tak:\n\nfrom math import lcm, ceil\nimport math\n\nprint(lcm(math.gcd(10, 6), ceil(10 / 3)))\n\nNigdy nie robimy tak:\n\nfrom math import *"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#lista-3",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#lista-3",
    "title": "Programowanie (PWr Lato 2025) Komentarze do list",
    "section": "Lista 3",
    "text": "Lista 3\n\nW funkcji liczby_zaprzyjażnione można użyć cachowania aby dla każdej liczby liczyć jej sumę dzielników tylko raz.\n\n\ndef liczby_zaprzyjaźnione(N):\n    liczby = []\n    sumy_dzielników = [0] * (N + 1)\n    for a in range(2, N):\n        b = suma_dzielników(a)\n        sumy_dzielników[a] = b\n        if b &lt; a:\n            if sumy_dzielników[b] == a:\n                liczby.append((a, b))\n    return liczby\n\n\nIterując po obiekcie, chcąc znać indeks na ktorym jesteśmy używamy enumerate.\n\n\nlista = [\"a\", \"b\"]\n\n# nie robimy tak\nlicznik = 0\nfor litera in lista:\n    print(f\"{licznik}: {litera}\")\n    licznik += 1\n\n# tylko tak\nfor licznik, litera in enumerate(lista):\n    print(f\"{licznik}: {litera}\")\n\n0: a\n1: b\n0: a\n1: b\n\n\n\nSito Eratostenesa da się znacząco przyśpieszyć implementując je w NumPy.\n\n\nimport numpy as np\nimport time\n\n\ndef sito_listowe(limit):\n    \"\"\"Implementacja sita Eratostenesa przy użyciu list.\"\"\"\n    if limit &lt; 2:\n        return []\n    kandydaci = list(range(limit))\n    kandydaci[0] = None\n    kandydaci[1] = None\n    for liczba in kandydaci:\n        if liczba is None:\n            continue\n        if liczba * liczba &gt;= limit:\n            break\n        for wielokrotnosc in range(liczba * liczba, limit, liczba):\n            kandydaci[wielokrotnosc] = None\n    return [liczba for liczba in kandydaci if liczba is not None]\n\n\ndef sito_numpy(limit):\n    \"\"\"Implementacja sita Eratostenesa przy użyciu biblioteki NumPy.\"\"\"\n    if limit &lt; 2:\n        return np.array([], dtype=int)\n\n    czy_pierwsza = np.ones(limit + 1, dtype=bool)\n    czy_pierwsza[0:2] = False\n    for p in range(2, int(np.sqrt(limit)) + 1):\n        if czy_pierwsza[p]:\n            czy_pierwsza[p * p :: p] = False\n    return np.nonzero(czy_pierwsza)[0]\n\n\ndef mierz_czas_sita(funkcja, limit, nazwa_funkcji, powtorzenia=10):\n    \"\"\"Mierzy czas wykonania danej funkcji sita Eratostenesa.\"\"\"\n    czasy = []\n    for _ in range(powtorzenia):\n        czas_start = time.time()\n        wynik = funkcja(limit)\n        czas_koniec = time.time()\n        czasy.append(czas_koniec - czas_start)\n\n    minimalny_czas = min(czasy)\n    print(f\"{nazwa_funkcji} (limit={limit}):\")\n    print(f\"  Minimalny czas ({powtorzenia} uruchomień): {minimalny_czas:.6f} sekund\")\n    print(f\"  Liczba liczb pierwszych: {len(wynik)}\")\n\n\n# Przykładowe użycie i pomiar czasu\nlimit = 1_000_000\n\nprint(\"Pomiar czasu z limitem =\", limit)\nmierz_czas_sita(sito_numpy, limit, \"Sito NumPy (zoptymalizowane)\")\nmierz_czas_sita(sito_listowe, limit, \"Sito Listowe\")\n\nPomiar czasu z limitem = 1000000\nSito NumPy (zoptymalizowane) (limit=1000000):\n  Minimalny czas (10 uruchomień): 0.001593 sekund\n  Liczba liczb pierwszych: 78498\nSito Listowe (limit=1000000):\n  Minimalny czas (10 uruchomień): 0.081699 sekund\n  Liczba liczb pierwszych: 78498"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#lista-4",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-list-comments.html#lista-4",
    "title": "Programowanie (PWr Lato 2025) Komentarze do list",
    "section": "Lista 4",
    "text": "Lista 4\n\nCzęsto pojawia się policzenia powtórzeń elementów w liśicie:\n\n\nlista = [1, 2, 2, 1, 2, 3, 4, 2, 1, 3]\nwystapienia = {klucz: 0 for klucz in set(lista)}\nfor elem in lista:\n    wystapienia[elem] += 1\nprint(wystapienia)\n\n{1: 3, 2: 4, 3: 2, 4: 1}\n\n\nPython ma do tego wbudowaną funkcjonalność Counter:\n\nfrom collections import Counter\nwystapienia = Counter(lista)\nprint(wystapienia)\n\nCounter({2: 4, 1: 3, 3: 2, 4: 1})\n\n\n\nPodobnie mamy gotowe narzędzia do liczenia sum częściowych. Zamiast:\n\n\npozycje = {}\nsuma = 0\nklucze = sorted(wystapienia)\nfor klucz in klucze:\n    pozycje[klucz] = suma\n    suma += wystapienia[klucz]\nprint(pozycje)\n\n{1: 0, 2: 3, 3: 7, 4: 9}\n\n\nmożemy użyć accumulate:\n\nfrom itertools import accumulate\n\n\npozycje = dict(\n    zip(\n        klucze,\n        accumulate((wystapienia[k] for k in klucze), initial=0),\n    )\n)\nprint(pozycje)\n\n{1: 0, 2: 3, 3: 7, 4: 9}\n\n\n\nAlternatywne podejście do sortowania przez zliczanie. Dobry pretekst aby poznać defaultdict oraz chain.\n\n\nfrom collections import defaultdict\nfrom itertools import chain\n\n\ndef sortowanie_zliczanie(lista, klucze):\n    wystapienia = defaultdict(list)\n    for elem in lista:\n        wystapienia[elem].append(elem)\n    return list(\n        chain.from_iterable(\n            (wystapienia[klucz] for klucz in klucze),\n        )\n    )\n\n\nprint(\n    sortowanie_zliczanie(\n        [\"a\", \"c\", \"a\", \"b\", \"b\"],\n        klucze=(\"c\", \"b\", \"a\"),\n    )\n)\n\n['c', 'b', 'b', 'a', 'a']"
  },
  {
    "objectID": "pages/courses/uwr-odes-1a-2017.html",
    "href": "pages/courses/uwr-odes-1a-2017.html",
    "title": "Równania Różniczkowe 1A (UWr Lato 2017)",
    "section": "",
    "text": "Prowadzę jedną z grup ćwiczeniowych do wykładu Roberta Stańczego."
  },
  {
    "objectID": "pages/courses/uwr-odes-1a-2017.html#skrypty",
    "href": "pages/courses/uwr-odes-1a-2017.html#skrypty",
    "title": "Równania Różniczkowe 1A (UWr Lato 2017)",
    "section": "Skrypty",
    "text": "Skrypty\n\nRównania Różniczkowe Zwyczajne\n\nRaczyński, A. Skrypt do kursu\nPalczewski, A. Skrypt do zajęć na UW\nPalczewski, A. Zbiór zadań\n\n\n\nRównania Różniczkowe Cząstkowe\n\nRozwiązane zadania na metodę charakterystyk\nKarpiński, W.: Rozwiązane zadania z równań drugiego rzędu\nRozwiązane zadania na metodę rozdzielania zmiennych\n\n\n\nListy Zadań\n\nLista 1\nLista 2\nLista 3\nLista 4\nLista 5\nLista 6\nLista 7\nLista 8\nLista 9\nLista 10\nLista 11\nLista 12\nLista 13\nLista 14\nLista 15 - powtórzeniowa"
  },
  {
    "objectID": "pages/courses/uw-analysis-2017.html",
    "href": "pages/courses/uw-analysis-2017.html",
    "title": "Zajęcia wyrównawcze dla Analizy 1.2 (UW Lato 2017)",
    "section": "",
    "text": "W marcu prowadzę zajęcia wyrównawcze dla studentów pierwszego roku matematyki na MIMUW. Zajęcia odbędą się w celu przygotowania studentów do pierwszego kolokwium z Analizy 1.2.\nW trakcie zajęć będziemy zajmowali się zadaniami z “jawnej puli” dostępnymi tutaj.\nPrzykłady szczegółowego badania przebiegu funkcji zaczerpnięte z książki Analiza matematyczna 1 - Przykłady, zadania można znaleźć 1 tutaj."
  },
  {
    "objectID": "pages/courses/uw-analysis-2017.html#douczkowe-listy-zadań",
    "href": "pages/courses/uw-analysis-2017.html#douczkowe-listy-zadań",
    "title": "Zajęcia wyrównawcze dla Analizy 1.2 (UW Lato 2017)",
    "section": "Douczkowe listy zadań",
    "text": "Douczkowe listy zadań\n\nJednostajna ciągłość i wypukłość"
  },
  {
    "objectID": "pages/courses/uw-analysis-2016.html",
    "href": "pages/courses/uw-analysis-2016.html",
    "title": "Zajęcia wyrównawcze dla Analizy 1.1 (UW Zima 2016)",
    "section": "",
    "text": "W styczniu prowadzę zajęcia wyrównawcze dla studentów pierwszego roku matematyki na MIMUW.\nZajęcia odbędą się w celu przygotowania studentów do drugiego kolokwium z Analizy 1.1.\nW trakcie zajęć będziemy zajmowali się zadaniami z “jawnej puli” dostępnymi tutaj.\nW razie potrzeby będę umieszczał tu dodatkowe zadania i materiały.\n\n\n Back to top"
  },
  {
    "objectID": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024-list-comments.html",
    "href": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024-list-comments.html",
    "title": "Listy Python (PWr Zima 2024)",
    "section": "",
    "text": "Lista 1\nPython lista 1 - wyrażenia matematyczne\nLista zadań\n\nZamiast\n\nimport math\npole = math.pi * 10**2\n\nwarto użyć\n\nfrom math import pi\npole = pi * 10**2\n\nZmniejszamy ilość pisania przy wielokrotnym użyciu, a sam import jest wydajniejszy co może mieć znaczenie przy bardziej zaawansowanych zadaniach.\nFunkcje pierwiastka kwadratowego i podnoszenia do potęgi \\(1/2\\) są oczywiście równoważne, natomiast polecana jest math.sqrt. Mniej ogólne algorytmy są zazwyczaj lepiej zoptymalizowane (przy naszych zastosowaniach nie ma to jednak znaczenia).\n\nfrom math import sqrt\nx = 2\ny = sqrt(x)\nz = x**0.5\nprint(y, z, y == z)\n\n1.4142135623730951 1.4142135623730951 True\n\n\nW zadaniu 4 występuje funkcja podłoga $ x $. Jest to największa liczba całkowita mniejsza niż \\(x\\). W Pythonie można używać funkcji math.floor.\n\nfrom math import floor\nx = 2.5\ny = 2.9\nz = -3.1\nprint(floor(x), floor(y), floor(z))\n\n2 2 -4\n\n\nZadanie 5 pokazuje, jak ważne jest umiejetne korzystanie ze zmiennych pomocniczych.\n\nfrom math import sqrt, pi\n\nsuma_w_nawiasie = 5 ** 4 + 53 * sqrt(89)\n\nmianownik = 80 * sqrt(15) * suma_w_nawiasie ** (3/2)\nlicznik = 3308 * suma_w_nawiasie - 3 * sqrt(89)\npi_przyblizenie = mianownik / licznik\n\nprint(round(pi_przyblizenie, 10))\nprint(round(pi_przyblizenie, 10) == round(pi, 10))\n\n3.1415926536\nTrue\n\n\nW powyższym kodzie dużo łatwiej wyłapac bład niż w jednolinijkowym gigancie.\nDo zadania 6 wrócimy jeszcze raz po funkcjach i pętlach aby zaimplemetować dużo czytelniejsze rozwiązanie.\n\n\n\nLista 2\nPython lista 2 - napisy\nLista zadań\n\nW razie gdy chcemy sprawdzić, gdzie w systemie zapisany jest dany plik Python albo zeszyt Jupyter poniższe drukuje obecna ścieżkę robocza (Current Working Directory).\n\nimport os\nprint(os.getcwd())\n\n/Users/bwrob/repos/bwrob.github.io/pages/courses/pwr-intro-to-cs-2024\n\n\n\n\n\nLista 3\nPython lista 3 - listy i słowniki\nLista zadań\nKomentarze dla zaawansowanych:\nZadanie 2\nKluczem do pisania szybkiego kodu w Pythonie jest jak najczestsze kożystanie z wbudowanych funkcji, które wykonywane sa bezposrednio w języku niskopoziomowym.\nPrzykładowo, to zadanie można elegancko rozwiazac za pomoca wbudowaniej biblioteki itertools. Składaja się na nia pomocnicze funkcje rozwiazujace często potrzebne funkcjonalności dookoła iteratorów:\n\nfrom itertools import accumulate\nL = list(accumulate((-1) ** i / (i) for i in range(1, 101)))\nprint(L)\n\n[-1.0, -0.5, -0.8333333333333333, -0.5833333333333333, -0.7833333333333332, -0.6166666666666666, -0.7595238095238095, -0.6345238095238095, -0.7456349206349207, -0.6456349206349207, -0.7365440115440116, -0.6532106782106782, -0.7301337551337552, -0.6587051837051838, -0.7253718503718505, -0.6628718503718505, -0.7216953797836152, -0.6661398242280596, -0.718771403175428, -0.6687714031754279, -0.7163904507944756, -0.6709359053399302, -0.7144141662094954, -0.6727474995428288, -0.7127474995428288, -0.6742859610812904, -0.7113229981183273, -0.6756087124040416, -0.7100914710247312, -0.6767581376913979, -0.7090162022075269, -0.6777662022075269, -0.7080692325105572, -0.6786574678046748, -0.7072288963761034, -0.6794511185983256, -0.7064781456253526, -0.6801623561516684, -0.7058033817926941, -0.6808033817926941, -0.7051936256951331, -0.6813841018856093, -0.7046399158390977, -0.681912643111825, -0.7041348653340472, -0.6823957348992646, -0.7036723306439455, -0.6828389973106122, -0.7032471605759183, -0.6832471605759183, -0.7028550037131732, -0.683624234482404, -0.7024921590107058, -0.6839736404921873, -0.7021554586740055, -0.6842983158168626, -0.7018421754659854, -0.6846007961556405, -0.7015499486980133, -0.6848832820313466, -0.7012767246542975, -0.685147692396233, -0.7010207082692488, -0.6853957082692488, -0.7007803236538641, -0.685628808502349, -0.7005541816366774, -0.6858482992837363, -0.7003410529069246, -0.6860553386212104, -0.7001398456634639, -0.686250956774575, -0.6999495869115613, -0.6864360733980478, -0.6997694067313811, -0.686611511994539, -0.699598524981552, -0.6867780121610392, -0.6994362400091404, -0.6869362400091404, -0.6992819190214861, -0.6870867970702665, -0.6991349898413509, -0.687230227936589, -0.698994933818942, -0.6873670268421977, -0.698861279715761, -0.6874976433521246, -0.6987335984083044, -0.6876224872971933, -0.6986114982862043, -0.6877419330688129, -0.6984946212408559, -0.6878563233685155, -0.6983826391579893, -0.6879659724913226, -0.6982752508418381, -0.688071169209185, -0.698172179310195, -0.688172179310195]\n\n\nStosujemy tu potrójne złożenie generatorów. Generatory to obiekty, po których możemy iterować, a zwaracaja wartości pojedynczo. Często wykonywane jest to leniwie, dopiero kiedy sa o to zapytane.\n\nrange(1, 101) tworzy generator liczb od 1 do 100, nie trzyma tych liczb od razu w pamięci, tylko wie która jest następna.\n(func(n) for n in range(1, 101)) tworzy generator liczb od 1 do 100, a potem wykona operacje na nich.\naccumulate bierze coś po czym moźna iterować i operator binarny (domyślnie +) i zwraca generator częściowych wartości używania tego operatora na wszystkich elementach generatora.\nlist tworzy listę zawierajaca elementy złożonego generatora, zmusza do materializacji wynikow. Wszystko powyżej było tworzone leniwie.\n\nZadanie 5\nIterowanie się po wszystkich elementach zbioru często da się zastapić za pomoca matematycznych operacji na zbiorach, które sa dobrze zoptymalizowane.\n\nS = {\"dolnośląskie\", \"lubuskie\", \"wielkopolskie\"}\nM = {\"Wrocław\", \"Opole\", \"Zielona Góra\", \"Gorzów Wielkopolski\"}\nD = {\n    \"dolnośląskie\": {\"Wrocław\"},\n    \"kujawsko-pomorskie\": {\"Bydgoszcz\", \"Toruń\"},\n    \"lubelskie\": {\"Lublin\"},\n    \"lubuskie\": {\"Gorzów Wielkopolski\", \"Zielona Góra\"},\n    \"łódzkie\": {\"Łódź\"},\n    \"małopolskie\": {\"Kraków\"},\n    \"mazowieckie\": {\"Warszawa\"},\n    \"opolskie\": {\"Opole\"},\n    \"podkarpackie\": {\"Rzeszów\"},\n    \"podlaskie\": {\"Białystok\"},\n    \"pomorskie\": {\"Gdańsk\"},\n    \"śląskie\": {\"Katowice\"},\n    \"świętokrzyskie\": {\"Kielce\"},\n    \"warmińsko-mazurskie\": {\"Olsztyn\"},\n    \"wielkopolskie\": {\"Poznań\"},\n    \"zachodniopomorskie\": {\"Szczecin\"},\n}\n\nprint(set.union(*D.values()))\nprint({key for key, value in D.items() if value.intersection(M)})\n\n{'Toruń', 'Lublin', 'Łódź', 'Białystok', 'Katowice', 'Rzeszów', 'Opole', 'Gorzów Wielkopolski', 'Gdańsk', 'Kielce', 'Szczecin', 'Wrocław', 'Kraków', 'Poznań', 'Olsztyn', 'Warszawa', 'Bydgoszcz', 'Zielona Góra'}\n{'lubuskie', 'opolskie', 'dolnośląskie'}\n\n\nZadanie 6\nW Pythonie 3.8+ jest to możliwe za pomoca operatora := (walrus operator). Pozwala na tworzenie zmiennych pomocniczych wewnatrz wyrażeń języka.\n\nfrom math import sin, cos, radians\n\nn = 101\npunkty = {\n    (angle:=i * 360 / n): (cos(radians(angle)), sin(radians(angle)))\n    for i in range(n)\n}\nprint(punkty)\n\n{0.0: (1.0, 0.0), 3.5643564356435644: (0.9980655971335943, 0.06216963743148053), 7.128712871287129: (0.9922698723632765, 0.12409875261325935), 10.693069306930694: (0.9826352482222637, 0.18554775382949326), 14.257425742574258: (0.9691989991996661, 0.24627890683200138), 17.821782178217823: (0.9520131075327299, 0.30605725458788735), 21.386138613861387: (0.9311440620976595, 0.3646515262826552), 24.95049504950495: (0.9066726011770726, 0.4218350320620623), 28.514851485148515: (0.8786934000992688, 0.4773865400511271), 32.07920792079208: (0.8473147049577775, 0.531091132257275), 35.64356435643565: (0.8126579138282503, 0.5827410360463009), 39.20792079207921: (0.7748571071028898, 0.6321364279743265), 42.772277227722775: (0.7340585287594601, 0.6790862068658859), 46.336633663366335: (0.6904200205717468, 0.7234087331472497), 49.9009900990099: (0.6441104114503977, 0.7649325315746477), 53.46534653465346: (0.5953088642766661, 0.8034969546386757), 57.02970297029703: (0.5442041827560273, 0.8389528040783012), 60.59405940594059: (0.4909940809733222, 0.8711629080999505), 64.15841584158416: (0.4358844184753712, 0.90000265206853), 67.72277227722772: (0.3790884038403794, 0.9253604606172415), 71.2871287128713: (0.3208257698153676, 0.9471382293110002), 74.85148514851485: (0.26132192321286074, 0.9652517041934356), 78.41584158415841: (0.20080707285571844, 0.9796308077490816), 81.98019801980197: (0.13951533894392312, 0.9902199100196695), 85.54455445544555: (0.07768384728900624, 0.9969780438256293), 89.10891089108911: (0.015551811920350793, 0.9998790632601495), 92.67326732673267: (-0.046640390387417484, 0.9989117448426108), 96.23762376237623: (-0.10865215008547437, 0.9940798309400526), 99.8019801980198: (-0.17024355572239872, 0.9854020152886813), 103.36633663366337: (-0.23117632211496966, 0.9729118706714375), 106.93069306930693: (-0.2912147122272519, 0.9566577190314197), 110.4950495049505: (-0.3501264491913907, 0.936702444523675), 114.05940594059406: (-0.40768361494168887, 0.9131232502286187), 117.62376237623762: (-0.46366353198532706, 0.8860113594683149), 121.18811881188118: (-0.5178496248983254, 0.8554716628811638), 124.75247524752476: (-0.5700322582137827, 0.8216223126204006), 128.31683168316832: (-0.620009547460775, 0.7845942652463661), 131.88118811881188: (-0.6675881402161536, 0.7445307750810152), 135.44554455445544: (-0.7125839641475069, 0.7015868399847767), 139.009900990099: (-0.7548229391532569, 0.6559286016999402), 142.5742574257426: (-0.7941416508447535, 0.6077327030805316), 146.13861386138615: (-0.8303879827647975, 0.5571856046954285), 149.7029702970297: (-0.8634217048966635, 0.5044828634486399), 153.26732673267327: (-0.8931150161867917, 0.44982837600763564), 156.83168316831683: (-0.9193530389822364, 0.3934335899667523), 160.3960396039604: (-0.9420342634699891, 0.335516685797525), 163.96039603960395: (-0.9610709403987245, 0.2763017327508305), 167.52475247524754: (-0.976389420563607, 0.2160178219764834), 171.0891089108911: (-0.9879304397407567, 0.1548981802140847), 174.65346534653466: (-0.9956493479690186, 0.09317926748407171), 178.21782178217822: (-0.9995162822919881, 0.031099862269836753), 181.78217821782178: (-0.9995162822919881, -0.03109986226983695), 185.34653465346534: (-0.9956493479690186, -0.09317926748407147), 188.9108910891089: (-0.9879304397407568, -0.15489818021408447), 192.47524752475246: (-0.9763894205636071, -0.21601782197648314), 196.03960396039605: (-0.9610709403987245, -0.27630173275083025), 199.6039603960396: (-0.9420342634699891, -0.33551668579752525), 203.16831683168317: (-0.9193530389822363, -0.3934335899667525), 206.73267326732673: (-0.8931150161867916, -0.4498283760076358), 210.2970297029703: (-0.8634217048966636, -0.5044828634486397), 213.86138613861385: (-0.8303879827647976, -0.5571856046954283), 217.4257425742574: (-0.7941416508447537, -0.6077327030805314), 220.990099009901: (-0.754822939153257, -0.6559286016999399), 224.55445544554456: (-0.7125839641475068, -0.7015868399847768), 228.11881188118812: (-0.6675881402161534, -0.7445307750810153), 231.68316831683168: (-0.6200095474607752, -0.7845942652463659), 235.24752475247524: (-0.5700322582137832, -0.8216223126204003), 238.8118811881188: (-0.5178496248983256, -0.8554716628811637), 242.37623762376236: (-0.4636635319853273, -0.8860113594683149), 245.94059405940595: (-0.40768361494168853, -0.913123250228619), 249.5049504950495: (-0.3501264491913909, -0.9367024445236749), 253.06930693069307: (-0.291214712227252, -0.9566577190314197), 256.63366336633663: (-0.2311763221149701, -0.9729118706714374), 260.1980198019802: (-0.17024355572239874, -0.9854020152886813), 263.76237623762376: (-0.10865215008547438, -0.9940798309400526), 267.3267326732673: (-0.04664039038741795, -0.9989117448426108), 270.8910891089109: (0.015551811920350768, -0.9998790632601495), 274.45544554455444: (0.07768384728900554, -0.9969780438256294), 278.019801980198: (0.13951533894392268, -0.9902199100196695), 281.58415841584156: (0.20080707285571756, -0.9796308077490818), 285.1485148514852: (0.2613219232128609, -0.9652517041934355), 288.71287128712873: (0.3208257698153682, -0.947138229311), 292.2772277227723: (0.37908840384037934, -0.9253604606172415), 295.84158415841586: (0.4358844184753714, -0.9000026520685299), 299.4059405940594: (0.490994080973322, -0.8711629080999506), 302.970297029703: (0.5442041827560273, -0.8389528040783011), 306.53465346534654: (0.5953088642766663, -0.8034969546386754), 310.0990099009901: (0.6441104114503976, -0.7649325315746478), 313.66336633663366: (0.6904200205717469, -0.7234087331472497), 317.2277227722772: (0.7340585287594598, -0.6790862068658863), 320.7920792079208: (0.7748571071028897, -0.6321364279743266), 324.35643564356434: (0.8126579138282498, -0.5827410360463015), 327.9207920792079: (0.8473147049577773, -0.5310911322572754), 331.48514851485146: (0.8786934000992683, -0.4773865400511279), 335.0495049504951: (0.9066726011770727, -0.4218350320620621), 338.61386138613864: (0.9311440620976598, -0.3646515262826547), 342.1782178217822: (0.9520131075327298, -0.30605725458788735), 345.74257425742576: (0.9691989991996662, -0.2462789068320011), 349.3069306930693: (0.9826352482222637, -0.18554775382949354), 352.8712871287129: (0.9922698723632765, -0.12409875261325934), 356.43564356435644: (0.9980655971335943, -0.0621696374314802)}\n\n\nInna metoda jest użycie generatora wewnatrz listy składanej.\n\npunkty = {\n    angle: (cos(radians(angle)), sin(radians(angle)))\n    for angle in (i * 360 / n for i in range(n))\n}\nprint(punkty)\n\n{0.0: (1.0, 0.0), 3.5643564356435644: (0.9980655971335943, 0.06216963743148053), 7.128712871287129: (0.9922698723632765, 0.12409875261325935), 10.693069306930694: (0.9826352482222637, 0.18554775382949326), 14.257425742574258: (0.9691989991996661, 0.24627890683200138), 17.821782178217823: (0.9520131075327299, 0.30605725458788735), 21.386138613861387: (0.9311440620976595, 0.3646515262826552), 24.95049504950495: (0.9066726011770726, 0.4218350320620623), 28.514851485148515: (0.8786934000992688, 0.4773865400511271), 32.07920792079208: (0.8473147049577775, 0.531091132257275), 35.64356435643565: (0.8126579138282503, 0.5827410360463009), 39.20792079207921: (0.7748571071028898, 0.6321364279743265), 42.772277227722775: (0.7340585287594601, 0.6790862068658859), 46.336633663366335: (0.6904200205717468, 0.7234087331472497), 49.9009900990099: (0.6441104114503977, 0.7649325315746477), 53.46534653465346: (0.5953088642766661, 0.8034969546386757), 57.02970297029703: (0.5442041827560273, 0.8389528040783012), 60.59405940594059: (0.4909940809733222, 0.8711629080999505), 64.15841584158416: (0.4358844184753712, 0.90000265206853), 67.72277227722772: (0.3790884038403794, 0.9253604606172415), 71.2871287128713: (0.3208257698153676, 0.9471382293110002), 74.85148514851485: (0.26132192321286074, 0.9652517041934356), 78.41584158415841: (0.20080707285571844, 0.9796308077490816), 81.98019801980197: (0.13951533894392312, 0.9902199100196695), 85.54455445544555: (0.07768384728900624, 0.9969780438256293), 89.10891089108911: (0.015551811920350793, 0.9998790632601495), 92.67326732673267: (-0.046640390387417484, 0.9989117448426108), 96.23762376237623: (-0.10865215008547437, 0.9940798309400526), 99.8019801980198: (-0.17024355572239872, 0.9854020152886813), 103.36633663366337: (-0.23117632211496966, 0.9729118706714375), 106.93069306930693: (-0.2912147122272519, 0.9566577190314197), 110.4950495049505: (-0.3501264491913907, 0.936702444523675), 114.05940594059406: (-0.40768361494168887, 0.9131232502286187), 117.62376237623762: (-0.46366353198532706, 0.8860113594683149), 121.18811881188118: (-0.5178496248983254, 0.8554716628811638), 124.75247524752476: (-0.5700322582137827, 0.8216223126204006), 128.31683168316832: (-0.620009547460775, 0.7845942652463661), 131.88118811881188: (-0.6675881402161536, 0.7445307750810152), 135.44554455445544: (-0.7125839641475069, 0.7015868399847767), 139.009900990099: (-0.7548229391532569, 0.6559286016999402), 142.5742574257426: (-0.7941416508447535, 0.6077327030805316), 146.13861386138615: (-0.8303879827647975, 0.5571856046954285), 149.7029702970297: (-0.8634217048966635, 0.5044828634486399), 153.26732673267327: (-0.8931150161867917, 0.44982837600763564), 156.83168316831683: (-0.9193530389822364, 0.3934335899667523), 160.3960396039604: (-0.9420342634699891, 0.335516685797525), 163.96039603960395: (-0.9610709403987245, 0.2763017327508305), 167.52475247524754: (-0.976389420563607, 0.2160178219764834), 171.0891089108911: (-0.9879304397407567, 0.1548981802140847), 174.65346534653466: (-0.9956493479690186, 0.09317926748407171), 178.21782178217822: (-0.9995162822919881, 0.031099862269836753), 181.78217821782178: (-0.9995162822919881, -0.03109986226983695), 185.34653465346534: (-0.9956493479690186, -0.09317926748407147), 188.9108910891089: (-0.9879304397407568, -0.15489818021408447), 192.47524752475246: (-0.9763894205636071, -0.21601782197648314), 196.03960396039605: (-0.9610709403987245, -0.27630173275083025), 199.6039603960396: (-0.9420342634699891, -0.33551668579752525), 203.16831683168317: (-0.9193530389822363, -0.3934335899667525), 206.73267326732673: (-0.8931150161867916, -0.4498283760076358), 210.2970297029703: (-0.8634217048966636, -0.5044828634486397), 213.86138613861385: (-0.8303879827647976, -0.5571856046954283), 217.4257425742574: (-0.7941416508447537, -0.6077327030805314), 220.990099009901: (-0.754822939153257, -0.6559286016999399), 224.55445544554456: (-0.7125839641475068, -0.7015868399847768), 228.11881188118812: (-0.6675881402161534, -0.7445307750810153), 231.68316831683168: (-0.6200095474607752, -0.7845942652463659), 235.24752475247524: (-0.5700322582137832, -0.8216223126204003), 238.8118811881188: (-0.5178496248983256, -0.8554716628811637), 242.37623762376236: (-0.4636635319853273, -0.8860113594683149), 245.94059405940595: (-0.40768361494168853, -0.913123250228619), 249.5049504950495: (-0.3501264491913909, -0.9367024445236749), 253.06930693069307: (-0.291214712227252, -0.9566577190314197), 256.63366336633663: (-0.2311763221149701, -0.9729118706714374), 260.1980198019802: (-0.17024355572239874, -0.9854020152886813), 263.76237623762376: (-0.10865215008547438, -0.9940798309400526), 267.3267326732673: (-0.04664039038741795, -0.9989117448426108), 270.8910891089109: (0.015551811920350768, -0.9998790632601495), 274.45544554455444: (0.07768384728900554, -0.9969780438256294), 278.019801980198: (0.13951533894392268, -0.9902199100196695), 281.58415841584156: (0.20080707285571756, -0.9796308077490818), 285.1485148514852: (0.2613219232128609, -0.9652517041934355), 288.71287128712873: (0.3208257698153682, -0.947138229311), 292.2772277227723: (0.37908840384037934, -0.9253604606172415), 295.84158415841586: (0.4358844184753714, -0.9000026520685299), 299.4059405940594: (0.490994080973322, -0.8711629080999506), 302.970297029703: (0.5442041827560273, -0.8389528040783011), 306.53465346534654: (0.5953088642766663, -0.8034969546386754), 310.0990099009901: (0.6441104114503976, -0.7649325315746478), 313.66336633663366: (0.6904200205717469, -0.7234087331472497), 317.2277227722772: (0.7340585287594598, -0.6790862068658863), 320.7920792079208: (0.7748571071028897, -0.6321364279743266), 324.35643564356434: (0.8126579138282498, -0.5827410360463015), 327.9207920792079: (0.8473147049577773, -0.5310911322572754), 331.48514851485146: (0.8786934000992683, -0.4773865400511279), 335.0495049504951: (0.9066726011770727, -0.4218350320620621), 338.61386138613864: (0.9311440620976598, -0.3646515262826547), 342.1782178217822: (0.9520131075327298, -0.30605725458788735), 345.74257425742576: (0.9691989991996662, -0.2462789068320011), 349.3069306930693: (0.9826352482222637, -0.18554775382949354), 352.8712871287129: (0.9922698723632765, -0.12409875261325934), 356.43564356435644: (0.9980655971335943, -0.0621696374314802)}\n\n\nPlusem użycia generatora, a nie osobnej listy jest to, że jest on leniwie ewaluowany - jeden element na raz. Nie trzymamy katów w pamieci dwa razy.\n\n\nLista 4\nPython lista 4 - funkcje.\nLista zadań\n\nNa zajęciach zobaczyliśy jak zapisać zadanie Fizz Buzz bez porównania modulo 15:\n\ndef fizz_buzz(\n    liczba: int,\n) -&gt; str:\n    \"\"\"Wyznacz FizzBuzz dla liczby.\"\"\"\n    msg = \"\"\n    if liczba % 3 == 0:\n        msg += \"Fizz\"\n    if liczba % 5 == 0:\n        msg += \"Buzz\"\n    return msg or str(liczba)\n\n\nprint([fizz_buzz(i) for i in range(1, 16)])\n\n['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']\n\n\nJest to szczególnie istotne, jeżeli dodamy dodatkowo Mizz dla liczb podzielnych przez 7 i Duzz dla liczb podzielnych przez 8. Funkcję można wtedy jeszcze bardziej uprościć za pomoca słownika i listy składanej:\n\ndef fizz_buzz(\n    liczba: int,\n) -&gt; str:\n    \"\"\"Wyznacz FizzBuzz dla liczby.\"\"\"\n    msg = \"\"\n    mapa = {\n        3: \"Fizz\",\n        5: \"Buzz\",\n        7: \"Mizz\",\n        8: \"Duzz\",\n    }\n    lista_slow = [mapa[i] for i in mapa if liczba % i == 0]\n    msg = \"\".join(lista_slow)\n    return msg or str(liczba)\n\nprint([fizz_buzz(i) for i in range(1, 16)])\n\n['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', 'Mizz', 'Duzz', 'Fizz', 'Buzz', '11', 'Fizz', '13', 'Mizz', 'FizzBuzz']\n\n\nSprawdzanie wszystkich podzielności miesznych było by bardzo niekomfortowe.\n\n\n\nLista 5\nPython lista 5 - numpy, matplotlib.\nLista zadań\n\n\nLista 6\nPython lista 6 - testowanie, wyjatki\nLista zadań\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/hobbies.html",
    "href": "pages/hobbies.html",
    "title": "Fueling the Mind & Body: My Off-Duty Explorations.",
    "section": "",
    "text": "Supprisingly, I still have some hobbies outside technology and finance. This list is meant to be aspirational – i.e. sort of Instagram take on my interests to motivate me to invest more time into things I like. Too often I find myself in a work-sleep-work cycle that leaves little time for enjoyment.\n\n\nI have a PS5, a NS and a gaming PC. I play only single-player games, enjoy rouge-likes and open-worlds the most. My favorite games are God of War (2018), Hades and Trackmania. If your life’s companion is also a gamer (or just plays a little bit) i highly recommend It Takes Two.\n\n\n\n\n\n\n\n\nGot two cameras, old big hog Canon 450D and compact and sleek Sony A6000. I can make a decent portrait or Instagram ‘location photo’ but mosty interested in nature and urban settings. Would like to learn more on light and exposure usage, for now I am looking for contrasts and interesting compositions in my photos.\n\n\n\n\n\n\n\n\nClever ideas that fill and fuel natural sciences are often intimidating. Sure, there are occasional outliers – genius individuals that make history with revolutionary inventions. But most of the progress is achieved by a tectonic creep of incremental small wins and observations. All of those geniuses stood on the shoulders of giants that came before. The history of how those ideas and meanders of knowledge happened can be thrilling and educating.\n\n\n\n\n\n\n\n\nMaster chef of making tasty meal from leftovers. Specializing in Asian fusion cuisine. Fried rice with pulled tofu? Sushi with beetroot? Korean beef with sauerkraut? Yes, those are all delicious!\n\n\n\n\n\n\n\n\nI am a proud owner of 90’s vintage road bike. It was recently refurbished and looks smashing! It even has chipset print and binary code on the handles!\n\n\n\n\n\n\n\n\nYes, just strolling, but with a philosophy. No headphones, no distractions, no direction. Just observing what changed in the neighborhood I’ve lived in for the last 15 years, and what is happening inside. Think awareness meditation but while walking."
  },
  {
    "objectID": "pages/hobbies.html#road-cycling",
    "href": "pages/hobbies.html#road-cycling",
    "title": "Fueling the Mind & Body: My Off-Duty Explorations.",
    "section": "",
    "text": "I am a proud owner of 90’s vintage road bike. It was recently refurbished and looks smashing! It even has chipset print and binary code on the handles!"
  },
  {
    "objectID": "pages/hobbies.html#strolling.",
    "href": "pages/hobbies.html#strolling.",
    "title": "Fueling the Mind & Body: My Off-Duty Explorations.",
    "section": "",
    "text": "Yes, just strolling, but with a philosophy. No headphones, no distractions, no direction. Just observing what changed in the neighborhood I’ve lived in for the last 15 years, and what is happening inside. Think awareness meditation but while walking."
  },
  {
    "objectID": "pages/teaching.html",
    "href": "pages/teaching.html",
    "title": "Dydaktyka",
    "section": "",
    "text": "Programowanie"
  },
  {
    "objectID": "pages/teaching.html#semestr-letni-2435",
    "href": "pages/teaching.html#semestr-letni-2435",
    "title": "Dydaktyka",
    "section": "",
    "text": "Programowanie"
  },
  {
    "objectID": "pages/teaching.html#semestr-zimowy-2425",
    "href": "pages/teaching.html#semestr-zimowy-2425",
    "title": "Dydaktyka",
    "section": "Semestr zimowy 24/25",
    "text": "Semestr zimowy 24/25\n\nWstęp do programowania"
  },
  {
    "objectID": "pages/teaching.html#semestr-letni-1718",
    "href": "pages/teaching.html#semestr-letni-1718",
    "title": "Dydaktyka",
    "section": "Semestr letni 17/18",
    "text": "Semestr letni 17/18\n\nRównania różniczkowe 1\nRównania różniczkowe 1R"
  },
  {
    "objectID": "pages/teaching.html#semestr-letni-1617",
    "href": "pages/teaching.html#semestr-letni-1617",
    "title": "Dydaktyka",
    "section": "Semestr letni 16/17",
    "text": "Semestr letni 16/17\n\nNieliniowa analiza funkcjonalna\nRównania różniczkowe 1A\nZajęcia wyrównawcze z Analizy 1.2"
  },
  {
    "objectID": "pages/teaching.html#semestr-zimowy-1617",
    "href": "pages/teaching.html#semestr-zimowy-1617",
    "title": "Dydaktyka",
    "section": "Semestr zimowy 16/17",
    "text": "Semestr zimowy 16/17\n\nZajęcia wyrównawcze z Analizy 1.1"
  },
  {
    "objectID": "posts/sgh-investment-banking/index.html",
    "href": "posts/sgh-investment-banking/index.html",
    "title": "Investment Banking (PL)",
    "section": "",
    "text": "Polskie akty prawne:\n\nUstawa o funduszach inwestycyjnych i zarządzaniu alternatywnymi funduszami inwestycyjnymi z dnia 27 maja 2004 r. (Dz.U. 2004 nr 146, poz. 1546 ze zm.) – Jest to kluczowy akt prawny regulujący tworzenie, funkcjonowanie, zarządzanie, nadzór oraz likwidację funduszy inwestycyjnych i alternatywnych funduszy inwestycyjnych (AFI) w Polsce. Określa m.in. zasady emisji jednostek uczestnictwa/certyfikatów inwestycyjnych, obowiązki zarządzających (TFI, Zarządzających AFI) oraz depozytariuszy, a także podstawowe limity inwestyzyjne.\nRozporządzenia Ministra Finansów – Szczegółowe regulacje dotyczące np. sprawozdawczości funduszy, limitów inwestycyjnych czy zasad wyceny aktywów.\nAkty prawne Komisji Nadzoru Finansowego (KNF) – Decyzje, rekomendacje i wytyczne KNF, które uzupełniają ramy prawne i precyzują interpretacje przepisów.\n\nZagraniczne (unijne) akty prawne:\n\nDyrektywa UCITS (Undertakings for Collective Investment in Transferable Securities) – Dyrektywa 2009/65/WE (UCITS IV), zmieniona Dyrektywą 2014/91/UE (UCITS V) – Stanowi fundament europejskiego rynku funduszy otwartych. Reguluje harmonizację zasad dotyczących tworzenia, zarządzania i sprzedaży funduszy inwestycyjnych, które mogą być swobodnie oferowane w państwach członkowskich UE na zasadzie paszportu. Kluczowe obszary to:\n\nWymogi dotyczące organizacji i funkcjonowania funduszy.\nZasady dotyczące depozytariusza.\nWymogi dotyczące zarządzania ryzykiem i płynnością.\nObowiązki informacyjne wobec inwestorów.\n\nDyrektywa AIFMD (Alternative Investment Fund Managers Directive) – Dyrektywa 2011/61/UE – Reguluje zarządzających alternatywnymi funduszami inwestycyjnymi (AFI), czyli funduszami, które nie są objęte dyrektywą UCITS (np. fundusze hedgingowe, fundusze private equity, fundusze nieruchomości). Skupia się na autoryzacji i nadzorze zarządzających, zasadach wyceny, zarządzaniu ryzykiem, obowiązkach informacyjnych i zasadach dystrybucji.\nRozporządzenia MIFID II (Markets in Financial Instruments Directive) i MIFIR (Markets in Financial Instruments Regulation) – Wpływają na dystrybucję funduszy inwestycyjnych, wymagania w zakresie transparentności, ochrony inwestora, badania adekwatności i odpowiedniości.\n\n\n\n\nZarządzanie procesowe/zespołowe (ang. team-based approach) w asset management polega na tym, że decyzje inwestycyjne są podejmowane kolektywnie przez zespół zarządzających portfelem i analityków, w oparciu o zdefiniowane procesy i struktury, a nie przez pojedynczą osobę. Jest to podejście powszechnie stosowane w większych instytucjach.\nZalety:\n\nRedukcja ryzyka pojedynczego punktu awarii (Single Point of Failure - SPOF): Brak uzależnienia od jednej osoby (tzw. gwiazdy zarządzającej). Odejście kluczowego PM-a nie destabilizuje strategii ani wyników.\nSynergia wiedzy i doświadczenia: Różne perspektywy i specjalizacje (np. analityk akcji, analityk długu, specjalista od rynków wschodzących) prowadzą do bardziej wszechstronnej analizy i lepszych decyzji.\nSpójność i dyscyplina: Procesy decyzyjne są zazwyczaj bardziej ustrukturyzowane i zinstytucjonalizowane, co zapewnia większą spójność w podejściu do inwestycji i dyscyplinę w stosowaniu strategii.\nLepsza kontrola ryzyka: Decyzje są poddawane wzajemnej weryfikacji, co może prowadzić do wcześniejszego wychwytywania błędów lub nadmiernego ryzyka.\nSkalowalność: Model zespołowy jest łatwiejszy do skalowania w miarę wzrostu aktywów pod zarządzaniem i rozszerzania oferty produktowej.\nRozwój pracowników: Młodsi członkowie zespołu mogą uczyć się od bardziej doświadczonych kolegów, co sprzyja rozwojowi kompetencji.\n\nWady:\n\nWolniejszy proces decyzyjny: Konsensus wymaga czasu, co może być nieefektywne w dynamicznie zmieniających się warunkach rynkowych.\nRyzyko „myślenia grupowego” (Groupthink): Zespół może popadać w pułapkę konformizmu, ignorując alternatywne perspektywy, co może prowadzić do błędnych decyzji.\nRozmycie odpowiedzialności: W przypadku słabych wyników może być trudniej wskazać konkretną osobę odpowiedzialną.\nKonieczność silnego przywództwa: Brak wyraźnego lidera lub jego słabość może prowadzić do braku spójności w strategii i wewnętrznych konfliktów.\nWyższe koszty: Utrzymanie zespołu zarządzających i analityków jest droższe niż zatrudnienie jednej „gwiazdy”.\nPotencjalne konflikty interesów: Różne opinie i preferencje mogą prowadzić do sporów wewnętrznych, jeśli nie ma jasno zdefiniowanego procesu rozstrzygania.\n\n\n\n\nProces inwestycyjny w funduszu inwestycyjnym jest zorganizowanym cyklem, mającym na celu osiągnięcie założonych celów inwestycyjnych. Kluczowe etapy to:\n\nUstalenie Celów Inwestycyjnych i Strategii (Investment Policy Statement - IPS):\n\nOmówienie: Ten etap definiuje, co fundusz ma osiągnąć (np. stopa zwrotu, poziom ryzyka, horyzont czasowy, specyficzne wymogi płynnościowe czy etyczne). Tworzy się Investment Policy Statement (IPS), który jest formalnym dokumentem określającym cel funduszu, jego profil ryzyka, limity inwestycyjne, benchmarki, i ogólną strategię (np. value, growth, income, pasywna, aktywna). Jest to podstawa dla wszystkich kolejnych decyzji.\n\nAlokacja Aktywów (Asset Allocation):\n\nOmówienie: Jest to najważniejsza decyzja, która w dużej mierze determinuje długoterminowy wynik funduszu. Polega na podziale portfela na szerokie klasy aktywów (np. akcje, obligacje, nieruchomości, surowce, gotówka), regiony geograficzne czy sektory. Wyróżnia się:\n\nStrategiczną alokację aktywów (SAA): Długoterminowy rozkład aktywów, zgodny z IPS, określający “neutralny” portfel.\nTaktyczną alokację aktywów (TAA): Krótkoterminowe odchylenia od SAA, mające na celu wykorzystanie krótkoterminowych okazji rynkowych (np. przeważanie akcji w fazie wzrostu gospodarczego).\n\n\nWybór Papierów Wartościowych (Security Selection):\n\nOmówienie: Na tym etapie zarządzający podejmują decyzje o konkretnych instrumentach finansowych, które zostaną włączone do portfela w ramach każdej klasy aktywów. Może to być wynik analizy fundamentalnej (np. wybór konkretnych spółek na podstawie ich kondycji finansowej i perspektyw), analizy technicznej, czy analizy ilościowej. Celem jest znalezienie aktywów, które są niedowartościowane lub oferują atrakcyjny stosunek ryzyka do zwrotu.\n\nImplementacja i Wykonanie (Implementation and Execution):\n\nOmówienie: Decyzje inwestycyjne są przekładane na konkretne zlecenia kupna/sprzedaży. Ważne jest efektywne wykonanie transakcji, minimalizacja kosztów transakcyjnych (np. spread bid-ask, prowizje) oraz zarządzanie płynnością. Współpracuje się z brokerami i systemami handlowymi.\n\nMonitorowanie i Kontrola (Monitoring and Control):\n\nOmówienie: Ciągłe śledzenie wyników portfela, zgodności z celami inwestycyjnymi, limitami i regulacjami. Monitoruje się zmiany rynkowe, makroekonomiczne oraz specyficzne dla poszczególnych spółek/sektorów. W razie potrzeby dokonuje się rebalansowania portfela.\n\nOcena Wyników (Performance Evaluation):\n\nOmówienie: Regularna ocena wyników funduszu w stosunku do benchmarku, innych funduszy oraz założonych celów. Analizuje się nie tylko nominalną stopę zwrotu, ale także dostosowaną do ryzyka (np. wskaźnik Sharpe’a, Treynora). Ocena pomaga w identyfikacji źródeł sukcesów i niepowodzeń oraz w udoskonaleniu przyszłych strategii.\n\n\n\n\n\nBenchmark (indeks odniesienia) odgrywa fundamentalną rolę w procesie inwestycyjnym funduszu, pełniąc kilka kluczowych funkcji:\n\nDefiniowanie Celu Inwestycyjnego: Benchmark stanowi punkt odniesienia dla strategii inwestycyjnej funduszu. Określa horyzont inwestycyjny, klasy aktywów, regiony, sektory i styl inwestycyjny. Na przykład, fundusz akcji polskich o dużej kapitalizacji będzie miał za benchmark indeks WIG20.\nPomiar Wyników (Performance Measurement): Jest to najważniejsza funkcja benchmarku. Umożliwia obiektywną ocenę, czy zarządzający osiągnął zamierzony cel, tj. czy wygenerował dodatkową wartość (alfę) ponad pasywny zwrot z rynku. Stopa zwrotu funduszu jest zawsze porównywana ze stopą zwrotu benchmarku.\n\n\\[\n\\text{Nadwyżka Zwrotu (Alpha)} = \\text{Zwrot Funduszu} - \\text{Zwrot Benchmarku}\n\\]\n\nPodstawa Alokacji Aktywów: Benchmark często wyznacza ramy dla alokacji strategicznej. Np. w funduszach indeksowych portfel jest budowany tak, aby replikować skład benchmarku. W funduszach aktywnych, benchmark służy jako punkt wyjścia do podejmowania decyzji o przeważaniu/niedoważaniu sektorów czy spółek.\nZarządzanie Ryzykiem: Ryzyko aktywne (ryzyko benchmarkowe, tracking error) jest mierzone jako odchylenie stopy zwrotu funduszu od stopy zwrotu benchmarku. Pozwala to na monitorowanie, w jakim stopniu zarządzający odchodzi od składu indeksu i jakie ryzyko aktywne bierze na siebie.\n\n\\[\n\\text{Tracking Error (TE)} = \\sqrt{\\sum_{i=1}^{n} \\frac{(\\text{Zwrot Funduszu}_i - \\text{Zwrot Benchmarku}_i)^2}{n-1}}\n\\]\nGdzie: * \\(\\text{Zwrot Funduszu}_i\\) to zwrot funduszu w okresie \\(i\\). * \\(\\text{Zwrot Benchmarku}_i\\) to zwrot benchmarku w okresie \\(i\\). * \\(n\\) to liczba okresów.\n\nKomunikacja z Inwestorami: Benchmark dostarcza inwestorom jasnego i zrozumiałego punktu odniesienia do oceny efektywności zarządzania. Pomaga im zrozumieć, jaką ekspozycję rynkową przyjmuje fundusz i czego mogą się spodziewać.\nPodstawa dla Opłat za Zarządzanie: W niektórych modelach (np. performance fees) opłaty za zarządzanie mogą być powiązane z osiągnięciem wyników powyżej benchmarku.\n\n\n\n\nDobór odpowiedniego benchmarku jest kluczowym, choć często niedocenianym, elementem procesu inwestycyjnego. Niewłaściwy benchmark może prowadzić do błędnych ocen efektywności zarządzającego i niezrozumienia ryzyka. Kryteria doboru benchmarku obejmują:\n\nReprezentatywność: Benchmark powinien być jak najbardziej reprezentatywny dla rynku, na którym fundusz inwestuje lub dla klasy aktywów, którą zarządza. Powinien odzwierciedlać możliwości inwestycyjne i koszty transakcyjne, z jakimi mierzy się zarządzający. Np. dla funduszu akcji polskich WIG20 może być reprezentatywny dla dużych spółek, ale nie dla całego rynku.\nMierzalność: Benchmark musi być łatwo mierzalny i dostępny dla zarządzającego oraz inwestorów. Jego skład i metodologia obliczania powinny być transparentne.\nNiezależność: Benchmark powinien być niezależny od zarządzającego funduszem. Nie powinien być manipulowany ani modyfikowany przez zarządzającego w celu sztucznego poprawienia wyników.\nAdresowalność: Benchmark powinien odzwierciedlać obszar, w którym zarządzający faktycznie może inwestować. Jeśli fundusz ma limity uniemożliwiające inwestowanie w pewne aktywa z benchmarku, należy to uwzględnić.\nSpójność ze Stylem Inwestycyjnym: Jeśli fundusz ma styl value, growth czy small-cap, benchmark powinien również odzwierciedlać ten styl. Np. dla funduszu akcji małych spółek, odpowiedniejszy będzie indeks małych spółek, a nie szeroki indeks rynkowy.\nSpójność z Celami Funduszu: Benchmark musi być zgodny z celami inwestycyjnymi określonymi w IPS. Jeśli celem jest generowanie dochodu, benchmark powinien zawierać aktywa generujące dochód (np. indeks obligacji).\nWielkość i Płynność: Aktywa wchodzące w skład benchmarku powinny być wystarczająco płynne, aby fundusz mógł efektywnie nimi handlować, zwłaszcza w przypadku funduszy replikujących indeks.\nDostępność historycznych danych: Aby móc ocenić historyczne wyniki i ryzyko, konieczne są długie szeregi danych historycznych dla benchmarku.\n\nPraktyczne aspekty doboru:\n\nStandardowe indeksy: Często używa się szeroko znanych indeksów giełdowych (np. S&P 500, MSCI World, WIG20, WIBOR dla stopy procentowej).\nBenchmarki mieszane (Blended Benchmarks): Dla funduszy zrównoważonych lub multi-asset, tworzy się benchmarki składające się z kilku indeksów ważonych zgodnie ze strategiczną alokacją aktywów. Np. 60% WIG20 + 40% WIG Bond.\nWłasne benchmarki (Custom Benchmarks): W rzadkich przypadkach, dla bardzo specyficznych strategii, instytucje mogą tworzyć własne benchmarki, ale wymaga to uzasadnienia i transparentności.\n\n\n\n\nPodejście „Top Down” (odgórne) jest jedną z metod budowania portfela inwestycyjnego. Polega na podejmowaniu decyzji inwestycyjnych począwszy od analizy ogólnego otoczenia makroekonomicznego i globalnych trendów, a następnie stopniowym zawężaniu zakresu do konkretnych rynków, sektorów, by na końcu wybrać konkretne spółki lub instrumenty finansowe.\nEtapy podejścia Top Down:\n\nAnaliza Makroekonomiczna i Globalnych Trendów:\n\nRozpoczyna się od oceny globalnego krajobrazu gospodarczego: perspektywy wzrostu PKB, inflacja, stopy procentowe, polityka banków centralnych, geopolityka, trendy demograficzne, technologiczne i środowiskowe.\nNa tym etapie analizuje się, które regiony lub kraje będą miały najlepsze perspektywy wzrostu, biorąc pod uwagę cykl koniunkturalny.\n\nAlokacja Aktywów (Asset Allocation):\n\nNa podstawie analizy makro, zarządzający decydują o strategicznej i taktycznej alokacji aktywów pomiędzy różne klasy (akcje, obligacje, surowce, gotówka), geografie (np. rynki rozwinięte vs. rynki wschodzące) i waluty.\nDecyzje te są zorientowane na alokację kapitału do najbardziej perspektywicznych obszarów makro.\n\nWybór Sektorów i Branż:\n\nW ramach wybranych klas aktywów i regionów, identyfikuje się sektory i branże, które są najbardziej atrakcyjne w obecnym cyklu koniunkturalnym lub w obliczu długoterminowych trendów.\nNa przykład, w okresie szybkiego wzrostu gospodarczego mogą być faworyzowane sektory cykliczne (np. przemysł, materiały), a w okresie spowolnienia – defensywne (np. opieka zdrowotna, użyteczność publiczna).\n\nWybór Spółek/Instrumentów Finansowych:\n\nDopiero na samym końcu, w ramach wybranych sektorów, dokonuje się wyboru konkretnych spółek lub instrumentów finansowych. Wybór ten jest często podyktowany ich dominującą pozycją w sektorze, siłą finansową lub ekspozycją na określone trendy.\nAnaliza fundamentalna spółek jest wykorzystywana do potwierdzenia, czy konkretna spółka jest dobrym reprezentantem wybranego sektora i czy jej wycena jest atrakcyjna.\n\n\nCharakterystyka podejścia Top Down:\n\nHolistyczne spojrzenie: Koncentruje się na szerszym obrazie ekonomicznym i rynkowym.\nMakro czynniki: Główne decyzje są napędzane przez czynniki makroekonomiczne i trendy.\nDynamiczne: Pozwala na szybkie reagowanie na zmieniające się warunki rynkowe poprzez rebalansowanie alokacji aktywów.\nWysokie ryzyko systematyczne: Decyzje są często związane z całym rynkiem lub dużymi segmentami, co naraża portfel na ryzyko systematyczne.\n\nPodejście Top Down jest często stosowane przez dużych zarządzających aktywami, fundusze makro hedgingowe oraz fundusze globalne, gdzie alokacja strategiczna i taktyczna są kluczowe.\n\n\n\nW kontekście zarządzania portfelem funduszu zrównoważonego, decyzje o “przeważaniu” (overweight) lub “niedoważaniu” (underweight) odnoszą się do taktycznej alokacji aktywów lub selekcji sektorów/spółek względem ich wagi w benchmarku lub strategicznej alokacji aktywów.\nFundusz zrównoważony posiada typowo strategiczną alokację aktywów, np. \\(60\\%\\) akcji i \\(40\\%\\) obligacji. W ramach tego \\(60\\%\\) akcji, zarządzający może przyjąć pewne wagi sektorowe lub regionalne, które są zgodne z benchmarkiem lub jego neutralną alokacją.\n\nSilne przeważenie (+2):\n\nZnaczenie: Oznacza, że zarządzający świadomie zwiększa wagę danej klasy aktywów (np. akcji ogólnie w stosunku do obligacji), danego sektora, regionu lub konkretnej spółki w portfelu funduszu, znacząco powyżej jej neutralnej wagi w benchmarku lub strategicznej alokacji.\nCel: Decyzja o silnym przeważaniu wynika z bardzo silnego pozytywnego przekonania zarządzającego o przyszłych perspektywach danego aktywa/sektora/spółki. Oczekuje się, że ta pozycja wygeneruje istotną alfę (nadwyżkę stopy zwrotu) dla portfela.\nRyzyko: Jest to decyzja o relatywnie wysokim ryzyku aktywnym (tracking error). W przypadku błędnej oceny, silne przeważenie może znacząco negatywnie wpłynąć na wyniki funduszu względem benchmarku. \\(+2\\) sugeruje bardzo mocne odchylenie od wagi neutralnej.\nPrzykład: Jeśli strategiczna alokacja akcji w funduszu zrównoważonym wynosi \\(60\\%\\), a zarządzający decyduje się na silne przeważenie akcji, może to oznaczać, że ich udział w portfelu wzrośnie do \\(62\\%\\) lub więcej (np. nawet do \\(65-70\\%\\) w zależności od limitów i apetytu na ryzyko), kosztem innych klas aktywów. Podobnie, jeśli spółka X stanowi \\(2\\%\\) w benchmarku, a zarządzający silnie ją przeważa, może to oznaczać, że jej waga w portfelu wzrośnie do \\(4\\%\\) lub \\(5\\%\\).\n\nNiedoważenie (-1):\n\nZnaczenie: Oznacza, że zarządzający świadomie zmniejsza wagę danej klasy aktywów, sektora, regionu lub konkretnej spółki w portfelu funduszu, poniżej jej neutralnej wagi w benchmarku lub strategicznej alokacji.\nCel: Decyzja o niedoważeniu wynika z negatywnego przekonania zarządzającego o przyszłych perspektywach danego aktywa/sektora/spółki, lub z oczekiwania, że będzie ono radzić sobie gorzej niż benchmark. Ma to na celu ograniczenie spadków lub ochronę kapitału.\nRyzyko: Podobnie jak przeważenie, niedoważenie również generuje ryzyko aktywne. W przypadku błędnej oceny i nagłej poprawy wyników niedoważonego aktywa, fundusz może stracić szansę na zysk i zanotować gorsze wyniki niż benchmark. \\(-1\\) sugeruje umiarkowane do silnego odchylenia w dół.\nPrzykład: Jeśli strategiczna alokacja akcji wynosi \\(60\\%\\), a zarządzający decyduje się na niedoważenie akcji, ich udział w portfelu może spaść do \\(59\\%\\) lub mniej (np. do \\(55\\%\\) w zależności od limitów). Jeśli spółka Y stanowi \\(1\\%\\) w benchmarku, a zarządzający ją niedoważa, może to oznaczać, że jej waga w portfelu spadnie do \\(0.5\\%\\) lub nawet zostanie całkowicie wyeliminowana (\\(0\\%\\)).\n\n\nPodsumowując, “+2” i “-1” to wskaźniki intensywności taktycznych decyzji zarządzającego. Wyższe wartości bezwzględne oznaczają większe ryzyko aktywne (tracking error) i większy potencjał generowania lub tracenia alfy.\n\n\n\nLimity inwestycyjne są kluczowym elementem systemu zarządzania ryzykiem w funduszach inwestycyjnych. Służą ochronie kapitału inwestorów, zapewnieniu zgodności z polityką inwestycyjną funduszu i dywersyfikacji. Dzielą się na kategorie w zależności od poziomu agregacji i celu:\n\nLimity koncentracji (concentration limits):\n\nLimit pojedynczej emisji/emitenta: Ogranicza maksymalną wartość inwestycji w papiery wartościowe jednego emitenta lub jednej emisji (np. maksymalnie \\(5\\%\\) aktywów funduszu w akcjach spółki X). Ma to na celu ograniczenie ryzyka specyficznego.\nLimit branżowy/sektorowy: Ogranicza koncentrację w jednej branży lub sektorze (np. maksymalnie \\(20\\%\\) w sektorze finansowym). Zmniejsza to ryzyko związane ze spowolnieniem w danej branży.\nLimit geograficzny/regionalny: Ogranicza koncentrację w danym kraju lub regionie (np. maksymalnie \\(30\\%\\) aktywów w inwestycjach w Polsce).\nLimit typu instrumentu: Ogranicza udział poszczególnych rodzajów instrumentów (np. akcje, obligacje korporacyjne, instrumenty pochodne) w portfelu.\nLimit kapitałowy: Ogranicza maksymalny udział funduszu w kapitale zakładowym lub w liczbie głosów na walnym zgromadzeniu jednej spółki (np. maksymalnie \\(10\\%\\) akcji spółki X).\n\nLimity płynnościowe (liquidity limits):\n\nLimit aktywów niepłynnych: Ogranicza udział aktywów o niskiej płynności, które trudno byłoby sprzedać w krótkim czasie bez znaczącego wpływu na ich cenę (np. maksymalnie \\(10\\%\\) w aktywach niepublicznych lub trudno zbywalnych). Ma to na celu zapewnienie możliwości wykupu jednostek uczestnictwa przez fundusz.\nLimity instrumentów pochodnych: Ograniczenia dotyczące ekspozycji nominalnej lub ryzyka związanego z instrumentami pochodnymi, zapewniające, że ich wykorzystanie nie prowadzi do nadmiernego ryzyka płynnościowego.\n\nLimity kredytowe/kontrahenta (credit/counterparty limits):\n\nLimit na kontrahenta: Ogranicza maksymalną ekspozycję na pojedynczego kontrahenta (bank, broker) w transakcjach pozagiełdowych (OTC), takich jak instrumenty pochodne, operacje repo. Zmniejsza ryzyko kredytowe kontrahenta.\nLimit ratingowy: Określa minimalny wymagany rating kredytowy dla emitentów obligacji w portfelu. W funduszach obligacji bezpiecznych często wymagany jest rating inwestycyjny (np. BBB- lub wyżej).\n\nLimity ryzyka (risk limits):\n\nLimit Value-at-Risk (VaR): Określa maksymalną potencjalną stratę portfela w określonym horyzoncie czasowym i z danym poziomem ufności (np. \\(VaR_{99\\%}\\) na poziomie \\(2\\%\\) aktywów dziennie). \\[\\text{VaR} = \\text{Wartość Portfela} \\times \\sigma \\times z_{\\alpha}\\] Gdzie:\n\n\\(\\sigma\\) to odchylenie standardowe (zmienność) stopy zwrotu portfela.\n\\(z_{\\alpha}\\) to wartość z rozkładu normalnego odpowiadająca danemu poziomowi ufności.\n\nLimit Tracking Error (TE): Ogranicza maksymalne dopuszczalne odchylenie standardowe stopy zwrotu funduszu od stopy zwrotu benchmarku (np. TE nie może przekroczyć \\(4\\%\\)). Chroni przed nadmiernym ryzykiem aktywnym.\nLimit duration/convexity: W funduszach obligacji, limity te kontrolują wrażliwość portfela na zmiany stóp procentowych.\nLimity stop-loss: Automatyczne limity, które nakazują sprzedaż danego aktywa, jeśli jego cena spadnie poniżej określonego poziomu.\n\nLimity regulacyjne (regulatory limits):\n\nSą to limity narzucone przez przepisy prawa (np. wspomniana Ustawa o funduszach inwestycyjnych, dyrektywa UCITS). Mają charakter obligatoryjny i często są bardziej konserwatywne niż wewnętrzne limity funduszu.\n\n\n\n\n\nRola limitów inwestycyjnych jest kluczowa dla każdego funduszu inwestycyjnego, niezależnie od jego profilu ryzyka, ale ich znaczenie i specyfika zastosowania mogą się różnić.\nRola limitów inwestycyjnych:\n\nOchrona Kapitału Inwestorów: Jest to podstawowa funkcja. Limity zapobiegają nadmiernej koncentracji, niepłynności i nadmiernemu ryzyku, chroniąc inwestorów przed dużymi stratami.\nZapewnienie Zgodności z Polityką Inwestycyjną: Limity egzekwują, aby fundusz działał zgodnie ze swoim statutem i deklarowaną strategią, co jest kluczowe dla zaufania inwestorów i unikania style drift (dryfu stylu).\nDywersyfikacja Portfela: Poprzez narzucenie limitów koncentracji, limity wymuszają dywersyfikację, co jest podstawową zasadą zarządzania ryzykiem.\nZarządzanie Płynnością: Limity dotyczące aktywów niepłynnych są niezbędne do zapewnienia, że fundusz jest w stanie na bieżąco realizować żądania wykupu jednostek uczestnictwa.\nZgodność Regulacyjna: Fundusze są zobowiązane do przestrzegania limitów określonych w przepisach prawa (np. UCITS w UE, ustawa o funduszach w Polsce). Nieprzestrzeganie ich grozi karami i utratą licencji.\nUłatwienie Monitorowania Ryzyka: Systemy monitorowania ryzyka opierają się na limitach, generując alerty, gdy zbliżają się do nich lub zostają przekroczone.\n\nGdzie są najbardziej istotne: Fundusze bezpieczne vs. Fundusze wysokiego ryzyka?\nLimity są krytycznie istotne w funduszach bezpiecznych, takich jak fundusze pieniężne, krótkoterminowe obligacji skarbowych czy fundusze stabilnego wzrostu. Wynika to z następujących powodów:\n\nOczekiwania Inwestorów: Inwestorzy w fundusze bezpieczne mają niską tolerancję na ryzyko i oczekują stabilnego, przewidywalnego zwrotu. Każde znaczące odchylenie od tego profilu jest nieakceptowalne.\nRyzyko Reputacyjne: Duża strata w funduszu “bezpiecznym” może zniszczyć reputację całego towarzystwa funduszy inwestycyjnych.\nRegulacje: Fundusze bezpieczne, zwłaszcza pieniężne, są często objęte bardzo ścisłymi i restrykcyjnymi limitami regulacyjnymi dotyczącymi jakości kredytowej emitentów, duration, płynności i koncentracji. Ich celem jest minimalizacja ryzyka utraty kapitału.\nZachowanie Kapitału: Podstawowym celem tych funduszy jest zachowanie kapitału, a nie maksymalizacja zwrotu. Limity służą bezpośrednio temu celowi.\n\nJednakże limity są również bardzo istotne w funduszach podejmujących duże ryzyko inwestycyjne, choć ich natura i dopuszczalne poziomy będą inne:\n\nKontrola Ryzyka Ekstremalnego: Nawet w funduszach wysokiego ryzyka (np. fundusze akcji sektorowych, fundusze rynków wschodzących, fundusze hedgingowe), limity są niezbędne do kontrolowania ryzyka ekstremalnego (np. maksymalna koncentracja w pojedynczej spółce, maksymalna ekspozycja na instrumenty pochodne, limity VaR).\nZarządzanie Zadeklarowanym Ryzykiem: Limity pomagają utrzymać fundusz w ramach zadeklarowanego profilu ryzyka, nawet jeśli jest on wysoki. Zapobiegają to sytuacji, w której fundusz stanie się jeszcze bardziej ryzykowny niż pierwotnie zakładano.\nOgraniczenie Strat: Choć celują w wysokie zwroty, fundusze wysokiego ryzyka również muszą mieć mechanizmy ograniczające potencjalne straty, zwłaszcza w warunkach kryzysu rynkowego.\nZgodność z Mandatem: W przypadku funduszy hedgingowych czy alternatywnych, które mają szeroki zakres swobody inwestycyjnej, wewnętrzne limity są kluczowe do zdefiniowania i przestrzegania specyficznego mandatu inwestycyjnego.\n\nPodsumowując: Limity są uniwersalnym narzędziem zarządzania ryzykiem. W funduszach bezpiecznych są one bardziej restrykcyjne i skupiają się na ochronie kapitału. W funduszach wysokiego ryzyka są one elastyczniejsze, ale wciąż niezbędne do kontrolowania ekspozycji na ryzyko i zapobiegania katastrofalnym stratom, zapewniając, że ryzyko podejmowane jest w sposób kontrolowany i zgodny z profilem funduszu.\n\n\n\nSelekcja spółek (ang. security selection lub stock picking) do portfela funduszu inwestycyjnego jest zazwyczaj wynikiem dogłębnej analizy, która może opierać się na różnych podejściach, często łączonych ze sobą. Główne podstawy to:\n\nAnaliza Fundamentalna:\n\nOmówienie: Jest to najczęściej stosowane podejście. Polega na ocenie wewnętrznej wartości spółki (intrinsic value) poprzez analizę jej sprawozdań finansowych (bilans, rachunek zysków i strat, rachunek przepływów pieniężnych), modelu biznesowego, pozycji konkurencyjnej, jakości zarządzania, perspektyw wzrostu, otoczenia branżowego i makroekonomicznego.\nKluczowe wskaźniki i czynniki:\n\nWskaźniki wyceny: Cena/Zysk (P/E), Cena/Wartość Księgowa (P/BV), Cena/Sprzedaż (P/S), Wartość Przedsiębiorstwa/EBITDA (EV/EBITDA), Stopa Dywidendy.\nWskaźniki rentowności: ROE (Return on Equity), ROA (Return on Assets), Marża Zysku Brutto/Netto.\nWskaźniki zadłużenia: Dług netto/EBITDA, Dług/Kapitał Własny.\nWskaźniki płynności: Bieżąca płynność, szybka płynność.\nJakość zarządzania (qualitative factors): Doświadczenie, strategia, ład korporacyjny.\nPerspektywy branży i przewagi konkurencyjne: Bariery wejścia, siła negocjacyjna, innowacyjność.\n\nCel: Identyfikacja spółek niedowartościowanych (w stosunku do ich wewnętrznej wartości) lub tych z silnym potencjałem wzrostu. Podejścia value investing (inwestowanie w wartość) i growth investing (inwestowanie we wzrost) są podtypami analizy fundamentalnej.\n\nAnaliza Ilościowa (Quantitative Analysis):\n\nOmówienie: Wykorzystuje modele matematyczne, statystyczne i algorytmy do identyfikacji wzorców i relacji w danych rynkowych i fundamentalnych. Selekcja spółek opiera się na scoringu według wybranych kryteriów ilościowych.\nKluczowe wskaźniki i czynniki:\n\nWskaźniki momentum: Siła trendu cenowego.\nWskaźniki zmienności: Beta, odchylenie standardowe.\nWskaźniki jakości: Niska zmienność, stabilne zyski.\nCzynniki fundamentalne w ujęciu ilościowym: Np. spółki o niskim P/E, wysokiej stopie dywidendy, silnym wzroście EPS.\n\nCel: Systematyczne identyfikowanie spółek spełniających określone kryteria, często w celu budowy portfeli smart beta lub funduszy ilościowych.\n\nAnaliza Techniczna (Technical Analysis):\n\nOmówienie: W mniejszym stopniu stosowana w długoterminowych funduszach inwestycyjnych, częściej w funduszach hedgingowych lub aktywnych funduszach akcji o krótkim horyzoncie. Koncentruje się na analizie historycznych danych cenowych i wolumenów w celu prognozowania przyszłych ruchów cen.\nKluczowe wskaźniki i narzędzia: Wykresy świecowe, średnie kroczące, oscylatory (RSI, MACD), poziomy wsparcia i oporu.\nCel: Identyfikacja punktów wejścia i wyjścia z pozycji, ale rzadziej podstawą do długoterminowej selekcji spółek.\n\nAnaliza CSR/ESG (Corporate Social Responsibility/Environmental, Social, and Governance):\n\nOmówienie: Rosnące znaczenie dla funduszy inwestujących odpowiedzialnie. Selekcja spółek obejmuje ocenę ich wpływu na środowisko, społeczeństwo oraz jakość ładu korporacyjnego.\nKluczowe czynniki: Emisje CO2, zużycie wody, prawa pracownicze, różnorodność, niezależność zarządu, etyka biznesu.\nCel: Inwestowanie w spółki o wysokich standardach ESG, unikając spółek z kontrowersyjnych branż lub o niskich ocenach ESG.\n\nAnaliza jakościowa i zarządzanie:\n\nOmówienie: Ocena jakości zarządu, strategii spółki, przewag konkurencyjnych (moat), zdolności do innowacji, siły marki, relacji z klientami i dostawcami.\nCel: Wybór spółek z trwałymi przewagami konkurencyjnymi i kompetentnym zarządem, zdolnym do realizacji długoterminowej strategii.\n\n\nCzęsto proces selekcji spółek jest iteracyjny i obejmuje połączenie tych metod. Na przykład, po decyzjach Top Down o alokacji sektorowej, analitycy fundamentalni dokonują głębokiej analizy spółek w ramach tych sektorów, wspierani analizą ilościową w celu identyfikacji wstępnej listy kandydatów.\n\n\n\nZarządzanie ryzykiem kredytowym w funduszach inwestycyjnych koncentruje się głównie na instrumentach dłużnych (obligacje korporacyjne, obligacje rządowe, dłużne papiery wartościowe emitowane przez instytucje finansowe, instrumenty rynku pieniężnego) oraz na ryzyku kontrahenta w przypadku instrumentów pochodnych lub transakcji repo. Główne elementy tego systemu to:\n\nPolityka i procedury zarządzania ryzykiem kredytowym:\n\nDefinicja apetytu na ryzyko kredytowe funduszu.\nUstalenie ram dla procesów identyfikacji, pomiaru, monitorowania i kontroli ryzyka kredytowego.\nOkreślenie ról i odpowiedzialności (np. komitet inwestycyjny, zespół ryzyka, zarządzający portfelem).\n\nAnaliza i ocena kredytowa emitentów:\n\nWewnętrzna analiza kredytowa: Zespół analityków kredytowych funduszu przeprowadza własną, niezależną ocenę zdolności kredytowej emitentów instrumentów dłużnych. Obejmuje to analizę sprawozdań finansowych, modelu biznesowego, pozycji konkurencyjnej, przepływów pieniężnych, jakości zarządzania oraz perspektyw branży i makroekonomicznych.\nWykorzystanie ratingów zewnętrznych: Korzystanie z ratingów przyznawanych przez agencje ratingowe (np. Standard & Poor’s, Moody’s, Fitch) jako punktu wyjścia lub uzupełnienia własnej analizy. Fundusze często mają limity dotyczące minimalnego wymaganego ratingu kredytowego dla inwestowanych instrumentów.\nMonitorowanie zdarzeń kredytowych: Śledzenie zmian ratingów, informacji rynkowych, wiadomości branżowych i makroekonomicznych, które mogą wpływać na zdolność kredytową emitentów.\n\nLimity ryzyka kredytowego:\n\nLimity na pojedynczego emitenta: Ograniczają maksymalną ekspozycję na dłużne papiery wartościowe jednego emitenta.\nLimity na sektor/branżę: Ograniczają koncentrację w długu emitentów z jednej branży, zmniejszając ryzyko specyficzne dla sektora.\nLimity ratingowe: Określają minimalny rating kredytowy dla inwestycji w instrumenty dłużne (np. inwestycje tylko w papiery o ratingu inwestycyjnym BBB- lub wyższym).\nLimity geograficzne: Ograniczają ekspozycję na obligacje emitowane w danym kraju lub regionie.\nLimity dla obligacji wysokodochodowych (High-Yield): Specjalne limity dla obligacji o ratingu spekulacyjnym, jeśli fundusz ma je w strategii.\n\nZarządzanie ryzykiem kontrahenta:\n\nW przypadku transakcji OTC (np. swapy, opcje, transakcje repo), fundusz jest narażony na ryzyko niewykonania zobowiązania przez kontrahenta.\nWybór i weryfikacja kontrahentów: Dokładna ocena wiarygodności kredytowej banków inwestycyjnych i brokerów, z którymi fundusz zawiera transakcje.\nLimity na kontrahenta: Ustanowienie maksymalnej ekspozycji na pojedynczego kontrahenta.\nUmowy ISDA (International Swaps and Derivatives Association) i CSA (Credit Support Annex): Wykorzystanie standardowych umów ramowych i aneksów o zabezpieczeniach w celu ograniczenia ryzyka kontrahenta poprzez codzienne rozliczanie marż i wymianę zabezpieczeń.\nNetting (kompensowanie): W przypadku wielu transakcji z tym samym kontrahentem, zastosowanie nettingu w celu zmniejszenia całkowitej ekspozycji.\n\nMonitoring i raportowanie ryzyka kredytowego:\n\nCiągłe monitorowanie ekspozycji kredytowej portfela w czasie rzeczywistym.\nRegularne raportowanie o przestrzeganiu limitów, zmianach ratingów, zdarzeniach kredytowych i ogólnej kondycji portfela w zakresie ryzyka kredytowego do zarządzających, komitetów inwestycyjnych i organów nadzorczych.\nWykorzystanie systemów informatycznych do agregacji danych i generowania raportów.\n\nTesty warunków skrajnych (Stress Testing) i analizy scenariuszowe:\n\nSymulacje wpływu negatywnych scenariuszy makroekonomicznych (np. recesja, kryzys finansowy, spadek ratingów dla całego sektora) na ekspozycję kredytową portfela i potencjalne straty.\nPomaga to w identyfikacji słabych punktów portfela i wczesnym reagowaniu.\n\n\n\n\n\nSztuczna Inteligencja (AI), w tym uczenie maszynowe (ML) i głębokie uczenie (DL), rewolucjonizuje zarządzanie funduszami inwestycyjnymi, oferując nowe możliwości w zakresie analizy danych, podejmowania decyzji i automatyzacji. Główne obszary zastosowania to:\n\nUdoskonalona Analiza Danych (Enhanced Data Analysis):\n\nPrzetwarzanie Dużych Zbiorów Danych (Big Data): AI jest w stanie przetwarzać i analizować ogromne, zróżnicowane zbiory danych, w tym dane strukturyzowane (sprawozdania finansowe, dane rynkowe) i niestrukturyzowane (wiadomości, raporty analityczne, posty w mediach społecznościowych, transkrypcje telekonferencji, dane satelitarne). Tradycyjne metody nie są w stanie efektywnie przetwarzać takiej skali i różnorodności.\nPrzetwarzanie Języka Naturalnego (NLP): Algorytmy NLP mogą analizować teksty, takie jak raporty spółek, wiadomości, analizy makroekonomiczne, by identyfikować sentyment, trendy, ryzyka i możliwości, które są trudne do uchwycenia przez ludzkich analityków. Na przykład, identyfikacja zmiany tonu w raportach kwartalnych zarządów.\n\nGenerowanie Alfy (Alpha Generation):\n\nPredykcja Ruchów Cen Aktywów: Modele ML mogą identyfikować złożone, nieliniowe wzorce w danych rynkowych i fundamentalnych, które mogą prowadzić do trafniejszych prognoz cen akcji, obligacji czy surowców. Mogą to być modele regresyjne, sieci neuronowe czy algorytmy wzmocnionego uczenia (reinforcement learning).\nStrategie Arbitrażowe i HFT (High-Frequency Trading): W przypadku funduszy hedgingowych i firm HFT, AI pozwala na identyfikację mikro-nieefektywności rynkowych i realizację transakcji w ułamkach sekund.\nSelekcja Spółek (Stock Picking): Algorytmy AI mogą przeszukiwać tysiące spółek, oceniając je na podstawie setek zmiennych (fundamentalnych, technicznych, ESG), by rekomendować te najbardziej atrakcyjne pod kątem danej strategii (np. value, growth, momentum).\n\nZarządzanie Ryzykiem (Risk Management):\n\nPrecyzyjne Modele Ryzyka: AI może budować bardziej złożone i dynamiczne modele ryzyka, które uwzględniają nieliniowe zależności i zmiany reżimu rynkowego, co prowadzi do dokładniejszych estymacji VaR, CVaR, czy ryzyka płynności.\nWykrywanie Anomalii (Anomaly Detection): Algorytmy ML mogą szybko wykrywać nietypowe wzorce w danych transakcyjnych lub rynkowych, sygnalizując potencjalne ryzyka operacyjne, manipulacje rynkowe czy nieoczekiwane zmiany sentymentu.\nStress Testing i Scenariusze: AI może generować i analizować znacznie szerszy zakres scenariuszy stress-testowych, identyfikując słabe punkty portfela w ekstremalnych warunkach rynkowych.\nZarządzanie Ryzykiem Kredytowym: Lepsza ocena zdolności kredytowej emitentów poprzez analizę ogromnych ilości danych, w tym niestrukturyzowanych.\n\nPersonalizacja i Obsługa Klienta (Personalization and Client Service):\n\nRobo-doradztwo: Platformy oparte na AI mogą oferować spersonalizowane strategie inwestyzyjne i rekomendacje portfelowe, dostosowane do profilu ryzyka i celów indywidualnych inwestorów.\nAutomatyzacja Procesów: AI może automatyzować rutynowe zadania, takie jak generowanie raportów, rebalansowanie portfeli czy wstępna obsługa zapytań klientów (chatboty).\n\nOptymalizacja Portfela (Portfolio Optimization):\n\nAI może znajdować bardziej złożone rozwiązania dla problemów optymalizacji portfela, uwzględniając wiele ograniczeń (limity, cele, koszty transakcyjne) i minimalizując ryzyko przy danym zwrocie lub maksymalizując zwrot przy danym ryzyku.\n\n\nWyzwania i ograniczenia:\n\nJakość Danych: Modele AI są tak dobre, jak dane, na których są trenowane. Niska jakość danych lub ich stronniczość może prowadzić do błędnych wyników.\nInterpretowalność (Explainability/Interpretability): Złożone modele AI (tzw. “czarne skrzynki”) mogą być trudne do zinterpretowania, co utrudnia zrozumienie, dlaczego podjęły daną decyzję, co jest problematyczne w silnie regulowanej branży finansowej.\nZbyt Duże Zaufanie: Ryzyko nadmiernego polegania na algorytmach bez ludzkiej weryfikacji i oceny.\nKoszty Implementacji: Wdrożenie i utrzymanie zaawansowanych systemów AI jest kosztowne i wymaga specjalistycznej wiedzy.\nRegulacje: Rozwój regulacji dotyczących wykorzystania AI w finansach jest wciąż na wczesnym etapie.\n\nPodsumowując, AI zmienia sposób, w jaki fundusze inwestycyjne zarządzają aktywami, umożliwiając bardziej zaawansowaną analizę, predykcję i zarządzanie ryzykiem. Nie zastępuje jednak całkowicie ludzkich zarządzających, lecz staje się potężnym narzędziem wspierającym ich decyzje."
  },
  {
    "objectID": "posts/sgh-investment-banking/index.html#fundusze-inwestycyjne-praktyczne-aspekty-procesu-inwestycyjnego",
    "href": "posts/sgh-investment-banking/index.html#fundusze-inwestycyjne-praktyczne-aspekty-procesu-inwestycyjnego",
    "title": "Investment Banking (PL)",
    "section": "",
    "text": "Polskie akty prawne:\n\nUstawa o funduszach inwestycyjnych i zarządzaniu alternatywnymi funduszami inwestycyjnymi z dnia 27 maja 2004 r. (Dz.U. 2004 nr 146, poz. 1546 ze zm.) – Jest to kluczowy akt prawny regulujący tworzenie, funkcjonowanie, zarządzanie, nadzór oraz likwidację funduszy inwestycyjnych i alternatywnych funduszy inwestycyjnych (AFI) w Polsce. Określa m.in. zasady emisji jednostek uczestnictwa/certyfikatów inwestycyjnych, obowiązki zarządzających (TFI, Zarządzających AFI) oraz depozytariuszy, a także podstawowe limity inwestyzyjne.\nRozporządzenia Ministra Finansów – Szczegółowe regulacje dotyczące np. sprawozdawczości funduszy, limitów inwestycyjnych czy zasad wyceny aktywów.\nAkty prawne Komisji Nadzoru Finansowego (KNF) – Decyzje, rekomendacje i wytyczne KNF, które uzupełniają ramy prawne i precyzują interpretacje przepisów.\n\nZagraniczne (unijne) akty prawne:\n\nDyrektywa UCITS (Undertakings for Collective Investment in Transferable Securities) – Dyrektywa 2009/65/WE (UCITS IV), zmieniona Dyrektywą 2014/91/UE (UCITS V) – Stanowi fundament europejskiego rynku funduszy otwartych. Reguluje harmonizację zasad dotyczących tworzenia, zarządzania i sprzedaży funduszy inwestycyjnych, które mogą być swobodnie oferowane w państwach członkowskich UE na zasadzie paszportu. Kluczowe obszary to:\n\nWymogi dotyczące organizacji i funkcjonowania funduszy.\nZasady dotyczące depozytariusza.\nWymogi dotyczące zarządzania ryzykiem i płynnością.\nObowiązki informacyjne wobec inwestorów.\n\nDyrektywa AIFMD (Alternative Investment Fund Managers Directive) – Dyrektywa 2011/61/UE – Reguluje zarządzających alternatywnymi funduszami inwestycyjnymi (AFI), czyli funduszami, które nie są objęte dyrektywą UCITS (np. fundusze hedgingowe, fundusze private equity, fundusze nieruchomości). Skupia się na autoryzacji i nadzorze zarządzających, zasadach wyceny, zarządzaniu ryzykiem, obowiązkach informacyjnych i zasadach dystrybucji.\nRozporządzenia MIFID II (Markets in Financial Instruments Directive) i MIFIR (Markets in Financial Instruments Regulation) – Wpływają na dystrybucję funduszy inwestycyjnych, wymagania w zakresie transparentności, ochrony inwestora, badania adekwatności i odpowiedniości.\n\n\n\n\nZarządzanie procesowe/zespołowe (ang. team-based approach) w asset management polega na tym, że decyzje inwestycyjne są podejmowane kolektywnie przez zespół zarządzających portfelem i analityków, w oparciu o zdefiniowane procesy i struktury, a nie przez pojedynczą osobę. Jest to podejście powszechnie stosowane w większych instytucjach.\nZalety:\n\nRedukcja ryzyka pojedynczego punktu awarii (Single Point of Failure - SPOF): Brak uzależnienia od jednej osoby (tzw. gwiazdy zarządzającej). Odejście kluczowego PM-a nie destabilizuje strategii ani wyników.\nSynergia wiedzy i doświadczenia: Różne perspektywy i specjalizacje (np. analityk akcji, analityk długu, specjalista od rynków wschodzących) prowadzą do bardziej wszechstronnej analizy i lepszych decyzji.\nSpójność i dyscyplina: Procesy decyzyjne są zazwyczaj bardziej ustrukturyzowane i zinstytucjonalizowane, co zapewnia większą spójność w podejściu do inwestycji i dyscyplinę w stosowaniu strategii.\nLepsza kontrola ryzyka: Decyzje są poddawane wzajemnej weryfikacji, co może prowadzić do wcześniejszego wychwytywania błędów lub nadmiernego ryzyka.\nSkalowalność: Model zespołowy jest łatwiejszy do skalowania w miarę wzrostu aktywów pod zarządzaniem i rozszerzania oferty produktowej.\nRozwój pracowników: Młodsi członkowie zespołu mogą uczyć się od bardziej doświadczonych kolegów, co sprzyja rozwojowi kompetencji.\n\nWady:\n\nWolniejszy proces decyzyjny: Konsensus wymaga czasu, co może być nieefektywne w dynamicznie zmieniających się warunkach rynkowych.\nRyzyko „myślenia grupowego” (Groupthink): Zespół może popadać w pułapkę konformizmu, ignorując alternatywne perspektywy, co może prowadzić do błędnych decyzji.\nRozmycie odpowiedzialności: W przypadku słabych wyników może być trudniej wskazać konkretną osobę odpowiedzialną.\nKonieczność silnego przywództwa: Brak wyraźnego lidera lub jego słabość może prowadzić do braku spójności w strategii i wewnętrznych konfliktów.\nWyższe koszty: Utrzymanie zespołu zarządzających i analityków jest droższe niż zatrudnienie jednej „gwiazdy”.\nPotencjalne konflikty interesów: Różne opinie i preferencje mogą prowadzić do sporów wewnętrznych, jeśli nie ma jasno zdefiniowanego procesu rozstrzygania.\n\n\n\n\nProces inwestycyjny w funduszu inwestycyjnym jest zorganizowanym cyklem, mającym na celu osiągnięcie założonych celów inwestycyjnych. Kluczowe etapy to:\n\nUstalenie Celów Inwestycyjnych i Strategii (Investment Policy Statement - IPS):\n\nOmówienie: Ten etap definiuje, co fundusz ma osiągnąć (np. stopa zwrotu, poziom ryzyka, horyzont czasowy, specyficzne wymogi płynnościowe czy etyczne). Tworzy się Investment Policy Statement (IPS), który jest formalnym dokumentem określającym cel funduszu, jego profil ryzyka, limity inwestycyjne, benchmarki, i ogólną strategię (np. value, growth, income, pasywna, aktywna). Jest to podstawa dla wszystkich kolejnych decyzji.\n\nAlokacja Aktywów (Asset Allocation):\n\nOmówienie: Jest to najważniejsza decyzja, która w dużej mierze determinuje długoterminowy wynik funduszu. Polega na podziale portfela na szerokie klasy aktywów (np. akcje, obligacje, nieruchomości, surowce, gotówka), regiony geograficzne czy sektory. Wyróżnia się:\n\nStrategiczną alokację aktywów (SAA): Długoterminowy rozkład aktywów, zgodny z IPS, określający “neutralny” portfel.\nTaktyczną alokację aktywów (TAA): Krótkoterminowe odchylenia od SAA, mające na celu wykorzystanie krótkoterminowych okazji rynkowych (np. przeważanie akcji w fazie wzrostu gospodarczego).\n\n\nWybór Papierów Wartościowych (Security Selection):\n\nOmówienie: Na tym etapie zarządzający podejmują decyzje o konkretnych instrumentach finansowych, które zostaną włączone do portfela w ramach każdej klasy aktywów. Może to być wynik analizy fundamentalnej (np. wybór konkretnych spółek na podstawie ich kondycji finansowej i perspektyw), analizy technicznej, czy analizy ilościowej. Celem jest znalezienie aktywów, które są niedowartościowane lub oferują atrakcyjny stosunek ryzyka do zwrotu.\n\nImplementacja i Wykonanie (Implementation and Execution):\n\nOmówienie: Decyzje inwestycyjne są przekładane na konkretne zlecenia kupna/sprzedaży. Ważne jest efektywne wykonanie transakcji, minimalizacja kosztów transakcyjnych (np. spread bid-ask, prowizje) oraz zarządzanie płynnością. Współpracuje się z brokerami i systemami handlowymi.\n\nMonitorowanie i Kontrola (Monitoring and Control):\n\nOmówienie: Ciągłe śledzenie wyników portfela, zgodności z celami inwestycyjnymi, limitami i regulacjami. Monitoruje się zmiany rynkowe, makroekonomiczne oraz specyficzne dla poszczególnych spółek/sektorów. W razie potrzeby dokonuje się rebalansowania portfela.\n\nOcena Wyników (Performance Evaluation):\n\nOmówienie: Regularna ocena wyników funduszu w stosunku do benchmarku, innych funduszy oraz założonych celów. Analizuje się nie tylko nominalną stopę zwrotu, ale także dostosowaną do ryzyka (np. wskaźnik Sharpe’a, Treynora). Ocena pomaga w identyfikacji źródeł sukcesów i niepowodzeń oraz w udoskonaleniu przyszłych strategii.\n\n\n\n\n\nBenchmark (indeks odniesienia) odgrywa fundamentalną rolę w procesie inwestycyjnym funduszu, pełniąc kilka kluczowych funkcji:\n\nDefiniowanie Celu Inwestycyjnego: Benchmark stanowi punkt odniesienia dla strategii inwestycyjnej funduszu. Określa horyzont inwestycyjny, klasy aktywów, regiony, sektory i styl inwestycyjny. Na przykład, fundusz akcji polskich o dużej kapitalizacji będzie miał za benchmark indeks WIG20.\nPomiar Wyników (Performance Measurement): Jest to najważniejsza funkcja benchmarku. Umożliwia obiektywną ocenę, czy zarządzający osiągnął zamierzony cel, tj. czy wygenerował dodatkową wartość (alfę) ponad pasywny zwrot z rynku. Stopa zwrotu funduszu jest zawsze porównywana ze stopą zwrotu benchmarku.\n\n\\[\n\\text{Nadwyżka Zwrotu (Alpha)} = \\text{Zwrot Funduszu} - \\text{Zwrot Benchmarku}\n\\]\n\nPodstawa Alokacji Aktywów: Benchmark często wyznacza ramy dla alokacji strategicznej. Np. w funduszach indeksowych portfel jest budowany tak, aby replikować skład benchmarku. W funduszach aktywnych, benchmark służy jako punkt wyjścia do podejmowania decyzji o przeważaniu/niedoważaniu sektorów czy spółek.\nZarządzanie Ryzykiem: Ryzyko aktywne (ryzyko benchmarkowe, tracking error) jest mierzone jako odchylenie stopy zwrotu funduszu od stopy zwrotu benchmarku. Pozwala to na monitorowanie, w jakim stopniu zarządzający odchodzi od składu indeksu i jakie ryzyko aktywne bierze na siebie.\n\n\\[\n\\text{Tracking Error (TE)} = \\sqrt{\\sum_{i=1}^{n} \\frac{(\\text{Zwrot Funduszu}_i - \\text{Zwrot Benchmarku}_i)^2}{n-1}}\n\\]\nGdzie: * \\(\\text{Zwrot Funduszu}_i\\) to zwrot funduszu w okresie \\(i\\). * \\(\\text{Zwrot Benchmarku}_i\\) to zwrot benchmarku w okresie \\(i\\). * \\(n\\) to liczba okresów.\n\nKomunikacja z Inwestorami: Benchmark dostarcza inwestorom jasnego i zrozumiałego punktu odniesienia do oceny efektywności zarządzania. Pomaga im zrozumieć, jaką ekspozycję rynkową przyjmuje fundusz i czego mogą się spodziewać.\nPodstawa dla Opłat za Zarządzanie: W niektórych modelach (np. performance fees) opłaty za zarządzanie mogą być powiązane z osiągnięciem wyników powyżej benchmarku.\n\n\n\n\nDobór odpowiedniego benchmarku jest kluczowym, choć często niedocenianym, elementem procesu inwestycyjnego. Niewłaściwy benchmark może prowadzić do błędnych ocen efektywności zarządzającego i niezrozumienia ryzyka. Kryteria doboru benchmarku obejmują:\n\nReprezentatywność: Benchmark powinien być jak najbardziej reprezentatywny dla rynku, na którym fundusz inwestuje lub dla klasy aktywów, którą zarządza. Powinien odzwierciedlać możliwości inwestycyjne i koszty transakcyjne, z jakimi mierzy się zarządzający. Np. dla funduszu akcji polskich WIG20 może być reprezentatywny dla dużych spółek, ale nie dla całego rynku.\nMierzalność: Benchmark musi być łatwo mierzalny i dostępny dla zarządzającego oraz inwestorów. Jego skład i metodologia obliczania powinny być transparentne.\nNiezależność: Benchmark powinien być niezależny od zarządzającego funduszem. Nie powinien być manipulowany ani modyfikowany przez zarządzającego w celu sztucznego poprawienia wyników.\nAdresowalność: Benchmark powinien odzwierciedlać obszar, w którym zarządzający faktycznie może inwestować. Jeśli fundusz ma limity uniemożliwiające inwestowanie w pewne aktywa z benchmarku, należy to uwzględnić.\nSpójność ze Stylem Inwestycyjnym: Jeśli fundusz ma styl value, growth czy small-cap, benchmark powinien również odzwierciedlać ten styl. Np. dla funduszu akcji małych spółek, odpowiedniejszy będzie indeks małych spółek, a nie szeroki indeks rynkowy.\nSpójność z Celami Funduszu: Benchmark musi być zgodny z celami inwestycyjnymi określonymi w IPS. Jeśli celem jest generowanie dochodu, benchmark powinien zawierać aktywa generujące dochód (np. indeks obligacji).\nWielkość i Płynność: Aktywa wchodzące w skład benchmarku powinny być wystarczająco płynne, aby fundusz mógł efektywnie nimi handlować, zwłaszcza w przypadku funduszy replikujących indeks.\nDostępność historycznych danych: Aby móc ocenić historyczne wyniki i ryzyko, konieczne są długie szeregi danych historycznych dla benchmarku.\n\nPraktyczne aspekty doboru:\n\nStandardowe indeksy: Często używa się szeroko znanych indeksów giełdowych (np. S&P 500, MSCI World, WIG20, WIBOR dla stopy procentowej).\nBenchmarki mieszane (Blended Benchmarks): Dla funduszy zrównoważonych lub multi-asset, tworzy się benchmarki składające się z kilku indeksów ważonych zgodnie ze strategiczną alokacją aktywów. Np. 60% WIG20 + 40% WIG Bond.\nWłasne benchmarki (Custom Benchmarks): W rzadkich przypadkach, dla bardzo specyficznych strategii, instytucje mogą tworzyć własne benchmarki, ale wymaga to uzasadnienia i transparentności.\n\n\n\n\nPodejście „Top Down” (odgórne) jest jedną z metod budowania portfela inwestycyjnego. Polega na podejmowaniu decyzji inwestycyjnych począwszy od analizy ogólnego otoczenia makroekonomicznego i globalnych trendów, a następnie stopniowym zawężaniu zakresu do konkretnych rynków, sektorów, by na końcu wybrać konkretne spółki lub instrumenty finansowe.\nEtapy podejścia Top Down:\n\nAnaliza Makroekonomiczna i Globalnych Trendów:\n\nRozpoczyna się od oceny globalnego krajobrazu gospodarczego: perspektywy wzrostu PKB, inflacja, stopy procentowe, polityka banków centralnych, geopolityka, trendy demograficzne, technologiczne i środowiskowe.\nNa tym etapie analizuje się, które regiony lub kraje będą miały najlepsze perspektywy wzrostu, biorąc pod uwagę cykl koniunkturalny.\n\nAlokacja Aktywów (Asset Allocation):\n\nNa podstawie analizy makro, zarządzający decydują o strategicznej i taktycznej alokacji aktywów pomiędzy różne klasy (akcje, obligacje, surowce, gotówka), geografie (np. rynki rozwinięte vs. rynki wschodzące) i waluty.\nDecyzje te są zorientowane na alokację kapitału do najbardziej perspektywicznych obszarów makro.\n\nWybór Sektorów i Branż:\n\nW ramach wybranych klas aktywów i regionów, identyfikuje się sektory i branże, które są najbardziej atrakcyjne w obecnym cyklu koniunkturalnym lub w obliczu długoterminowych trendów.\nNa przykład, w okresie szybkiego wzrostu gospodarczego mogą być faworyzowane sektory cykliczne (np. przemysł, materiały), a w okresie spowolnienia – defensywne (np. opieka zdrowotna, użyteczność publiczna).\n\nWybór Spółek/Instrumentów Finansowych:\n\nDopiero na samym końcu, w ramach wybranych sektorów, dokonuje się wyboru konkretnych spółek lub instrumentów finansowych. Wybór ten jest często podyktowany ich dominującą pozycją w sektorze, siłą finansową lub ekspozycją na określone trendy.\nAnaliza fundamentalna spółek jest wykorzystywana do potwierdzenia, czy konkretna spółka jest dobrym reprezentantem wybranego sektora i czy jej wycena jest atrakcyjna.\n\n\nCharakterystyka podejścia Top Down:\n\nHolistyczne spojrzenie: Koncentruje się na szerszym obrazie ekonomicznym i rynkowym.\nMakro czynniki: Główne decyzje są napędzane przez czynniki makroekonomiczne i trendy.\nDynamiczne: Pozwala na szybkie reagowanie na zmieniające się warunki rynkowe poprzez rebalansowanie alokacji aktywów.\nWysokie ryzyko systematyczne: Decyzje są często związane z całym rynkiem lub dużymi segmentami, co naraża portfel na ryzyko systematyczne.\n\nPodejście Top Down jest często stosowane przez dużych zarządzających aktywami, fundusze makro hedgingowe oraz fundusze globalne, gdzie alokacja strategiczna i taktyczna są kluczowe.\n\n\n\nW kontekście zarządzania portfelem funduszu zrównoważonego, decyzje o “przeważaniu” (overweight) lub “niedoważaniu” (underweight) odnoszą się do taktycznej alokacji aktywów lub selekcji sektorów/spółek względem ich wagi w benchmarku lub strategicznej alokacji aktywów.\nFundusz zrównoważony posiada typowo strategiczną alokację aktywów, np. \\(60\\%\\) akcji i \\(40\\%\\) obligacji. W ramach tego \\(60\\%\\) akcji, zarządzający może przyjąć pewne wagi sektorowe lub regionalne, które są zgodne z benchmarkiem lub jego neutralną alokacją.\n\nSilne przeważenie (+2):\n\nZnaczenie: Oznacza, że zarządzający świadomie zwiększa wagę danej klasy aktywów (np. akcji ogólnie w stosunku do obligacji), danego sektora, regionu lub konkretnej spółki w portfelu funduszu, znacząco powyżej jej neutralnej wagi w benchmarku lub strategicznej alokacji.\nCel: Decyzja o silnym przeważaniu wynika z bardzo silnego pozytywnego przekonania zarządzającego o przyszłych perspektywach danego aktywa/sektora/spółki. Oczekuje się, że ta pozycja wygeneruje istotną alfę (nadwyżkę stopy zwrotu) dla portfela.\nRyzyko: Jest to decyzja o relatywnie wysokim ryzyku aktywnym (tracking error). W przypadku błędnej oceny, silne przeważenie może znacząco negatywnie wpłynąć na wyniki funduszu względem benchmarku. \\(+2\\) sugeruje bardzo mocne odchylenie od wagi neutralnej.\nPrzykład: Jeśli strategiczna alokacja akcji w funduszu zrównoważonym wynosi \\(60\\%\\), a zarządzający decyduje się na silne przeważenie akcji, może to oznaczać, że ich udział w portfelu wzrośnie do \\(62\\%\\) lub więcej (np. nawet do \\(65-70\\%\\) w zależności od limitów i apetytu na ryzyko), kosztem innych klas aktywów. Podobnie, jeśli spółka X stanowi \\(2\\%\\) w benchmarku, a zarządzający silnie ją przeważa, może to oznaczać, że jej waga w portfelu wzrośnie do \\(4\\%\\) lub \\(5\\%\\).\n\nNiedoważenie (-1):\n\nZnaczenie: Oznacza, że zarządzający świadomie zmniejsza wagę danej klasy aktywów, sektora, regionu lub konkretnej spółki w portfelu funduszu, poniżej jej neutralnej wagi w benchmarku lub strategicznej alokacji.\nCel: Decyzja o niedoważeniu wynika z negatywnego przekonania zarządzającego o przyszłych perspektywach danego aktywa/sektora/spółki, lub z oczekiwania, że będzie ono radzić sobie gorzej niż benchmark. Ma to na celu ograniczenie spadków lub ochronę kapitału.\nRyzyko: Podobnie jak przeważenie, niedoważenie również generuje ryzyko aktywne. W przypadku błędnej oceny i nagłej poprawy wyników niedoważonego aktywa, fundusz może stracić szansę na zysk i zanotować gorsze wyniki niż benchmark. \\(-1\\) sugeruje umiarkowane do silnego odchylenia w dół.\nPrzykład: Jeśli strategiczna alokacja akcji wynosi \\(60\\%\\), a zarządzający decyduje się na niedoważenie akcji, ich udział w portfelu może spaść do \\(59\\%\\) lub mniej (np. do \\(55\\%\\) w zależności od limitów). Jeśli spółka Y stanowi \\(1\\%\\) w benchmarku, a zarządzający ją niedoważa, może to oznaczać, że jej waga w portfelu spadnie do \\(0.5\\%\\) lub nawet zostanie całkowicie wyeliminowana (\\(0\\%\\)).\n\n\nPodsumowując, “+2” i “-1” to wskaźniki intensywności taktycznych decyzji zarządzającego. Wyższe wartości bezwzględne oznaczają większe ryzyko aktywne (tracking error) i większy potencjał generowania lub tracenia alfy.\n\n\n\nLimity inwestycyjne są kluczowym elementem systemu zarządzania ryzykiem w funduszach inwestycyjnych. Służą ochronie kapitału inwestorów, zapewnieniu zgodności z polityką inwestycyjną funduszu i dywersyfikacji. Dzielą się na kategorie w zależności od poziomu agregacji i celu:\n\nLimity koncentracji (concentration limits):\n\nLimit pojedynczej emisji/emitenta: Ogranicza maksymalną wartość inwestycji w papiery wartościowe jednego emitenta lub jednej emisji (np. maksymalnie \\(5\\%\\) aktywów funduszu w akcjach spółki X). Ma to na celu ograniczenie ryzyka specyficznego.\nLimit branżowy/sektorowy: Ogranicza koncentrację w jednej branży lub sektorze (np. maksymalnie \\(20\\%\\) w sektorze finansowym). Zmniejsza to ryzyko związane ze spowolnieniem w danej branży.\nLimit geograficzny/regionalny: Ogranicza koncentrację w danym kraju lub regionie (np. maksymalnie \\(30\\%\\) aktywów w inwestycjach w Polsce).\nLimit typu instrumentu: Ogranicza udział poszczególnych rodzajów instrumentów (np. akcje, obligacje korporacyjne, instrumenty pochodne) w portfelu.\nLimit kapitałowy: Ogranicza maksymalny udział funduszu w kapitale zakładowym lub w liczbie głosów na walnym zgromadzeniu jednej spółki (np. maksymalnie \\(10\\%\\) akcji spółki X).\n\nLimity płynnościowe (liquidity limits):\n\nLimit aktywów niepłynnych: Ogranicza udział aktywów o niskiej płynności, które trudno byłoby sprzedać w krótkim czasie bez znaczącego wpływu na ich cenę (np. maksymalnie \\(10\\%\\) w aktywach niepublicznych lub trudno zbywalnych). Ma to na celu zapewnienie możliwości wykupu jednostek uczestnictwa przez fundusz.\nLimity instrumentów pochodnych: Ograniczenia dotyczące ekspozycji nominalnej lub ryzyka związanego z instrumentami pochodnymi, zapewniające, że ich wykorzystanie nie prowadzi do nadmiernego ryzyka płynnościowego.\n\nLimity kredytowe/kontrahenta (credit/counterparty limits):\n\nLimit na kontrahenta: Ogranicza maksymalną ekspozycję na pojedynczego kontrahenta (bank, broker) w transakcjach pozagiełdowych (OTC), takich jak instrumenty pochodne, operacje repo. Zmniejsza ryzyko kredytowe kontrahenta.\nLimit ratingowy: Określa minimalny wymagany rating kredytowy dla emitentów obligacji w portfelu. W funduszach obligacji bezpiecznych często wymagany jest rating inwestycyjny (np. BBB- lub wyżej).\n\nLimity ryzyka (risk limits):\n\nLimit Value-at-Risk (VaR): Określa maksymalną potencjalną stratę portfela w określonym horyzoncie czasowym i z danym poziomem ufności (np. \\(VaR_{99\\%}\\) na poziomie \\(2\\%\\) aktywów dziennie). \\[\\text{VaR} = \\text{Wartość Portfela} \\times \\sigma \\times z_{\\alpha}\\] Gdzie:\n\n\\(\\sigma\\) to odchylenie standardowe (zmienność) stopy zwrotu portfela.\n\\(z_{\\alpha}\\) to wartość z rozkładu normalnego odpowiadająca danemu poziomowi ufności.\n\nLimit Tracking Error (TE): Ogranicza maksymalne dopuszczalne odchylenie standardowe stopy zwrotu funduszu od stopy zwrotu benchmarku (np. TE nie może przekroczyć \\(4\\%\\)). Chroni przed nadmiernym ryzykiem aktywnym.\nLimit duration/convexity: W funduszach obligacji, limity te kontrolują wrażliwość portfela na zmiany stóp procentowych.\nLimity stop-loss: Automatyczne limity, które nakazują sprzedaż danego aktywa, jeśli jego cena spadnie poniżej określonego poziomu.\n\nLimity regulacyjne (regulatory limits):\n\nSą to limity narzucone przez przepisy prawa (np. wspomniana Ustawa o funduszach inwestycyjnych, dyrektywa UCITS). Mają charakter obligatoryjny i często są bardziej konserwatywne niż wewnętrzne limity funduszu.\n\n\n\n\n\nRola limitów inwestycyjnych jest kluczowa dla każdego funduszu inwestycyjnego, niezależnie od jego profilu ryzyka, ale ich znaczenie i specyfika zastosowania mogą się różnić.\nRola limitów inwestycyjnych:\n\nOchrona Kapitału Inwestorów: Jest to podstawowa funkcja. Limity zapobiegają nadmiernej koncentracji, niepłynności i nadmiernemu ryzyku, chroniąc inwestorów przed dużymi stratami.\nZapewnienie Zgodności z Polityką Inwestycyjną: Limity egzekwują, aby fundusz działał zgodnie ze swoim statutem i deklarowaną strategią, co jest kluczowe dla zaufania inwestorów i unikania style drift (dryfu stylu).\nDywersyfikacja Portfela: Poprzez narzucenie limitów koncentracji, limity wymuszają dywersyfikację, co jest podstawową zasadą zarządzania ryzykiem.\nZarządzanie Płynnością: Limity dotyczące aktywów niepłynnych są niezbędne do zapewnienia, że fundusz jest w stanie na bieżąco realizować żądania wykupu jednostek uczestnictwa.\nZgodność Regulacyjna: Fundusze są zobowiązane do przestrzegania limitów określonych w przepisach prawa (np. UCITS w UE, ustawa o funduszach w Polsce). Nieprzestrzeganie ich grozi karami i utratą licencji.\nUłatwienie Monitorowania Ryzyka: Systemy monitorowania ryzyka opierają się na limitach, generując alerty, gdy zbliżają się do nich lub zostają przekroczone.\n\nGdzie są najbardziej istotne: Fundusze bezpieczne vs. Fundusze wysokiego ryzyka?\nLimity są krytycznie istotne w funduszach bezpiecznych, takich jak fundusze pieniężne, krótkoterminowe obligacji skarbowych czy fundusze stabilnego wzrostu. Wynika to z następujących powodów:\n\nOczekiwania Inwestorów: Inwestorzy w fundusze bezpieczne mają niską tolerancję na ryzyko i oczekują stabilnego, przewidywalnego zwrotu. Każde znaczące odchylenie od tego profilu jest nieakceptowalne.\nRyzyko Reputacyjne: Duża strata w funduszu “bezpiecznym” może zniszczyć reputację całego towarzystwa funduszy inwestycyjnych.\nRegulacje: Fundusze bezpieczne, zwłaszcza pieniężne, są często objęte bardzo ścisłymi i restrykcyjnymi limitami regulacyjnymi dotyczącymi jakości kredytowej emitentów, duration, płynności i koncentracji. Ich celem jest minimalizacja ryzyka utraty kapitału.\nZachowanie Kapitału: Podstawowym celem tych funduszy jest zachowanie kapitału, a nie maksymalizacja zwrotu. Limity służą bezpośrednio temu celowi.\n\nJednakże limity są również bardzo istotne w funduszach podejmujących duże ryzyko inwestycyjne, choć ich natura i dopuszczalne poziomy będą inne:\n\nKontrola Ryzyka Ekstremalnego: Nawet w funduszach wysokiego ryzyka (np. fundusze akcji sektorowych, fundusze rynków wschodzących, fundusze hedgingowe), limity są niezbędne do kontrolowania ryzyka ekstremalnego (np. maksymalna koncentracja w pojedynczej spółce, maksymalna ekspozycja na instrumenty pochodne, limity VaR).\nZarządzanie Zadeklarowanym Ryzykiem: Limity pomagają utrzymać fundusz w ramach zadeklarowanego profilu ryzyka, nawet jeśli jest on wysoki. Zapobiegają to sytuacji, w której fundusz stanie się jeszcze bardziej ryzykowny niż pierwotnie zakładano.\nOgraniczenie Strat: Choć celują w wysokie zwroty, fundusze wysokiego ryzyka również muszą mieć mechanizmy ograniczające potencjalne straty, zwłaszcza w warunkach kryzysu rynkowego.\nZgodność z Mandatem: W przypadku funduszy hedgingowych czy alternatywnych, które mają szeroki zakres swobody inwestycyjnej, wewnętrzne limity są kluczowe do zdefiniowania i przestrzegania specyficznego mandatu inwestycyjnego.\n\nPodsumowując: Limity są uniwersalnym narzędziem zarządzania ryzykiem. W funduszach bezpiecznych są one bardziej restrykcyjne i skupiają się na ochronie kapitału. W funduszach wysokiego ryzyka są one elastyczniejsze, ale wciąż niezbędne do kontrolowania ekspozycji na ryzyko i zapobiegania katastrofalnym stratom, zapewniając, że ryzyko podejmowane jest w sposób kontrolowany i zgodny z profilem funduszu.\n\n\n\nSelekcja spółek (ang. security selection lub stock picking) do portfela funduszu inwestycyjnego jest zazwyczaj wynikiem dogłębnej analizy, która może opierać się na różnych podejściach, często łączonych ze sobą. Główne podstawy to:\n\nAnaliza Fundamentalna:\n\nOmówienie: Jest to najczęściej stosowane podejście. Polega na ocenie wewnętrznej wartości spółki (intrinsic value) poprzez analizę jej sprawozdań finansowych (bilans, rachunek zysków i strat, rachunek przepływów pieniężnych), modelu biznesowego, pozycji konkurencyjnej, jakości zarządzania, perspektyw wzrostu, otoczenia branżowego i makroekonomicznego.\nKluczowe wskaźniki i czynniki:\n\nWskaźniki wyceny: Cena/Zysk (P/E), Cena/Wartość Księgowa (P/BV), Cena/Sprzedaż (P/S), Wartość Przedsiębiorstwa/EBITDA (EV/EBITDA), Stopa Dywidendy.\nWskaźniki rentowności: ROE (Return on Equity), ROA (Return on Assets), Marża Zysku Brutto/Netto.\nWskaźniki zadłużenia: Dług netto/EBITDA, Dług/Kapitał Własny.\nWskaźniki płynności: Bieżąca płynność, szybka płynność.\nJakość zarządzania (qualitative factors): Doświadczenie, strategia, ład korporacyjny.\nPerspektywy branży i przewagi konkurencyjne: Bariery wejścia, siła negocjacyjna, innowacyjność.\n\nCel: Identyfikacja spółek niedowartościowanych (w stosunku do ich wewnętrznej wartości) lub tych z silnym potencjałem wzrostu. Podejścia value investing (inwestowanie w wartość) i growth investing (inwestowanie we wzrost) są podtypami analizy fundamentalnej.\n\nAnaliza Ilościowa (Quantitative Analysis):\n\nOmówienie: Wykorzystuje modele matematyczne, statystyczne i algorytmy do identyfikacji wzorców i relacji w danych rynkowych i fundamentalnych. Selekcja spółek opiera się na scoringu według wybranych kryteriów ilościowych.\nKluczowe wskaźniki i czynniki:\n\nWskaźniki momentum: Siła trendu cenowego.\nWskaźniki zmienności: Beta, odchylenie standardowe.\nWskaźniki jakości: Niska zmienność, stabilne zyski.\nCzynniki fundamentalne w ujęciu ilościowym: Np. spółki o niskim P/E, wysokiej stopie dywidendy, silnym wzroście EPS.\n\nCel: Systematyczne identyfikowanie spółek spełniających określone kryteria, często w celu budowy portfeli smart beta lub funduszy ilościowych.\n\nAnaliza Techniczna (Technical Analysis):\n\nOmówienie: W mniejszym stopniu stosowana w długoterminowych funduszach inwestycyjnych, częściej w funduszach hedgingowych lub aktywnych funduszach akcji o krótkim horyzoncie. Koncentruje się na analizie historycznych danych cenowych i wolumenów w celu prognozowania przyszłych ruchów cen.\nKluczowe wskaźniki i narzędzia: Wykresy świecowe, średnie kroczące, oscylatory (RSI, MACD), poziomy wsparcia i oporu.\nCel: Identyfikacja punktów wejścia i wyjścia z pozycji, ale rzadziej podstawą do długoterminowej selekcji spółek.\n\nAnaliza CSR/ESG (Corporate Social Responsibility/Environmental, Social, and Governance):\n\nOmówienie: Rosnące znaczenie dla funduszy inwestujących odpowiedzialnie. Selekcja spółek obejmuje ocenę ich wpływu na środowisko, społeczeństwo oraz jakość ładu korporacyjnego.\nKluczowe czynniki: Emisje CO2, zużycie wody, prawa pracownicze, różnorodność, niezależność zarządu, etyka biznesu.\nCel: Inwestowanie w spółki o wysokich standardach ESG, unikając spółek z kontrowersyjnych branż lub o niskich ocenach ESG.\n\nAnaliza jakościowa i zarządzanie:\n\nOmówienie: Ocena jakości zarządu, strategii spółki, przewag konkurencyjnych (moat), zdolności do innowacji, siły marki, relacji z klientami i dostawcami.\nCel: Wybór spółek z trwałymi przewagami konkurencyjnymi i kompetentnym zarządem, zdolnym do realizacji długoterminowej strategii.\n\n\nCzęsto proces selekcji spółek jest iteracyjny i obejmuje połączenie tych metod. Na przykład, po decyzjach Top Down o alokacji sektorowej, analitycy fundamentalni dokonują głębokiej analizy spółek w ramach tych sektorów, wspierani analizą ilościową w celu identyfikacji wstępnej listy kandydatów.\n\n\n\nZarządzanie ryzykiem kredytowym w funduszach inwestycyjnych koncentruje się głównie na instrumentach dłużnych (obligacje korporacyjne, obligacje rządowe, dłużne papiery wartościowe emitowane przez instytucje finansowe, instrumenty rynku pieniężnego) oraz na ryzyku kontrahenta w przypadku instrumentów pochodnych lub transakcji repo. Główne elementy tego systemu to:\n\nPolityka i procedury zarządzania ryzykiem kredytowym:\n\nDefinicja apetytu na ryzyko kredytowe funduszu.\nUstalenie ram dla procesów identyfikacji, pomiaru, monitorowania i kontroli ryzyka kredytowego.\nOkreślenie ról i odpowiedzialności (np. komitet inwestycyjny, zespół ryzyka, zarządzający portfelem).\n\nAnaliza i ocena kredytowa emitentów:\n\nWewnętrzna analiza kredytowa: Zespół analityków kredytowych funduszu przeprowadza własną, niezależną ocenę zdolności kredytowej emitentów instrumentów dłużnych. Obejmuje to analizę sprawozdań finansowych, modelu biznesowego, pozycji konkurencyjnej, przepływów pieniężnych, jakości zarządzania oraz perspektyw branży i makroekonomicznych.\nWykorzystanie ratingów zewnętrznych: Korzystanie z ratingów przyznawanych przez agencje ratingowe (np. Standard & Poor’s, Moody’s, Fitch) jako punktu wyjścia lub uzupełnienia własnej analizy. Fundusze często mają limity dotyczące minimalnego wymaganego ratingu kredytowego dla inwestowanych instrumentów.\nMonitorowanie zdarzeń kredytowych: Śledzenie zmian ratingów, informacji rynkowych, wiadomości branżowych i makroekonomicznych, które mogą wpływać na zdolność kredytową emitentów.\n\nLimity ryzyka kredytowego:\n\nLimity na pojedynczego emitenta: Ograniczają maksymalną ekspozycję na dłużne papiery wartościowe jednego emitenta.\nLimity na sektor/branżę: Ograniczają koncentrację w długu emitentów z jednej branży, zmniejszając ryzyko specyficzne dla sektora.\nLimity ratingowe: Określają minimalny rating kredytowy dla inwestycji w instrumenty dłużne (np. inwestycje tylko w papiery o ratingu inwestycyjnym BBB- lub wyższym).\nLimity geograficzne: Ograniczają ekspozycję na obligacje emitowane w danym kraju lub regionie.\nLimity dla obligacji wysokodochodowych (High-Yield): Specjalne limity dla obligacji o ratingu spekulacyjnym, jeśli fundusz ma je w strategii.\n\nZarządzanie ryzykiem kontrahenta:\n\nW przypadku transakcji OTC (np. swapy, opcje, transakcje repo), fundusz jest narażony na ryzyko niewykonania zobowiązania przez kontrahenta.\nWybór i weryfikacja kontrahentów: Dokładna ocena wiarygodności kredytowej banków inwestycyjnych i brokerów, z którymi fundusz zawiera transakcje.\nLimity na kontrahenta: Ustanowienie maksymalnej ekspozycji na pojedynczego kontrahenta.\nUmowy ISDA (International Swaps and Derivatives Association) i CSA (Credit Support Annex): Wykorzystanie standardowych umów ramowych i aneksów o zabezpieczeniach w celu ograniczenia ryzyka kontrahenta poprzez codzienne rozliczanie marż i wymianę zabezpieczeń.\nNetting (kompensowanie): W przypadku wielu transakcji z tym samym kontrahentem, zastosowanie nettingu w celu zmniejszenia całkowitej ekspozycji.\n\nMonitoring i raportowanie ryzyka kredytowego:\n\nCiągłe monitorowanie ekspozycji kredytowej portfela w czasie rzeczywistym.\nRegularne raportowanie o przestrzeganiu limitów, zmianach ratingów, zdarzeniach kredytowych i ogólnej kondycji portfela w zakresie ryzyka kredytowego do zarządzających, komitetów inwestycyjnych i organów nadzorczych.\nWykorzystanie systemów informatycznych do agregacji danych i generowania raportów.\n\nTesty warunków skrajnych (Stress Testing) i analizy scenariuszowe:\n\nSymulacje wpływu negatywnych scenariuszy makroekonomicznych (np. recesja, kryzys finansowy, spadek ratingów dla całego sektora) na ekspozycję kredytową portfela i potencjalne straty.\nPomaga to w identyfikacji słabych punktów portfela i wczesnym reagowaniu.\n\n\n\n\n\nSztuczna Inteligencja (AI), w tym uczenie maszynowe (ML) i głębokie uczenie (DL), rewolucjonizuje zarządzanie funduszami inwestycyjnymi, oferując nowe możliwości w zakresie analizy danych, podejmowania decyzji i automatyzacji. Główne obszary zastosowania to:\n\nUdoskonalona Analiza Danych (Enhanced Data Analysis):\n\nPrzetwarzanie Dużych Zbiorów Danych (Big Data): AI jest w stanie przetwarzać i analizować ogromne, zróżnicowane zbiory danych, w tym dane strukturyzowane (sprawozdania finansowe, dane rynkowe) i niestrukturyzowane (wiadomości, raporty analityczne, posty w mediach społecznościowych, transkrypcje telekonferencji, dane satelitarne). Tradycyjne metody nie są w stanie efektywnie przetwarzać takiej skali i różnorodności.\nPrzetwarzanie Języka Naturalnego (NLP): Algorytmy NLP mogą analizować teksty, takie jak raporty spółek, wiadomości, analizy makroekonomiczne, by identyfikować sentyment, trendy, ryzyka i możliwości, które są trudne do uchwycenia przez ludzkich analityków. Na przykład, identyfikacja zmiany tonu w raportach kwartalnych zarządów.\n\nGenerowanie Alfy (Alpha Generation):\n\nPredykcja Ruchów Cen Aktywów: Modele ML mogą identyfikować złożone, nieliniowe wzorce w danych rynkowych i fundamentalnych, które mogą prowadzić do trafniejszych prognoz cen akcji, obligacji czy surowców. Mogą to być modele regresyjne, sieci neuronowe czy algorytmy wzmocnionego uczenia (reinforcement learning).\nStrategie Arbitrażowe i HFT (High-Frequency Trading): W przypadku funduszy hedgingowych i firm HFT, AI pozwala na identyfikację mikro-nieefektywności rynkowych i realizację transakcji w ułamkach sekund.\nSelekcja Spółek (Stock Picking): Algorytmy AI mogą przeszukiwać tysiące spółek, oceniając je na podstawie setek zmiennych (fundamentalnych, technicznych, ESG), by rekomendować te najbardziej atrakcyjne pod kątem danej strategii (np. value, growth, momentum).\n\nZarządzanie Ryzykiem (Risk Management):\n\nPrecyzyjne Modele Ryzyka: AI może budować bardziej złożone i dynamiczne modele ryzyka, które uwzględniają nieliniowe zależności i zmiany reżimu rynkowego, co prowadzi do dokładniejszych estymacji VaR, CVaR, czy ryzyka płynności.\nWykrywanie Anomalii (Anomaly Detection): Algorytmy ML mogą szybko wykrywać nietypowe wzorce w danych transakcyjnych lub rynkowych, sygnalizując potencjalne ryzyka operacyjne, manipulacje rynkowe czy nieoczekiwane zmiany sentymentu.\nStress Testing i Scenariusze: AI może generować i analizować znacznie szerszy zakres scenariuszy stress-testowych, identyfikując słabe punkty portfela w ekstremalnych warunkach rynkowych.\nZarządzanie Ryzykiem Kredytowym: Lepsza ocena zdolności kredytowej emitentów poprzez analizę ogromnych ilości danych, w tym niestrukturyzowanych.\n\nPersonalizacja i Obsługa Klienta (Personalization and Client Service):\n\nRobo-doradztwo: Platformy oparte na AI mogą oferować spersonalizowane strategie inwestyzyjne i rekomendacje portfelowe, dostosowane do profilu ryzyka i celów indywidualnych inwestorów.\nAutomatyzacja Procesów: AI może automatyzować rutynowe zadania, takie jak generowanie raportów, rebalansowanie portfeli czy wstępna obsługa zapytań klientów (chatboty).\n\nOptymalizacja Portfela (Portfolio Optimization):\n\nAI może znajdować bardziej złożone rozwiązania dla problemów optymalizacji portfela, uwzględniając wiele ograniczeń (limity, cele, koszty transakcyjne) i minimalizując ryzyko przy danym zwrocie lub maksymalizując zwrot przy danym ryzyku.\n\n\nWyzwania i ograniczenia:\n\nJakość Danych: Modele AI są tak dobre, jak dane, na których są trenowane. Niska jakość danych lub ich stronniczość może prowadzić do błędnych wyników.\nInterpretowalność (Explainability/Interpretability): Złożone modele AI (tzw. “czarne skrzynki”) mogą być trudne do zinterpretowania, co utrudnia zrozumienie, dlaczego podjęły daną decyzję, co jest problematyczne w silnie regulowanej branży finansowej.\nZbyt Duże Zaufanie: Ryzyko nadmiernego polegania na algorytmach bez ludzkiej weryfikacji i oceny.\nKoszty Implementacji: Wdrożenie i utrzymanie zaawansowanych systemów AI jest kosztowne i wymaga specjalistycznej wiedzy.\nRegulacje: Rozwój regulacji dotyczących wykorzystania AI w finansach jest wciąż na wczesnym etapie.\n\nPodsumowując, AI zmienia sposób, w jaki fundusze inwestycyjne zarządzają aktywami, umożliwiając bardziej zaawansowaną analizę, predykcję i zarządzanie ryzykiem. Nie zastępuje jednak całkowicie ludzkich zarządzających, lecz staje się potężnym narzędziem wspierającym ich decyzje."
  },
  {
    "objectID": "posts/sgh-investment-banking/index.html#asset-management",
    "href": "posts/sgh-investment-banking/index.html#asset-management",
    "title": "Investment Banking (PL)",
    "section": "Asset management",
    "text": "Asset management\n\n1. Wyjaśnij czym jest benchmark i podaj przykłady możliwych benchmarków dla funduszu akcyjnego, dłużnego i pieniężnego.\nBenchmark to punkt odniesienia, który służy do oceny wyników inwestycyjnych danego funduszu, portfela lub strategii. Stanowi on miarę rynkowego ryzyka i zwrotu, umożliwiając porównanie osiągnięć zarządzającego z ogólnym trendem rynkowym lub z wynikami innych podobnych inwestycji. Wybór odpowiedniego benchmarku jest kluczowy, ponieważ powinien on realistycznie odzwierciedlać cel inwestycyjny funduszu, jego strukturę oraz zakres aktywów, w które inwestuje.\nPrzykłady benchmarków:\n\nFundusz Akcyjny:\n\nIndeksy Giełdowe: Najczęściej używane są szerokie indeksy odzwierciedlające cały rynek akcji lub jego specyficzny segment.\n\nGlobalne: MSCI World, FTSE Global All Cap Index, S&P 500 (dla funduszy inwestujących w USA).\nEuropejskie: STOXX Europe 600, Euro Stoxx 50.\nPolskie: WIG, WIG20 (dla funduszy akcji polskich).\n\nIndeksy Sektorowe: Jeśli fundusz specjalizuje się w konkretnym sektorze (np. technologiczny, finansowy), benchmarkiem może być odpowiedni indeks sektorowy (np. NASDAQ 100 dla funduszu technologicznego).\nIndeksy Stylu Inwestowania: Dla funduszy Value (niskie P/E, P/B) lub Growth (wysokie tempo wzrostu zysków), benchmarkiem mogą być indeksy typu Russell 1000 Value/Growth.\n\nFundusz Dłużny:\n\nIndeksy Obligacji: Benchmarki dla funduszy dłużnych są zazwyczaj oparte na indeksach obligacji o określonej zapadalności, ratingu kredytowym i walucie.\n\nGlobalne: Bloomberg Global Aggregate Bond Index.\nObligacje Skarbowe: Indeksy obligacji skarbowych o różnych terminach do wykupu (np. 1-3 lata, 5-7 lat, 10+ lat), np. Bloomberg U.S. Treasury Index.\nObligacje Korporacyjne: Indeksy obligacji korporacyjnych o różnym ratingu (np. High-Grade Corporate Bond Index, High-Yield Corporate Bond Index).\nObligacje Inflacyjne: Indeksy obligacji indeksowanych inflacją (np. Bloomberg U.S. Treasury Inflation-Protected Securities (TIPS) Index).\nPolskie: Indeksy obligacji skarbowych emitowanych w PLN.\n\n\nFundusz Pieniężny:\n\nStopy Rynku Międzybankowego: Ze względu na krótki horyzont inwestycyjny i niskie ryzyko, benchmarkami są zazwyczaj stopy procentowe krótkoterminowych instrumentów dłużnych.\n\nEURIBOR (Euro Interbank Offered Rate), LIBOR (London Interbank Offered Rate - choć w fazie wycofywania), SOFR (Secured Overnight Financing Rate - jako następca LIBOR).\nW Polsce: WIBOR (Warsaw Interbank Offered Rate) 1M, 3M.\n\nIndeksy Krótkoterminowych Obligacji: Indeksy skupiające bardzo krótkoterminowe papiery dłużne, np. Bloomberg U.S. Treasury Bill Index.\nOprocentowanie Lokaty Bankowej: W niektórych przypadkach, szczególnie dla funduszy o bardzo niskim profilu ryzyka, benchmarkiem może być średnie oprocentowanie lokat bankowych.\n\n\n\n\n2. Wyjaśnij skróty PKB, CPI, ISM oraz opisz jak mogą być wykorzystywane w zarządzaniu kapitałem?\nTe trzy wskaźniki makroekonomiczne są kluczowe dla analityków i zarządzających portfelami, ponieważ dostarczają informacji o ogólnej kondycji gospodarki, inflacji oraz aktywności produkcyjnej i usługowej.\n\nPKB (Produkt Krajowy Brutto - Gross Domestic Product)\n\nDefinicja: Jest to łączna wartość rynkowa wszystkich finalnych dóbr i usług wyprodukowanych w danym kraju w określonym czasie (zazwyczaj kwartał lub rok). Stanowi najważniejszy wskaźnik aktywności gospodarczej i miernik wielkości gospodarki.\nWzór (metoda wydatkowa): \\(PKB = C + I + G + (X - M)\\) Gdzie:\n\n\\(C\\) = Wydatki konsumpcyjne (consumption)\n\\(I\\) = Inwestycje brutto (investment)\n\\(G\\) = Wydatki rządowe (government spending)\n\\(X\\) = Eksport (exports)\n\\(M\\) = Import (imports)\n\nWykorzystanie w zarządzaniu kapitałem:\n\nOcena Kondycji Gospodarczej: Wzrost PKB sygnalizuje ekspansję gospodarczą, co zazwyczaj jest korzystne dla rynków akcji (wzrost zysków spółek) i generalnie sprzyja zwiększaniu apetytu na ryzyko. Spowolnienie lub recesja (ujemny wzrost PKB) może prowadzić do spadków na rynkach akcji i wzrostu popytu na bezpieczne aktywa (np. obligacje skarbowe).\nAlokacja Aktywów: W fazach silnego wzrostu PKB, zarządzający mogą zwiększać ekspozycję na akcje, szczególnie cykliczne. W okresach spowolnienia, preferowane mogą być obligacje lub akcje spółek defensywnych.\nPrognozowanie Zysków: Zmiany w PKB korelują ze zmianami w przychodach i zyskach przedsiębiorstw, co jest kluczowe dla wyceny akcji.\n\n\nCPI (Wskaźnik Cen Konsumpcyjnych - Consumer Price Index)\n\nDefinicja: Mierzy średnią zmianę cen w czasie koszyka dóbr i usług konsumpcyjnych, nabywanych przez typowe gospodarstwo domowe. Jest podstawową miarą inflacji.\nWykorzystanie w zarządzaniu kapitałem:\n\nOcena Inflacji: Wysoka inflacja (wzrost CPI) eroduje siłę nabywczą pieniądza i może negatywnie wpływać na obligacje o stałym oprocentowaniu (spadek realnej stopy zwrotu). Banki centralne reagują na inflację podwyżkami stóp procentowych, co ma wpływ na koszty finansowania przedsiębiorstw i wycenę aktywów.\nPolityka Pieniężna: CPI jest kluczowym wskaźnikiem monitorowanym przez banki centralne. Prognozy CPI wpływają na decyzje dotyczące stóp procentowych, co bezpośrednio przekłada się na rynek obligacji (wzrost stóp = spadek cen obligacji) i pośrednio na rynek akcji.\nInwestycje Odporne na Inflację: W okresach rosnącego CPI, zarządzający mogą rozważać inwestycje w aktywa odporne na inflację, takie jak surowce, nieruchomości, złoto, czy obligacje indeksowane inflacją (TIPS).\n\n\nISM (Institute for Supply Management - wskaźniki PMI/NMI)\n\nDefinicja: ISM publikuje dwa kluczowe wskaźniki:\n\nManufacturing PMI (Purchasing Managers’ Index): Indeks menedżerów zakupów dla sektora przemysłowego.\nServices PMI (Non-Manufacturing/Services PMI): Indeks menedżerów zakupów dla sektora usługowego.\nOba wskaźniki są oparte na ankietach przeprowadzanych wśród menedżerów zakupów i mierzą ich sentyment odnośnie nowych zamówień, produkcji, zatrudnienia, zapasów i dostaw. Wartość powyżej 50 wskazuje na ekspansję sektora, poniżej 50 na jego kurczenie się.\n\nWykorzystanie w zarządzaniu kapitałem:\n\nWskaźniki Wyprzedzające: PMI/NMI są uznawane za ważne wskaźniki wyprzedzające aktywności gospodarczej. Zmiany w nich często antycypują zmiany w PKB. Silny wzrost PMI/NMI sugeruje poprawę koniunktury i jest pozytywny dla akcji, szczególnie spółek cyklicznych.\nSentyment Rynkowy: Publikacje ISM mają duży wpływ na sentyment rynkowy, ponieważ szybko odzwierciedlają zmiany w perspektywach biznesowych. Niskie odczyty mogą wzbudzać obawy o recesję, podczas gdy wysokie wskazują na ożywienie.\nDecyzje Inwestycyjne: Zarządzający wykorzystują ISM do podejmowania decyzji o alokacji sektorowej. Na przykład, rosnący PMI dla przemysłu może skłonić do zwiększenia ekspozycji na sektory przemysłowe i materiałowe.\n\n\n\n\n\n3. Wymień i opisz cztery wskaźniki gospodarcze opisujące koniunkturę.\nWskaźniki koniunktury gospodarczej dostarczają informacji o bieżącym stanie i przyszłych perspektywach gospodarki. Możemy je podzielić na wyprzedzające, zbieżne i opóźnione. Oto cztery kluczowe:\n\nStopa Bezrobocia (Unemployment Rate):\n\nOpis: Jest to odsetek siły roboczej, która jest bezrobotna, ale aktywnie poszukuje pracy i jest dostępna do jej podjęcia. Obliczana jest jako stosunek liczby osób bezrobotnych do całkowitej siły roboczej (zatrudnieni + bezrobotni).\nZnaczenie dla koniunktury: Stopa bezrobocia jest wskaźnikiem opóźnionym. Zazwyczaj spada podczas ekspansji gospodarczej (firmy zatrudniają więcej pracowników) i rośnie w okresach spowolnienia lub recesji (firmy redukują zatrudnienie). Niska stopa bezrobocia świadczy o silnym rynku pracy i jest pozytywnym sygnałem dla konsumpcji, co wspiera wzrost gospodarczy. Jednak zbyt niska stopa bezrobocia może prowadzić do wzrostu presji płacowej i inflacyjnej.\n\nInflacja (Inflation Rate - mierzona np. CPI lub HICP):\n\nOpis: Mierzy tempo wzrostu ogólnego poziomu cen dóbr i usług w gospodarce w określonym czasie. Najczęściej używanym wskaźnikiem jest CPI (Consumer Price Index) lub w strefie euro HICP (Harmonised Index of Consumer Prices).\nZnaczenie dla koniunktury: Inflacja jest wskaźnikiem zbieżnym. Umiarkowana inflacja (np. 2-3%) jest często postrzegana jako zdrowa dla gospodarki, sygnalizując wzrost popytu. Wysoka, niekontrolowana inflacja (galopująca lub hiperinflacja) jest szkodliwa, ponieważ obniża siłę nabywczą, destabilizuje gospodarkę i prowadzi do niepewności. Deflacja (spadek cen) jest również niekorzystna, ponieważ może prowadzić do spirali spadku cen i zmniejszenia inwestycji. Monitorowanie inflacji jest kluczowe dla banków centralnych w kontekście polityki pieniężnej.\n\nWskaźniki Zaufania Konsumentów/Przedsiębiorców (Consumer Confidence Index / Business Confidence Index):\n\nOpis: To ankiety mierzące optymizm konsumentów lub przedsiębiorców odnośnie bieżącej i przyszłej sytuacji gospodarczej, ich finansów osobistych/firmowych oraz zamiarów zakupowych/inwestycyjnych. Przykładem jest Conference Board Consumer Confidence Index w USA czy indeks IFO w Niemczech.\nZnaczenie dla koniunktury: Są to wskaźniki wyprzedzające. Wysokie wskaźniki zaufania wskazują na optymizm, który zazwyczaj przekłada się na zwiększone wydatki konsumpcyjne (dla konsumentów) i inwestycje (dla przedsiębiorców), co sprzyja wzrostowi gospodarczemu. Spadek zaufania może sygnalizować nadchodzące spowolnienie, gdyż konsumenci mogą ograniczyć wydatki, a firmy inwestycje.\n\nWskaźnik Produkcji Przemysłowej (Industrial Production Index):\n\nOpis: Mierzy zmiany w wolumenie produkcji fizycznej w sektorach przemysłu, górnictwa i usług użyteczności publicznej.\nZnaczenie dla koniunktury: Jest to wskaźnik zbieżny. Wzrost produkcji przemysłowej świadczy o ekspansji gospodarczej i zwiększonym popycie na dobra. Spadek sygnalizuje osłabienie aktywności gospodarczej. Choć usługi stanowią coraz większą część nowoczesnych gospodarek, produkcja przemysłowa nadal jest ważnym barometrem cyklu koniunkturalnego, zwłaszcza dla sektorów wrażliwych na cykl.\n\n\n\n\n4. Jakie są największe różnice w inwestowaniu aktywnym i pasywnym z punktu widzenia inwestora?\nRóżnice między inwestowaniem aktywnym a pasywnym mają fundamentalne znaczenie dla strategii inwestycyjnej, wpływając na koszty, oczekiwane zwroty oraz poziom zaangażowania samego inwestora.\n\n\n\n\n\n\n\n\nCecha\nInwestowanie Aktywne\nInwestowanie Pasywne\n\n\n\n\nCel\nPrzewyższenie wyników benchmarku (rynku) poprzez aktywne zarządzanie portfelem, wybór konkretnych aktywów i timing rynkowy.\nOdwzorowanie wyników benchmarku (rynku) poprzez replikację jego składu. Cel to uzyskanie rynkowej stopy zwrotu.\n\n\nStrategia\nSelekcja aktywów (stock picking), timing rynkowy, czyli kupowanie i sprzedawanie w optymalnym momencie, próba przewidzenia przyszłych ruchów cen.\nKup i trzymaj (buy and hold). Inwestor kupuje instrument, który śledzi dany indeks (np. S&P 500) i utrzymuje go przez długi czas, bez prób aktywnego zarządzania.\n\n\nKoszty (Opłaty)\nWyższe. Wynika to z kosztów zatrudnienia profesjonalnych zarządzających, częstszego handlu (prowizje, spready bid-ask), opłat za zarządzanie oraz potencjalnych kosztów podatkowych (częściej realizowane zyski).\nZnacznie niższe. Główne koszty to minimalne opłaty za zarządzanie (np. w funduszach ETF) oraz niższe koszty transakcyjne ze względu na rzadkie zmiany w portfelu.\n\n\nPotencjał Zwrotu\nPotencjalnie wyższe zwroty niż rynek, ale wiąże się to również z ryzykiem niedociągnięcia do benchmarku. Historycznie większość aktywnych zarządzających nie była w stanie konsekwentnie przewyższać rynku po uwzględnieniu kosztów.\nZwroty zbliżone do rynkowych. Inwestor akceptuje średnią rynkową stopę zwrotu, unikając jednocześnie ryzyka niedostatecznych wyników aktywnego zarządzania.\n\n\nRyzyko\nWyższe ryzyko “błędu ludzkiego” – błędne decyzje zarządzającego, zły timing, niewłaściwy wybór aktywów. Ryzyko, że zarządzający nie osiągnie zamierzonego celu.\nRyzyko rynkowe. Inwestor jest narażony na fluktuacje całego rynku. Nie ma ryzyka, że zarządzający “popełni błąd” względem benchmarku, ponieważ benchmark jest śledzony.\n\n\nZaangażowanie Inwestora\nNiskie, jeśli inwestor powierza środki funduszowi aktywnie zarządzanemu. Jeśli inwestor sam zarządza aktywnie, wymaga to dużego zaangażowania (analiza, monitorowanie, czas).\nNiskie. Po wyborze odpowiedniego indeksu i instrumentu (np. ETF), inwestycja wymaga minimalnego monitorowania. Idealne dla inwestorów z ograniczonym czasem i wiedzą.\n\n\nTransparentność\nMniejsza, skład portfela może być zmieniany dynamicznie, a dokładne uzasadnienie decyzji inwestycyjnych może być mniej przejrzyste.\nWiększa, skład portfela jest publicznie znany i odzwierciedla skład wybranego indeksu.\n\n\nInstrumenty\nAktywnie zarządzane fundusze inwestycyjne (np. fundusze akcji, fundusze hedgingowe), indywidualne konta zarządzane, samodzielny trading.\nFundusze indeksowe (mutual funds), fundusze giełdowe (ETFs) śledzące indeksy (np. akcji, obligacji, surowców).\n\n\n\nDla inwestora początkującego lub tego, który stawia na długoterminowy, stabilny wzrost przy minimalnym zaangażowaniu i kosztach, inwestowanie pasywne jest często rekomendowanym wyborem. Z kolei inwestowanie aktywne może kusić wizją ponadprzeciętnych zysków, ale wiąże się z wyższymi kosztami, większym ryzykiem i wymaga zaufania do umiejętności zarządzającego lub poświęcenia znacznego czasu i wiedzy.\n\n\n5. Wyjaśnij jak rozumiesz stwierdzenie Johna Keynesa: „Rynek może być dłużej nieefektywny niż ty możesz być wypłacalny”.\nTo słynne powiedzenie Johna Maynarda Keynesa jest fundamentalną przestrogą dla każdego inwestora, zwłaszcza tych stosujących strategie kontrariańskie lub polegających na długoterminowych przewartościowaniach/niedowartościowaniach. Możemy je interpretować na kilka sposobów, które są ze sobą powiązane:\n\nDominacja Sentymentu i Psychologii nad Fundamentalną Wyceną: Keynes, jako bystry obserwator rynków, zdawał sobie sprawę, że ceny aktywów nie zawsze odzwierciedlają ich rzeczywistą, fundamentalną wartość. Mogą być one przez długi czas napędzane przez irracjonalny optymizm (bańki spekulacyjne) lub pesymizm (krachy). Inwestor może prawidłowo zidentyfikować, że dany aktyw jest przewartościowany lub niedowartościowany z perspektywy fundamentalnej, ale rynek może ignorować te fundamenty przez nieoczekiwanie długi okres.\nOgraniczenia Czasowe i Płynnościowe: Nawet jeśli inwestor ma rację co do kierunku, w którym rynek ostatecznie podąży, jego zdolność do utrzymania pozycji jest ograniczona przez jego kapitał i płynność. Jeśli inwestor zajmie pozycję krótką na przewartościowanym aktywie, a jego cena nadal rośnie, będzie musiał ponosić straty (np. dopłacać do depozytu zabezpieczającego w przypadku pozycji lewarowanych) lub jego kapitał zostanie zjedzony przez te straty, zanim rynek “skoryguje” się do fundamentalnej wartości. W rezultacie, inwestor może zostać zmuszony do zamknięcia pozycji ze stratą, zanim jego teza inwestycyjna się sprawdzi.\nBrak Płynności i Margin Calls: Dla inwestorów korzystających z dźwigni finansowej, problem wypłacalności staje się jeszcze bardziej krytyczny. Rosnące straty mogą prowadzić do wezwań do uzupełnienia depozytu (margin calls). Brak możliwości ich pokrycia skutkuje przymusowym zamknięciem pozycji, co tylko pogłębia stratę, niezależnie od tego, czy długoterminowa prognoza była słuszna.\nZnaczenie Zarządzania Ryzykiem i Horyzontu Czasowego: Powiedzenie Keynesa podkreśla, że nawet najbardziej trafna analiza fundamentalna nie jest gwarancją sukcesu, jeśli inwestor nie zarządza odpowiednio ryzykiem i nie ma wystarczającego kapitału, aby przetrwać okresy irracjonalnych ruchów rynkowych. To przestroga przed nadmierną pewnością siebie i niedoszacowaniem wpływu psychologii rynkowej.\n\nPraktyczne Implikacje dla Inwestora (zwłaszcza aktywnego):\n\nDywersyfikacja: Nie stawiaj wszystkiego na jedną kartę, nawet jeśli jesteś przekonany o słuszności swojej tezy.\nZarządzanie Kapitałem: Nie angażuj całego kapitału w jedną, nawet najbardziej perspektywiczną, inwestycję. Pozostaw sobie bufor płynności.\nStop-Lossy: Używaj narzędzi do zarządzania ryzykiem, takich jak zlecenia stop-loss, aby ograniczyć potencjalne straty, jeśli rynek idzie wbrew twoim oczekiwaniom.\nRealizm: Pamiętaj, że rynki mogą zachowywać się irracjonalnie przez dłuższy czas, niż można by przypuszczać na podstawie fundamentów.\nCierpliwość, ale z Ograniczeniami: Cierpliwość jest cnotą, ale musi iść w parze z realistyczną oceną ryzyka i wytrzymałości finansowej.\n\nW kontekście zarządzania kapitałem, cytat Keynesa jest przypomnieniem, że inwestowanie to nie tylko analiza danych i modeli, ale także psychologia, zarządzanie ryzykiem i zdolność do przetrwania okresów, w których rynek wydaje się zachowywać irracjonalnie.\n\n\n6. Opisz potencjał zysku w trzech różnych klasach aktywów.\nPotencjał zysku w różnych klasach aktywów jest nierozerwalnie związany z poziomem ryzyka, jaki te aktywa niosą. Generalnie, im wyższe oczekiwane zwroty, tym wyższe ryzyko.\n\n1. Akcje (Equity)\n\nCharakterystyka: Akcje reprezentują udział własnościowy w spółce. Inwestorzy w akcje stają się współwłaścicielami przedsiębiorstwa i czerpią korzyści z jego sukcesu.\nGłówne źródła zysku:\n\nWzrost Wartości (Capital Appreciation): Głównym źródłem zysku jest wzrost ceny akcji na giełdzie, wynikający z rozwoju spółki, wzrostu jej zysków, pozytywnych perspektyw rynkowych, innowacji, czy ekspansji.\nDywidendy: Część zysku spółki wypłacana akcjonariuszom. Dywidendy mogą stanowić stały strumień dochodu, zwłaszcza dla spółek o ugruntowanej pozycji (np. spółki dywidendowe, utilities).\n\nPotencjał Zysku:\n\nHistorycznie najwyższy: W długim terminie, akcje historycznie generowały najwyższe stopy zwrotu spośród głównych klas aktywów, przewyższając obligacje i gotówkę. Jest to premia za ryzyko (equity risk premium).\nWysoka zmienność: Potencjał wysokiego zysku idzie w parze z wysoką zmiennością (ryzykiem). Ceny akcji mogą gwałtownie rosnąć w okresach hossy, ale także znacząco spadać w okresach bessy, recesji lub kryzysów.\nZależność od koniunktury: Potencjał zysku z akcji jest silnie skorelowany z cyklem koniunkturalnym. W fazie ekspansji gospodarczej zyski spółek rosną, co napędza ceny akcji. W fazie spowolnienia lub recesji, zyski spadają, a ceny akcji korygują.\nPrzykłady: Wzrosty o kilkaset procent w ciągu kilku lat dla innowacyjnych spółek technologicznych (np. NVIDIA, Tesla w przeszłości), stabilne, ale niższe, zwroty z dywidend dla spółek value.\n\n\n\n\n2. Obligacje (Bonds)\n\nCharakterystyka: Obligacje to dłużne papiery wartościowe, które reprezentują pożyczkę udzieloną emitentowi (rządowi, korporacji, samorządowi) w zamian za obietnicę regularnych płatności odsetkowych (kuponów) i zwrotu kapitału w terminie wykupu.\nGłówne źródła zysku:\n\nPłatności Odsetkowe (Kupony): Podstawowym źródłem zysku są regularne płatności odsetkowe.\nWzrost Wartości (Capital Appreciation): Ceny obligacji mogą rosnąć na rynku wtórnym, gdy stopy procentowe spadają. Inwestor może sprzedać obligację przed terminem wykupu po wyższej cenie niż cena zakupu.\nDyskonto: Zakup obligacji poniżej wartości nominalnej i jej wykup po wartości nominalnej.\n\nPotencjał Zysku:\n\nNiższy, ale bardziej stabilny: Potencjał zysku z obligacji jest zazwyczaj niższy niż z akcji, ale charakteryzuje się znacznie niższą zmiennością. Stanowią one ważny element dywersyfikacji portfela.\nZależność od stóp procentowych: Ceny obligacji są odwrotnie skorelowane ze stopami procentowymi. Wzrost stóp procentowych powoduje spadek cen obligacji istniejących na rynku, i na odwrót. Ryzyko stopy procentowej jest kluczowe.\nRyzyko Kredytowe: Obligacje korporacyjne niosą ze sobą ryzyko niewypłacalności emitenta (ryzyko kredytowe), co jest odzwierciedlone w ratingach kredytowych i premii za ryzyko (spread). Obligacje skarbowe uważane są za najbezpieczniejsze, zwłaszcza te emitowane przez stabilne rządy.\nPrzykłady: Obligacje skarbowe USA mogą oferować stopy zwrotu rzędu 3-5% rocznie (w zależności od stóp procentowych i terminu do wykupu), podczas gdy obligacje korporacyjne wysokiego ryzyka (junk bonds) mogą oferować znacznie wyższe kupony, ale z proporcjonalnie wyższym ryzykiem straty kapitału.\n\n\n\n\n3. Nieruchomości (Real Estate)\n\nCharakterystyka: Inwestowanie w nieruchomości może obejmować bezpośrednie posiadanie nieruchomości (mieszkalne, komercyjne), fundusze REITs (Real Estate Investment Trusts) lub fundusze nieruchomościowe.\nGłówne źródła zysku:\n\nDochód z Wynajmu: Regularne wpływy z czynszu (dla nieruchomości generujących dochód).\nWzrost Wartości (Capital Appreciation): Wzrost wartości nieruchomości w czasie, wynikający z inflacji, wzrostu popytu, rozwoju obszaru, czy poprawy infrastruktury.\n\nPotencjał Zysku:\n\nUmiarkowany do wysokiego: Potencjał zysku z nieruchomości może być znaczący w długim terminie, zwłaszcza w okresach wzrostu gospodarczego i inflacji. Nieruchomości często pełnią rolę zabezpieczenia przed inflacją.\nNiska płynność i wysokie koszty transakcyjne (dla bezpośrednich inwestycji): Nieruchomości są aktywami o niskiej płynności. Zakup i sprzedaż są czasochłonne i kosztowne (prowizje, podatki, opłaty notarialne).\nWrażliwość na cykl koniunkturalny i stopy procentowe: Rynek nieruchomości jest cykliczny i wrażliwy na stopy procentowe (koszt kredytu hipotecznego). Wzrost stóp procentowych może obniżyć dostępność kredytu i schłodzić rynek.\nZróżnicowanie: Potencjał zysku zależy od lokalizacji, typu nieruchomości i warunków rynkowych. REITs oferują większą płynność i dywersyfikację niż bezpośrednie posiadanie, ale są bardziej skorelowane z rynkiem akcji.\nPrzykłady: Wzrost wartości nieruchomości mieszkalnych w dużych miastach o 5-10% rocznie plus dochód z wynajmu, lub stabilne dywidendy z REITs.\n\n\nPodsumowanie:\n\n\n\n\n\n\n\n\n\n\nKlasa Aktywów\nPotencjał Zysku (Długoterminowy)\nRyzyko (Zmienność)\nGłówne Źródła Zysku\nKluczowe Czynniki Wpływające\n\n\n\n\nAkcje\nNajwyższy\nNajwyższe\nWzrost wartości, dywidendy\nKoniunktura, zyski spółek, stopy proc.\n\n\nObligacje\nNiższy\nNiskie do średniego\nOdsetki, wzrost wartości (przy spadku stóp)\nStopy procentowe, ryzyko kredytowe, inflacja\n\n\nNieruchomości\nUmiarkowany do wysokiego\nŚrednie\nDochód z wynajmu, wzrost wartości\nKoniunktura, stopy proc., lokalizacja\n\n\n\nW zarządzaniu kapitałem, kluczem jest dywersyfikacja między tymi klasami aktywów, aby zoptymalizować stosunek ryzyka do zwrotu, dostosowując portfel do profilu ryzyka i horyzontu inwestycyjnego inwestora.\n\n\n\n\n7. Jakie są główne fazy cyklu koniunkturalnego (cyklu gospodarczego)? Wskaż jakie klasy aktywów są preferowane w każdej z faz i dlaczego?\nCykl koniunkturalny to naturalny, powtarzający się wzorzec wzrostu i spadku aktywności gospodarczej. Zrozumienie poszczególnych faz jest kluczowe dla alokacji aktywów, ponieważ różne klasy aktywów zachowują się odmiennie w zależności od fazy cyklu. Główne fazy to: ekspansja (ożywienie), szczyt, recesja (kurczenie się) i dno (dołek).\n\n1. Faza Ekspansji (Recovery/Expansion)\n\nCharakterystyka:\n\nGospodarka wychodzi z recesji.\nPKB rośnie, bezrobocie spada.\nRośnie produkcja przemysłowa i sprzedaż detaliczna.\nZaufanie konsumentów i przedsiębiorstw rośnie.\nInflacja jest początkowo niska, ale zaczyna rosnąć w późniejszych fazach ekspansji.\nBanki centralne utrzymują niskie stopy procentowe, aby wspierać wzrost.\n\nPreferowane Klasy Aktywów:\n\nAkcje: Zdecydowanie preferowane. Spółki odnotowują rosnące zyski, co napędza ceny akcji.\n\nAkcje cykliczne: Szczególnie dobrze radzą sobie spółki z sektorów wrażliwych na cykl gospodarczy, takie jak: technologiczne, dóbr konsumpcyjnych wyższego rzędu (np. motoryzacja, turystyka), przemysłowe, materiałowe i finansowe. Ich zyski są silnie skorelowane ze wzrostem PKB.\n\nSurowce: Ceny surowców (ropa, metale) zaczynają rosnąć wraz ze wzrostem popytu przemysłowego i konsumpcyjnego.\nNieruchomości: Rynek nieruchomości zaczyna się ożywiać, wspierany przez niższe stopy procentowe i poprawą zaufania.\n\nDlaczego: Poprawiająca się koniunktura gospodarcza bezpośrednio przekłada się na lepsze wyniki finansowe spółek, co zwiększa ich wycenę. Rosnący popyt napędza ceny surowców.\n\n\n\n\n2. Szczyt (Peak)\n\nCharakterystyka:\n\nGospodarka osiąga swój maksymalny punkt wzrostu.\nTempo wzrostu PKB zaczyna zwalniać, ale jest nadal dodatnie.\nBezrobocie jest na bardzo niskim poziomie (bliskim pełnego zatrudnienia).\nInflacja rośnie, stając się często problemem.\nBank centralny zaczyna podnosić stopy procentowe w celu opanowania inflacji i schłodzenia gospodarki.\n\nPreferowane Klasy Aktywów:\n\nAkcje: Zaczynają być selektywne. Wzrost na rynku akcji zwalnia, a wyceny mogą być już wysokie.\n\nAkcje defensywne: Spółki z sektorów mniej wrażliwych na cykl gospodarczy, takich jak: opieka zdrowotna, użyteczności publicznej (utilities), podstawowe dobra konsumpcyjne. Ich zyski są bardziej stabilne, nawet w obliczu spowolnienia.\nGotówka/Krótkoterminowe obligacje: Wzrost stóp procentowych sprawia, że gotówka i krótkoterminowe obligacje stają się atrakcyjniejsze.\n\nSurowce: Mogą być nadal silne z powodu inflacji, ale ich wzrost może zwalniać.\n\nDlaczego: Wzrost stóp procentowych i rosnące koszty finansowania zaczynają obciążać zyski spółek. Akcje defensywne oferują większą stabilność.\n\n\n\n\n3. Recesja (Contraction/Recession)\n\nCharakterystyka:\n\nSpadek PKB przez co najmniej dwa kolejne kwartały.\nBezrobocie szybko rośnie.\nSpada produkcja przemysłowa i sprzedaż.\nZaufanie konsumentów i przedsiębiorstw gwałtownie spada.\nInflacja zazwyczaj zaczyna spadać (dezinflacja).\nBanki centralne obniżają stopy procentowe, aby pobudzić gospodarkę.\n\nPreferowane Klasy Aktywów:\n\nObligacje Skarbowe (zwłaszcza długoterminowe): Zdecydowanie preferowane jako “bezpieczna przystań”. Spadek stóp procentowych przez bank centralny (w celu pobudzenia gospodarki) powoduje wzrost cen obligacji. Inwestorzy uciekają z ryzykownych aktywów.\nGotówka: Ważna dla zachowania płynności i wykorzystania okazji inwestycyjnych.\nZłoto: Często zyskuje w okresach niepewności gospodarczej jako magazyn wartości.\nAkcje defensywne: Nadal mogą być lepszym wyborem niż akcje cykliczne, choć ogólnie rynek akcji jest pod presją.\n\nDlaczego: Wzrost ryzyka na rynku akcji i spadające stopy procentowe powodują wzrost popytu na bezpieczne obligacje.\n\n\n\n4. Dno (Trough)\n\nCharakterystyka:\n\nGospodarka osiąga najniższy punkt recesji.\nTempo spadku PKB zwalnia, lub PKB jest bliskie stabilizacji.\nBezrobocie jest wysokie, ale tempo jego wzrostu może zwalniać.\nZaufanie jest na niskim poziomie, ale stabilizuje się.\nInflacja jest niska lub następuje deflacja.\nBank centralny utrzymuje stopy procentowe na bardzo niskim poziomie lub rozważa dalsze luzowanie ilościowe.\n\nPreferowane Klasy Aktywów:\n\nAkcje (wczesne spółki cykliczne i te o wysokiej becie): Inwestorzy zaczynają wyprzedzać poprawę koniunktury. Akcje, które ucierpiały najbardziej w recesji, mają największy potencjał do odbicia. Jest to często dobry moment na budowanie pozycji w akcjach.\n\nMałe spółki (Small Cap): Często odbijają się dynamiczniej na wczesnych etapach ożywienia.\nAkcje Wzrostowe (Growth Stocks): Perspektywy szybszego wzrostu zysków stają się atrakcyjniejsze.\n\nSurowce: Zaczynają rosnąć, antycypując przyszły wzrost popytu przemysłowego.\nKredyt wysokiego ryzyka (High-Yield Bonds): Ich spready kredytowe są wysokie, ale jeśli recesja się kończy, perspektywa obniżenia ryzyka niewypłacalności może przynieść wysokie zwroty.\n\nDlaczego: Rynek zaczyna “wyceniać” przyszłe ożywienie gospodarcze, często zanim dane makroekonomiczne to potwierdzą. Aktywa bardziej ryzykowne oferują największy potencjał wzrostu po spadkach.\n\nZrozumienie tych faz i dynamiki aktywów pozwala na bardziej świadome i strategiczne decyzje inwestycyjne, dopasowane do aktualnej kondycji gospodarczej.\n\n\n\n8. Czy dobra informacja dla gospodarki (np. wzrost sprzedaży o 10% lub wzrost zatrudnionych o 200 tys. miejsc pracy) może na rynkach wywołać spadki? W jakiej sytuacji spodziewałbyś się takiej reakcji rynków?\nTak, jak najbardziej dobra informacja dla gospodarki może wywołać spadki na rynkach finansowych, w szczególności na rynku obligacji, a pośrednio także na rynku akcji. Taka reakcja rynków jest przykładem “paradoksu dobrych wieści” i jest zazwyczaj obserwowana w kontekście:\n\n\nSytuacja: Oczekiwania Inflacyjne i Reakcja Banku Centralnego\nGłównym mechanizmem, który prowadzi do spadków po “dobrych” wiadomościach, jest zmiana oczekiwań rynkowych dotyczących polityki pieniężnej banku centralnego, zwłaszcza w odniesieniu do stóp procentowych.\n\nSilny Wzrost Gospodarczy (Wzrost Sprzedaży, Zatrudnienia):\n\nImplikacja dla Banku Centralnego: Takie dane wskazują na silną gospodarkę, która rośnie w szybkim tempie. Z perspektywy banku centralnego, silny wzrost gospodarczy (szczególnie w połączeniu z niskim bezrobociem i rosnącymi płacami) zwiększa ryzyko wzrostu inflacji powyżej celu inflacyjnego.\nReakcja Banku Centralnego: W odpowiedzi na rosnącą presję inflacyjną, bank centralny (np. Fed, EBC, NBP) jest zmuszony do przyjęcia bardziej jastrzębiej postawy (hawkish stance), co oznacza sygnalizowanie lub faktyczne podwyższanie stóp procentowych. Celem jest schłodzenie gospodarki i zapobieżenie przegrzaniu oraz niekontrolowanemu wzrostowi cen.\n\nReakcja Rynków Finansowych:\n\nRynek Obligacji:\n\nSpadek cen obligacji: Wzrost oczekiwań na podwyżki stóp procentowych jest natychmiast negatywny dla cen obligacji. Istniejące obligacje o niższych kuponach stają się mniej atrakcyjne w porównaniu do nowo emitowanych obligacji z wyższym oprocentowaniem. Inwestorzy wyprzedają obligacje, co prowadzi do wzrostu ich rentowności.\nWzór: Cena obligacji (P) jest odwrotnie skorelowana z jej rentownością do wykupu (YTM). Jeśli oczekiwane stopy procentowe rosną, YTM rośnie, a P spada.\n\\(\\text{Cena Obligacji} \\approx \\frac{\\text{Kupon}}{(1 + \\text{YTM})^1} + \\dots + \\frac{\\text{Kupon} + \\text{Wartość Nominalna}}{(1 + \\text{YTM})^N}\\)\nGdzie YTM jest silnie skorelowane z oczekiwanymi stopami procentowymi.\n\nRynek Akcji:\n\nWyceny spółek pod presją: Wzrost stóp procentowych oznacza wyższe koszty finansowania dla przedsiębiorstw (droższe kredyty, droższe obligacje). To z kolei obniża ich zyski.\nWyższa stopa dyskontowa: W modelach wyceny akcji (np. DDM - Dividend Discount Model, DCF - Discounted Cash Flow), przyszłe przepływy pieniężne są dyskontowane wyższą stopą. Wyższa stopa dyskontowa obniża bieżącą wartość akcji.\nOdpływ kapitału z akcji: Wzrost rentowności obligacji sprawia, że stają się one bardziej atrakcyjne jako alternatywa dla akcji (tzw. “risk-free rate” rośnie). Inwestorzy mogą przenosić kapitał z akcji do obligacji.\nSektory wrażliwe: Szczególnie narażone są sektory silnie zadłużone, spółki wzrostowe (których wyceny opierają się na odległych przyszłych zyskach) oraz sektory wrażliwe na koszt kredytu (np. nieruchomości, budownictwo).\n\n\n\nKiedy spodziewałbyś się takiej reakcji rynków?\nSpodziewałbym się takiej reakcji przede wszystkim w następujących sytuacjach:\n\nFaza późnej ekspansji gospodarczej lub przegrzania: Gdy gospodarka jest bliska lub znajduje się w szczycie cyklu koniunkturalnego, a inflacja staje się realnym problemem. Bank centralny już prowadzi zacieśnianie polityki pieniężnej lub rynek silnie tego oczekuje.\nNiespodziewanie mocne dane makroekonomiczne: Jeśli dane (np. raport o zatrudnieniu, inflacja CPI) są znacznie lepsze od konsensusu rynkowego i sygnalizują większą presję inflacyjną niż wcześniej zakładano. Rynek musi wówczas zrewidować swoje oczekiwania co do przyszłych podwyżek stóp.\nJastrzębi ton banku centralnego: Jeśli “dobre” dane są publikowane w momencie, gdy bank centralny jest już nastawiony jastrzębio, lub gdy prezes banku centralnego wypowiada się w sposób sugerujący dalsze zacieśnianie polityki pieniężnej.\nOczekiwania rynkowe są kluczowe: Rynki dyskontują przyszłość. Jeśli “dobra informacja” jest już w dużej mierze uwzględniona w cenach, reakcja może być ograniczona. Jednak, jeśli jest ona zaskoczeniem i zmienia postrzeganie ścieżki stóp procentowych, spadki są bardzo prawdopodobne.\n\nPrzykład: Wzrost zatrudnienia o 200 tys. miejsc pracy w USA to ogólnie pozytywna wiadomość. Jednak jeśli rynek oczekiwał 100 tys., a bezrobocie spada do rekordowo niskich poziomów, to taka informacja może być interpretowana jako sygnał dla Rezerwy Federalnej do dalszych lub szybszych podwyżek stóp, co prowadzi do spadków na giełdach i na rynku obligacji. To samo dotyczy silnych danych o sprzedaży detalicznej, które mogą wskazywać na utrzymujący się wysoki popyt i presję inflacyjną.\n\n\n9. Opisz zależność pomiędzy zmianą stóp procentowych przez bank centralny, a zachowaniem się rynku obligacji. Podaj przykład takiej sytuacji z prawdziwego rynku.\nZależność między zmianą stóp procentowych przez bank centralny a zachowaniem się rynku obligacji jest fundamentalna i odwrotna. Oznacza to, że:\n\nWzrost stóp procentowych przez bank centralny prowadzi do spadku cen obligacji (i wzrostu ich rentowności).\nSpadek stóp procentowych przez bank centralny prowadzi do wzrostu cen obligacji (i spadku ich rentowności).\n\n\nMechanizm Zależności\n\nWzrost Stóp Procentowych (Zacieśnianie Polityki Pieniężnej):\n\nNowe Emisje: Kiedy bank centralny podnosi stopy procentowe (np. stopę referencyjną, stopę lombardową), to koszt pieniądza w gospodarce wzrasta. Nowo emitowane obligacje muszą oferować wyższe oprocentowanie (kupony), aby być atrakcyjne dla inwestorów.\nAtrakcyjność Starych Obligacji: Obligacje wyemitowane wcześniej, z niższymi kuponami, stają się mniej atrakcyjne w porównaniu do nowo emitowanych papierów. Aby “stare” obligacje stały się ponownie konkurencyjne, ich cena na rynku wtórnym musi spaść. W ten sposób ich rentowność do wykupu (Yield to Maturity, YTM) dostosowuje się do wyższych rynkowych stóp procentowych.\nKoszt Alternatywny: Inwestorzy mają alternatywę w postaci lokat bankowych lub innych instrumentów krótkoterminowych, które zaczynają oferować wyższe oprocentowanie. Sprawia to, że obligacje o stałym, niższym oprocentowaniu stają się mniej pożądane.\n\nSpadek Stóp Procentowych (Luzowanie Polityki Pieniężnej):\n\nNowe Emisje: Kiedy bank centralny obniża stopy procentowe, koszt pieniądza w gospodarce spada. Nowo emitowane obligacje będą oferować niższe oprocentowanie.\nAtrakcyjność Starych Obligacji: Obligacje wyemitowane wcześniej, z wyższymi kuponami, stają się bardziej atrakcyjne, ponieważ oferują lepsze oprocentowanie niż aktualne rynkowe stopy. Wzrost popytu na te “stare” obligacje prowadzi do wzrostu ich cen na rynku wtórnym, a tym samym do spadku ich rentowności do wykupu.\nPoszukiwanie Dochodu: W środowisku niskich stóp procentowych inwestorzy poszukują wyższych dochodów, co prowadzi ich do obligacji o wyższym oprocentowaniu, nawet jeśli ich ceny wzrosły.\n\n\nDuration jako Miernik Wrażliwości:\nWrażliwość ceny obligacji na zmianę stopy procentowej jest mierzona wskaźnikiem zwanym duration (czas trwania). Im dłuższy czas trwania obligacji, tym bardziej jej cena reaguje na zmiany stóp procentowych.\n\\(\\text{Duration Macaulay'a} = \\sum_{t=1}^{N} \\frac{t \\times C_t / (1+YTM)^t}{\\text{Cena Obligacji}}\\)\nGdzie \\(C_t\\) to przepływ pieniężny w czasie \\(t\\), \\(YTM\\) to rentowność do wykupu, a \\(N\\) to liczba okresów do wykupu. Zmodyfikowana duration (Modified Duration) jest częściej używana w praktyce do szacowania zmian cen:\n\\(\\text{Zmiana Ceny Obligacji (\\%)} \\approx - \\text{Modified Duration} \\times \\text{Zmiana YTM}\\)\n\n\nPrzykład z Prawdziwego Rynku: Cykl Podwyżek Stóp Procentowych przez Rezerwę Federalną (2022-2023)\n\nSytuacja przed podwyżkami (2020-2021): W odpowiedzi na pandemię COVID-19, Rezerwa Federalna (Fed) drastycznie obniżyła stopy procentowe do niemal zera (stopa federalnych funduszy w zakresie 0-0.25%) i wdrożyła program luzowania ilościowego (QE), skupując obligacje skarbowe i MBS. Celem było wsparcie gospodarki. W tym okresie ceny obligacji rosły, a rentowności spadały.\nWzrost Inflacji (2021-2022): Od połowy 2021 roku inflacja w USA zaczęła gwałtownie rosnąć, osiągając w czerwcu 2022 roku 9.1% (CPI), poziomy niewidziane od dekad. Było to spowodowane m.in. zakłóceniami w łańcuchach dostaw, stymulacją fiskalną i monetarną, oraz wzrostem cen energii.\nReakcja Fed (2022-2023): W odpowiedzi na uporczywą inflację, Fed rozpoczął agresywny cykl podwyżek stóp procentowych. W marcu 2022 roku nastąpiła pierwsza podwyżka, a następnie seria kolejnych, w tym kilka o 75 punktów bazowych. Stopa federalnych funduszy została podniesiona z poziomu bliskiego zera do zakresu 5.25-5.50% do lipca 2023 roku.\nZachowanie Rynku Obligacji:\n\nSpadek cen obligacji: Agresywne podwyżki stóp procentowych przez Fed wywołały masową wyprzedaż obligacji. Ceny obligacji skarbowych (np. 10-letnich US Treasury bonds) znacząco spadły.\nWzrost rentowności: Rentowność 10-letnich obligacji skarbowych USA, która pod koniec 2021 roku wynosiła około 1.5%, wzrosła do ponad 4-5% w 2022 i 2023 roku, osiągając najwyższe poziomy od wielu lat. Był to jeden z najgorszych okresów dla posiadaczy obligacji w historii, co pokazało, jak duży wpływ mają decyzje banku centralnego.\nInwersja krzywej dochodowości: Krótkoterminowe rentowności rosły szybciej niż długoterminowe, prowadząc do inwersji krzywej dochodowości (sygnał recesji).\n\n\nTen przykład jasno ilustruje odwrotną zależność: im wyższe stopy procentowe ustanowione przez bank centralny, tym niższe ceny obligacji (i wyższe rentowności) na rynku wtórnym, i odwrotnie.\n\n\n\n10. Wymień największe różnice pomiędzy obligacjami skarbowymi i korporacyjnymi. W jakich sytuacjach takie inwestycje dla inwestora mogą generować ponadprzeciętne ryzyko straty na kapitale.\nObligacje skarbowe i korporacyjne to dwie główne kategorie obligacji, które różnią się emitentem, profilem ryzyka, rentownością i przeznaczeniem.\n\n\nNajwiększe Różnice\n\n\n\n\n\n\n\n\nCecha\nObligacje Skarbowe (Treasury Bonds)\nObligacje Korporacyjne (Corporate Bonds)\n\n\n\n\nEmitent\nRząd (Skarb Państwa) kraju.\nPrzedsiębiorstwa (korporacje) w celu pozyskania kapitału na rozwój, inwestycje, spłatę długów itp.\n\n\nRyzyko Kredytowe\nNajniższe (lub zerowe) ryzyko kredytowe (ryzyko niewypłacalności). Obligacje emitowane przez stabilne rządy (np. USA, Niemcy) są często uważane za “wolne od ryzyka”. Rząd ma zdolność do opodatkowania i drukowania pieniędzy.\nWyższe ryzyko kredytowe (ryzyko niewypłacalności). Zależy od kondycji finansowej, ratingu kredytowego i sektora firmy. W przypadku bankructwa, posiadacze obligacji korporacyjnych są niżej w hierarchii spłaty niż posiadacze obligacji zabezpieczonych, ale wyżej niż akcjonariusze.\n\n\nRentowność (Yield)\nNiższa rentowność. Ze względu na niskie ryzyko, oferują niższe stopy zwrotu. Stanowią punkt odniesienia dla innych instrumentów dłużnych.\nWyższa rentowność. Oferują premię za ryzyko (credit spread) w stosunku do obligacji skarbowych o podobnym terminie zapadalności i walucie. Im wyższe ryzyko emitenta, tym wyższa premia.\n\n\nPłynność\nZazwyczaj wysoka płynność, zwłaszcza na głównych rynkach (np. US Treasury market), co ułatwia kupno i sprzedaż.\nPłynność zmienna, od wysokiej dla obligacji dużych, renomowanych firm, po bardzo niską dla mniejszych, mniej znanych emitentów lub obligacji o niskich ratingach.\n\n\nCel Emisji\nFinansowanie wydatków budżetowych rządu, refinansowanie długu publicznego.\nFinansowanie działalności operacyjnej, inwestycji, przejęć, restrukturyzacji, spłata wcześniejszych długów.\n\n\nRating Kredytowy\nOceniane przez agencje ratingowe (S&P, Moody’s, Fitch) na podstawie stabilności makroekonomicznej kraju i jego finansów publicznych.\nOceniane indywidualnie dla każdej korporacji, odzwierciedlając jej zdolność do terminowej spłaty długu. Wpływają na cenę i płynność obligacji.\n\n\nZabezpieczenie\nNiezabezpieczone (oparte na zdolności rządu do opodatkowania/drukowania pieniądza).\nMogą być zabezpieczone (secured) konkretnymi aktywami firmy lub niezabezpieczone (unsecured - niższe miejsce w hierarchii spłat).\n\n\n\n\nSytuacje Generujące Ponadprzeciętne Ryzyko Straty na Kapitale\nChoć obligacje są często postrzegane jako bezpieczniejsze niż akcje, również niosą ryzyko straty kapitału.\n\nDla Obligacji Skarbowych:\n\nGwałtowny Wzrost Stóp Procentowych (Ryzyko Stopy Procentowej):\n\nOpis: Jeśli bank centralny niespodziewanie i agresywnie podnosi stopy procentowe (np. w celu walki z wysoką inflacją), ceny istniejących obligacji skarbowych z niższymi kuponami drastycznie spadną. Inwestorzy, którzy sprzedają obligacje przed terminem wykupu, mogą ponieść znaczące straty.\nSytuacja: Agresywne zacieśnianie polityki pieniężnej, np. w warunkach stagflacji (wysoka inflacja + niska dynamika wzrostu), gdzie bank centralny jest zmuszony podnosić stopy, mimo słabnącej gospodarki.\nPrzykład: Opisana wcześniej sytuacja z amerykańskim rynkiem obligacji skarbowych w latach 2022-2023, kiedy to rentowności 10-letnich obligacji wzrosły z około 1.5% do ponad 4.5%, powodując znaczące straty dla posiadaczy tych papierów.\n\nPogorszenie Wiarygodności Kredytowej Kraju (Ryzyko Kraju/Emitenta):\n\nOpis: W przypadku, gdy państwo emitujące obligacje ma problemy z finansami publicznymi (np. rosnący dług, deficyt budżetowy, polityczny kryzys), jego wiarygodność kredytowa może spaść. To prowadzi do wyprzedaży jego obligacji, wzrostu rentowności i spadku cen.\nSytuacja: Kryzys zadłużenia, brak zaufania do rządu, wysokie ryzyko niewypłacalności (default).\nPrzykład: Europejski kryzys zadłużenia państwowego w latach 2010-2012, gdzie obligacje skarbowe krajów takich jak Grecja, Irlandia, Portugalia, Hiszpania czy Włochy doświadczyły gwałtownego spadku cen i wzrostu rentowności, ponieważ rynki obawiały się ich bankructwa.\n\n\n\n\nDla Obligacji Korporacyjnych:\n\nPogorszenie Kondycji Finansowej Emitenta (Ryzyko Kredytowe/Niewypłacalności):\n\nOpis: Jeśli emitująca obligacje korporacja doświadcza problemów finansowych (spadek przychodów, brak płynności, rosnące zadłużenie, utrata klientów, złe zarządzanie), jej zdolność do terminowej spłaty długu jest zagrożona. Rynek zaczyna wyceniać wyższe ryzyko bankructwa, co prowadzi do drastycznego spadku ceny obligacji, niezależnie od ogólnego poziomu stóp procentowych.\nSytuacja: Recesja gospodarcza (szczególnie dotykająca dany sektor), specyficzne problemy branżowe, błędy zarządcze, skandale korporacyjne.\nPrzykład: Upadłość Lehman Brothers w 2008 roku spowodowała, że ich obligacje stały się bezwartościowe. Inny przykład to spółki w sektorach silnie cyklicznych (np. motoryzacja, linie lotnicze) w trakcie głębokiej recesji – nawet jeśli nie zbankrutują, ich obligacje mogą znacząco stracić na wartości z powodu spadku ich ratingu kredytowego.\n\nWzrost Stóp Procentowych (Ryzyko Stopy Procentowej):\n\nOpis: Podobnie jak w przypadku obligacji skarbowych, wzrost ogólnych stóp procentowych na rynku negatywnie wpływa na ceny obligacji korporacyjnych, zwłaszcza tych długoterminowych.\nSytuacja: Cykl podwyżek stóp procentowych przez banki centralne. W tym przypadku obligacje korporacyjne odczują zarówno wzrost ogólnych stóp, jak i potencjalne pogorszenie sentymentu kredytowego (firmy mają droższe finansowanie).\n\nWzrost Spreadu Kredytowego (Credit Spread Widening):\n\nOpis: Spread kredytowy to różnica w rentowności między obligacją korporacyjną a obligacją skarbową o podobnym terminie zapadalności. Wzrost spreadu oznacza, że inwestorzy żądają wyższej premii za podjęcie ryzyka kredytowego danej korporacji. Dzieje się tak, gdy sentyment rynkowy do ryzyka korporacyjnego pogarsza się.\nSytuacja: Zwiększona awersja do ryzyka na rynku, kryzys finansowy, zbliżająca się recesja, obawy o cały sektor lub gospodarkę. Spready kredytowe gwałtownie rosną w okresach niepewności.\nPrzykład: Globalny Kryzys Finansowy w 2008 roku lub początek pandemii COVID-19 w 2020 roku. Obawy o masowe bankructwa spowodowały, że inwestorzy masowo wyprzedawali obligacje korporacyjne, co doprowadziło do gwałtownego wzrostu spreadów kredytowych (różnica rentowności między obligacjami korporacyjnymi a skarbowymi). Obligacje nawet relatywnie zdrowych firm traciły na wartości.\n\n\nPodsumowując, choć obligacje są często częścią “bezpiecznej” części portfela, nadal są narażone na znaczące straty kapitału, zwłaszcza w obliczu zmian w polityce pieniężnej, pogorszenia wiarygodności emitenta lub ogólnego wzrostu awersji do ryzyka na rynkach."
  },
  {
    "objectID": "posts/sgh-investment-banking/index.html#ryzyko-na-rynkach-finansowych",
    "href": "posts/sgh-investment-banking/index.html#ryzyko-na-rynkach-finansowych",
    "title": "Investment Banking (PL)",
    "section": "Ryzyko na Rynkach Finansowych",
    "text": "Ryzyko na Rynkach Finansowych\n\n1. Klasyfikacja ryzyka finansowego według definicji Bank for International Settlements (BIS)\nBank Rozrachunków Międzynarodowych (BIS) jest kluczową instytucją w kształtowaniu globalnych standardów bankowych, w tym w zakresie zarządzania ryzykiem. W ramach swoich ram regulacyjnych, zwłaszcza w porozumieniach Bazylejskich (np. Bazylea II, Bazylea III), BIS definiuje i klasyfikuje ryzyka finansowe, na które narażone są instytucje finansowe. Zrozumienie tej klasyfikacji jest fundamentalne dla efektywnego zarządzania ryzykiem w sektorze finansowym, ponieważ pozwala na systematyczne identyfikowanie, mierzenie, monitorowanie i kontrolowanie różnorodnych zagrożeń. Główne kategorie ryzyka finansowego to:\n\nRyzyko kredytowe (Credit Risk): Ryzyko, że kontrahent (np. kredytobiorca, emitent obligacji) nie wywiąże się ze swoich zobowiązań umownych, co spowoduje stratę dla banku lub innej instytucji finansowej. Jest to jedno z najstarszych i najbardziej znaczących ryzyk w bankowości.\n\nObejmuje to ryzyko niewypłacalności (default risk), czyli całkowitą niemożność spłaty długu.\nRyzyko pogorszenia jakości kredytowej (downgrade risk), gdzie rating kredytowy dłużnika zostaje obniżony, co zwiększa koszt finansowania dla dłużnika i obniża wartość rynkową jego długu.\nRyzyko koncentracji kredytowej, wynikające z nadmiernego zaangażowania w jednego kontrahenta, branżę, region geograficzny lub rodzaj produktu, co sprawia, że portfel kredytowy jest szczególnie wrażliwy na negatywne zdarzenia w tej konkretnej kategorii.\nPrzykład: Bank udziela kredytu przedsiębiorstwu, które w wyniku pogorszenia koniunktury gospodarczej nie jest w stanie spłacać rat, co prowadzi do straty dla banku.\n\nRyzyko rynkowe (Market Risk): Ryzyko strat w pozycjach bilansowych i pozabilansowych (np. instrumenty pochodne) wynikające ze zmian cen rynkowych. Jest to ryzyko związane z wahaniami wartości aktywów i pasywów w wyniku ruchów na rynkach finansowych.\n\nRyzyko stopy procentowej (Interest Rate Risk): Ryzyko strat wynikających ze zmian stóp procentowych, które wpływają na wartość instrumentów dłużnych, kredytów i depozytów.\nRyzyko kursu walutowego (Foreign Exchange Risk): Ryzyko strat wynikających ze zmian kursów walutowych, wpływające na wartość aktywów i pasywów denominowanych w obcych walutach.\nRyzyko cen akcji (Equity Price Risk): Ryzyko strat wynikających ze zmian cen akcji, wpływające na portfele inwestycyjne i pozycje handlowe.\nRyzyko cen towarów (Commodity Price Risk): Ryzyko strat wynikających ze zmian cen towarów (np. ropy naftowej, złota), wpływające na ekspozycje na rynkach surowców.\nPrzykład: Bank posiada duży portfel obligacji o stałym oprocentowaniu. Niespodziewany wzrost stóp procentowych na rynku powoduje spadek wartości tych obligacji, generując stratę dla banku.\n\nRyzyko operacyjne (Operational Risk): Ryzyko strat wynikających z nieadekwatnych lub wadliwych procesów wewnętrznych, ludzi i systemów, lub z zewnętrznych zdarzeń. Jest to szeroka kategoria, która może obejmować wiele różnorodnych zdarzeń, często niedocenianych aż do momentu ich wystąpienia.\n\nObejmuje to błędy ludzkie (np. błędne wprowadzenie danych, nieprawidłowa obsługa klienta), awarie systemów (np. awarie IT, cyberataki), oszustwa (wewnętrzne lub zewnętrzne), a także zdarzenia zewnętrzne takie jak klęski żywiołowe (np. pożar, powódź niszcząca infrastrukturę banku) czy ataki terrorystyczne.\nPrzykład: Błąd w oprogramowaniu bankowym powoduje podwójne zaksięgowanie transakcji, co skutkuje stratami finansowymi i koniecznością ręcznej korekty wielu rekordów. Inny przykład to cyberatak prowadzący do wycieku danych klientów i związanych z tym kar regulacyjnych oraz utraty reputacji.\n\nRyzyko płynności (Liquidity Risk): Ryzyko, że bank nie będzie w stanie wywiązać się ze swoich krótkoterminowych zobowiązań finansowych w terminie i po rozsądnej cenie. Jest to ryzyko krytyczne, ponieważ jego materializacja może prowadzić do natychmiastowej niewypłacalności, nawet jeśli bank jest solventny długoterminowo. Dzieli się na:\n\nRyzyko płynności finansowania (Funding Liquidity Risk): Ryzyko niemożności pozyskania środków na spłatę zobowiązań (np. depozytów, krótkoterminowych pożyczek) bez ponoszenia nadmiernych kosztów lub znacznych strat. Może wynikać z utraty zaufania inwestorów lub zakłóceń na rynkach międzybankowych.\nRyzyko płynności rynkowej (Market Liquidity Risk): Ryzyko niemożności szybkiej likwidacji pozycji po cenie rynkowej z powodu niewystarczającej głębokości lub szerokości rynku. Oznacza to, że sprzedaż aktywów w celu pozyskania gotówki może wiązać się ze znacznym spadkiem ich ceny.\nPrzykład: Bank nagle traci dostęp do rynku międzybankowego, z którego pozyskiwał krótkoterminowe finansowanie, i musi sprzedać część swoich aktywów po zaniżonych cenach, aby zaspokoić bieżące zobowiązania.\n\nRyzyko reputacji (Reputational Risk): Ryzyko utraty zaufania klientów, kontrahentów, inwestorów lub opinii publicznej, co może prowadzić do strat finansowych (np. odpływ depozytów, spadek cen akcji, utrata klientów) lub utraty wartości rynkowej firmy. Jest to ryzyko często wynikające z materializacji innych ryzyk (np. operacyjnego, prawnego) lub z nieetycznych zachowań.\n\nPrzykład: Bank zostaje uwikłany w skandal związany z praniem pieniędzy, co prowadzi do masowego wycofywania depozytów przez klientów i znaczącego spadku wartości akcji banku.\n\nRyzyko strategiczne (Strategic Risk): Ryzyko strat wynikających z błędnych decyzji biznesowych, nieefektywnej realizacji strategii, braku reakcji na zmiany w otoczeniu biznesowym (np. nowe technologie, zmiany regulacyjne, konkurencja) lub nieodpowiedniego planowania.\n\nPrzykład: Bank ignoruje rosnące znaczenie bankowości cyfrowej, inwestując wyłącznie w tradycyjne oddziały, co prowadzi do utraty udziału w rynku na rzecz bardziej innowacyjnych konkurentów.\n\nRyzyko systemowe (Systemic Risk): Ryzyko upadku całego systemu finansowego lub jego znaczącej części, spowodowane upadkiem jednej lub kilku dużych instytucji finansowych (tzw. “too big to fail”), co prowadzi do efektu domina (contagion effect) i może destabilizować całą gospodarkę. Jest to ryzyko makroekonomiczne, które jest monitorowane i zarządzane na poziomie regulatorów i banków centralnych.\n\nPrzykład: Upadek dużego banku inwestycyjnego wywołuje panikę na rynkach finansowych, prowadząc do masowego wycofywania środków z innych instytucji i zamrożenia rynku międzybankowego, co destabilizuje cały system finansowy.\n\n\nŹródło: Bank for International Settlements (BIS) - Basel Committee on Banking Supervision (BCBS) Frameworks, np. Basel II, Basel III. Szczegółowe informacje dostępne na stronie BIS: www.bis.org/bcbs/\n\n\n\n2. Porównanie odchylenia standardowego i odchylenia przeciętnego jako miary ryzyka\nZarówno odchylenie standardowe, jak i odchylenie przeciętne są miarami rozproszenia, używanymi do kwantyfikacji ryzyka, rozumianego jako zmienność wyników. Mimo że obie miary informują o stopniu rozproszenia danych wokół średniej, ich konstrukcja matematyczna i implikacje praktyczne różnią się znacząco.\nOdchylenie standardowe (\\(\\sigma\\))\nOdchylenie standardowe jest najczęściej używaną miarą ryzyka w finansach, zwłaszcza w kontekście teorii portfela Markowitza i Modelu Wyceny Aktywów Kapitałowych (CAPM). Mierzy ono średnie odchylenie poszczególnych obserwacji od średniej arytmetycznej, podniesione do kwadratu, a następnie spierwiastkowane. Podnoszenie do kwadratu ma na celu wyeliminowanie problemu sumowania odchyleń dodatnich i ujemnych, które wzajemnie by się znosiły.\n\nWzór (dla próby):\n\\[\\sigma = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^{n}(x_i - \\bar{x})^2}\\]\ngdzie:\n\n\\(x_i\\) to \\(i\\)-ta obserwacja (np. stopa zwrotu aktywa)\n\\(\\bar{x}\\) to średnia arytmetyczna stóp zwrotu\n\\(n\\) to liczba obserwacji\n\nCharakterystyka:\n\nWrażliwość na wartości odstające: Ze względu na podnoszenie odchyleń do kwadratu, odchylenie standardowe jest bardzo wrażliwe na duże odchylenia od średniej (wartości odstające, tzw. outliery). Duże odchylenia są wagi podwójnie, co może być zarówno zaletą (podkreśla ekstremalne zdarzenia, które są kluczowe w zarządzaniu ryzykiem), jak i wadą (może zniekształcać obraz ryzyka dla danych z silnymi wartościami odstającymi, które nie są reprezentatywne dla typowej zmienności).\nWłasności matematyczne: Jest podstawą wariancji (\\(\\sigma^2\\)), która jest addytywna dla niezależnych zmiennych losowych. Posiada doskonałe własności matematyczne, co ułatwia jego wykorzystanie w zaawansowanych modelach optymalizacyjnych, takich jak optymalizacja portfela Markowitza (minimalizacja wariancji portfela dla danego poziomu zwrotu) czy w modelach wyceny aktywów (np. CAPM, gdzie ryzyko systematyczne jest mierzone przez beta, które jest pochodną kowariancji i wariancji). Te własności sprawiają, że jest to preferowana miara w teorii finansów.\nZałożenie o rozkładzie: W kontekście ryzyka rynkowego, często zakłada się, że stopy zwrotu mają rozkład normalny, dla którego odchylenie standardowe jest kompletną miarą ryzyka (wraz ze średnią). W praktyce jednak stopy zwrotu aktywów finansowych często wykazują grube ogony (większe prawdopodobieństwo wystąpienia ekstremalnych zdarzeń) i skośność (asymetria rozkładu), co sprawia, że samo odchylenie standardowe może nie w pełni oddawać obraz ryzyka.\n\n\nOdchylenie przeciętne (Mean Absolute Deviation, MAD)\nOdchylenie przeciętne mierzy średnią arytmetyczną bezwzględnych wartości odchyleń poszczególnych obserwacji od średniej arytmetycznej. Jest to prostsza miara, która unika problemu znoszenia się odchyleń poprzez zastosowanie wartości bezwzględnej.\n\nWzór (dla próby):\n\\[MAD = \\frac{1}{n}\\sum_{i=1}^{n}|x_i - \\bar{x}|\\]\ngdzie symbole mają takie samo znaczenie jak powyżej.\nCharakterystyka:\n\nMniejsza wrażliwość na wartości odstające: Ponieważ używa wartości bezwzględnych zamiast kwadratów, jest mniej wrażliwe na ekstremalne wartości odstające niż odchylenie standardowe. Duże odchylenia nie są “karywane” podwójnie. To może być zaletą, jeśli chcemy uzyskać bardziej “typowy” obraz zmienności, mniej zniekształcony przez rzadkie, ekstremalne zdarzenia.\nIntuicyjność: Jest bardziej intuicyjne w interpretacji, ponieważ przedstawia “przeciętne” odchylenie od średniej. Łatwiej jest wyjaśnić, że “średnie odchylenie wynosi X” niż “pierwiastek z średniej kwadratów odchyleń wynosi X”.\nWłasności matematyczne: Posiada mniej pożądane własności matematyczne niż odchylenie standardowe. Funkcja wartości bezwzględnej nie jest różniczkowalna w punkcie 0, co znacząco komplikuje jego zastosowanie w zaawansowanych modelach statystycznych i optymalizacyjnych, które często opierają się na metodach gradientowych. Z tego powodu MAD jest rzadziej wykorzystywane w praktyce rynkowej i akademickiej do budowy kompleksowych modeli ryzyka.\n\n\nPodsumowanie porównania:\n\n\n\n\n\n\n\n\nCecha\nOdchylenie Standardowe (\\(\\sigma\\))\nOdchylenie Przeciętne (MAD)\n\n\n\n\nWrażliwość na Outliery\nWysoka (kwadratowe odchylenia)\nNiższa (bezwzględne odchylenia)\n\n\nWłasności Mat.\nDobre, używane w optymalizacji portfela (wariancja addytywna, różniczkowalność)\nGorsze (funkcja wartości bezwzględnej nie jest różniczkowalna)\n\n\nPowszechność użycia\nBardzo powszechne w finansach (teoria portfela, CAPM)\nRzadziej używane w praktyce rynkowej\n\n\nInterpretacja\nMniej intuicyjna (jednostki kwadratowe)\nBardziej intuicyjna (przeciętne odchylenie)\n\n\n\nW praktyce rynkowej i akademickiej, odchylenie standardowe jest zdecydowanie preferowaną miarą ryzyka ze względu na jego lepsze własności matematyczne, które pozwalają na rozwój bardziej złożonych modeli ryzyka i optymalizacji portfela. Mimo to, w niektórych kontekstach, zwłaszcza w analizach, gdzie prostota interpretacji i mniejsza wrażliwość na ekstremalne, rzadkie zdarzenia są pożądane, MAD może znaleźć zastosowanie. Źródło: Podstawy statystyki i ekonometrii, np. podręczniki J. Woś, W. Kufel. Dodatkowe informacje na temat miar ryzyka w finansach można znaleźć w publikacjach CFA Institute: www.cfainstitute.org\n\n\n\n3. Scharakteryzuj czas trwania (duration) jako miernik ryzyka stopy procentowej. Wyjaśnij dlaczego duration jest uznawane za konserwatywną miarę ryzyka.\nCzas trwania (Duration) jest kluczową miarą wrażliwości ceny instrumentu dłużnego (np. obligacji) na zmiany stóp procentowych. Jest to miara, która łączy w sobie zarówno termin zapadalności obligacji, jak i strukturę jej przepływów pieniężnych (kuponów). Istnieją dwie główne koncepcje duration: Macaulay Duration i Modified Duration.\nMacaulay Duration (\\(D_{Mac}\\))\nMacaulay Duration jest średnią ważoną okresów, w których otrzymywane są przepływy pieniężne z obligacji, gdzie wagami są zdyskontowane wartości tych przepływów w stosunku do bieżącej ceny obligacji. Jest to miara wyrażona w latach i może być interpretowana jako efektywny termin zapadalności obligacji, uwzględniający wszystkie płatności.\n\nWzór:\n\\[D_{Mac} = \\frac{\\sum_{t=1}^{N} t \\cdot \\frac{CF_t}{(1+y)^t}}{P}\\]\ngdzie:\n\n\\(t\\) to okres, w którym następuje przepływ pieniężny (np. rok, półrocze)\n\\(CF_t\\) to przepływ pieniężny (kupon lub wykup) w okresie \\(t\\)\n\\(y\\) to stopa dochodu do wykupu (yield to maturity, YTM) dla danego okresu\n\\(P\\) to bieżąca cena obligacji\n\\(N\\) to liczba okresów do wykupu\n\n\nModified Duration (\\(D_{Mod}\\))\nModified Duration jest bardziej praktyczną miarą wrażliwości ceny obligacji na zmianę stopy dochodu do wykupu. Przybliża procentową zmianę ceny obligacji dla danej zmiany stopy dochodu do wykupu. Jest to miara, która bezpośrednio wskazuje, o ile procent zmieni się cena obligacji, jeśli YTM zmieni się o jeden punkt procentowy (100 punktów bazowych).\n\nWzór:\n\\[D_{Mod} = \\frac{D_{Mac}}{1 + \\frac{y}{k}}\\]\ngdzie:\n\n\\(y\\) to annualizowana stopa dochodu do wykupu (yield to maturity, YTM)\n\\(k\\) to liczba okresów płatności kuponów w roku (np. 2 dla płatności półrocznych, 1 dla płatności rocznych).\nW uproszczeniu, dla stopy ciągłej lub rocznej kapitalizacji: \\(D_{Mod} = \\frac{D_{Mac}}{1+y}\\).\n\nInterpretacja:\n\\[\\% \\Delta P \\approx -D_{Mod} \\times \\Delta y\\]\ngdzie:\n\n\\(\\% \\Delta P\\) to procentowa zmiana ceny obligacji\n\\(\\Delta y\\) to zmiana stopy dochodu do wykupu (w ułamku dziesiętnym, np. 0.01 dla 1% lub 100 punktów bazowych)\nZnak minus wskazuje na odwrotną zależność między ceną obligacji a stopą dochodu do wykupu.\n\n\nWyjaśnienie Yield to Maturity (YTM):\nYield to Maturity (YTM), czyli stopa dochodu do wykupu, to całkowita stopa zwrotu, jaką inwestor może oczekiwać od obligacji, jeśli utrzyma ją do terminu wykupu, a wszystkie płatności kuponowe zostaną reinwestowane po tej samej stopie. Jest to zdyskontowana stopa, która zrównuje bieżącą cenę obligacji z sumą zdyskontowanych przyszłych przepływów pieniężnych (płatności kuponowych i kapitału w terminie wykupu). YTM jest często traktowana jako miara efektywnej stopy procentowej obligacji i jest kluczowym wskaźnikiem do porównywania różnych obligacji o różnych kuponach i terminach zapadalności. Jest to również stopa, która jest używana do dyskontowania przepływów pieniężnych w celu obliczenia Macaulay Duration.\nDlaczego duration jest uznawane za konserwatywną miarę ryzyka?\nDuration jest uznawane za konserwatywną miarę ryzyka z kilku powodów, wynikających głównie z jej charakteru jako liniowej aproksymacji nieliniowej zależności między ceną obligacji a stopą procentową. Ta nieliniowość jest kluczowa i jest opisywana przez miarę zwaną konweksyjnością (convexity).\n\nLiniowa aproksymacja nieliniowej zależności: Duration zakłada liniową zależność między zmianą stopy procentowej a zmianą ceny obligacji. W rzeczywistości, zależność ta jest nieliniowa i wypukła (konweksyjna), co oznacza, że krzywa ceny w funkcji stopy procentowej jest wygięta, a nie prosta.\n\nDla małych zmian stóp procentowych, duration jest dobrym przybliżeniem. Jednak dla dużych zmian stóp procentowych, liniowa aproksymacja staje się mniej dokładna.\nW przypadku spadku stóp procentowych: Rzeczywisty wzrost ceny obligacji jest większy niż przewiduje duration. Liniowa aproksymacja niedoszacowuje potencjalnych zysków. Dzieje się tak, ponieważ w miarę spadku stóp, duration obligacji rośnie, co zwiększa jej wrażliwość na dalsze spadki stóp.\nW przypadku wzrostu stóp procentowych: Rzeczywisty spadek ceny obligacji jest mniejszy niż przewiduje duration. Liniowa aproksymacja przeszacowuje potencjalne straty. Wzrost stóp procentowych powoduje spadek duration, co zmniejsza wrażliwość obligacji na dalsze wzrosty stóp.\nZatem, duration niedoszacowuje korzyści ze spadku stóp i przecenia straty ze wzrostu stóp. To sprawia, że jest ona “konserwatywna” w sensie, że nie daje pełnego obrazu potencjalnych zysków ani strat w ekstremalnych scenariuszach, co może prowadzić do nadmiernie ostrożnych decyzji.\n\nBrak uwzględnienia konweksyjności: Wypukłość (convexity) to miara drugiego rzędu, która koryguje błąd aproksymacji duration. Konweksyjność mierzy, jak szybko zmienia się duration wraz ze zmianą stóp procentowych. Im większa konweksyjność, tym większa jest różnica między rzeczywistą zmianą ceny a zmianą przewidywaną przez duration. Ponieważ duration ignoruje konweksyjność, jest to miara “konserwatywna” w tym sensie, że nie uwzględnia pełnego zakresu potencjalnych zmian cen, szczególnie tych korzystnych, które wynikają z wypukłości. W praktyce, obligacje o wyższej konweksyjności są bardziej pożądane, ponieważ oferują większe zyski przy spadku stóp i mniejsze straty przy wzroście stóp niż obligacje o niższej konweksyjności, co jest dla inwestora korzystnym zjawiskiem.\nZałożenie o równoległych przesunięciach krzywej dochodowości: Duration zakłada, że cała krzywa dochodowości przesuwa się równolegle (wszystkie stopy procentowe dla różnych terminów zapadalności zmieniają się o tę samą wartość). W rzeczywistości, zmiany stóp procentowych rzadko są równoległe; często obserwuje się skręty (twist) lub spłaszczenia (flattening/steepening) krzywej dochodowości, gdzie krótkoterminowe stopy mogą zmieniać się bardziej niż długoterminowe, lub odwrotnie. To uproszczenie wprowadza dodatkowy błąd do estymacji ryzyka, zwłaszcza dla portfeli z rozłożonymi terminami zapadalności, ponieważ różne segmenty krzywej dochodowości mogą reagować odmiennie na czynniki makroekonomiczne.\n\nW praktyce, aby uzyskać dokładniejszą estymację wrażliwości ceny obligacji na zmiany stóp procentowych, analitycy często używają duration w połączeniu z konweksyjnością:\n\\[\\% \\Delta P \\approx -D_{Mod} \\times \\Delta y + \\frac{1}{2} \\times Convexity \\times (\\Delta y)^2\\]\nPodsumowując, duration jest konserwatywną miarą, ponieważ jej liniowa natura prowadzi do niedoszacowania potencjalnych zysków i przeszacowania potencjalnych strat w przypadku dużych zmian stóp procentowych, a także ignoruje efekt konweksyjności i złożoność ruchów krzywej dochodowości. Mimo to, jest to niezwykle użyteczne narzędzie do zarządzania ryzykiem stopy procentowej, zwłaszcza dla małych zmian stóp, i stanowi fundament dla bardziej zaawansowanych modeli ryzyka. Źródło: Z. Jędrzejczyk, “Ryzyko finansowe i jego pomiar”, PWE 2008. Dodatkowe informacje: Corporate Finance Institute - Duration\n\n\n\n4. Scharakteryzuj Expected Shortfall jako miarę ryzyka. Na czym polega jej przewaga nad miarą VaR.\nExpected Shortfall (ES), znany również jako Conditional Value at Risk (CVaR) lub Average Value at Risk (AVaR), jest miarą ryzyka, która kwantyfikuje średnią oczekiwaną stratę, która wystąpi, jeśli strata przekroczy wartość VaR na danym poziomie ufności. Innymi słowy, ES odpowiada na pytanie: “Jeśli już poniesiemy stratę przekraczającą VaR, to jak duża będzie ta strata średnio?”. Jest to miara, która dostarcza bardziej kompleksowego obrazu ryzyka niż VaR, szczególnie w kontekście ekstremalnych zdarzeń.\n\nDefinicja: Dla danego poziomu ufności \\(\\alpha\\) (np. 95% lub 99%), Expected Shortfall to oczekiwana wartość strat, które są większe niż VaR na tym samym poziomie \\(\\alpha\\). \\[ES_{\\alpha} = E[L | L &gt; VaR_{\\alpha}]\\] gdzie:\n\n\\(L\\) to zmienna losowa reprezentująca stratę portfela\n\\(VaR_{\\alpha}\\) to Value at Risk na poziomie ufności \\(\\alpha\\), czyli kwantyl rozkładu strat.\n\nCharakterystyka:\n\nMiara ogona rozkładu (Tail Risk): ES koncentruje się na “ogonie” rozkładu strat, czyli na ekstremalnych, rzadziej występujących, ale potencjalnie bardzo dużych stratach. Jest to kluczowe w zarządzaniu ryzykiem, ponieważ największe straty często pochodzą z tych rzadkich, ale katastrofalnych zdarzeń, które mogą zagrozić stabilności całej instytucji. ES dostarcza informacji o skali tych “najgorszych scenariuszy”.\nKoherentna miara ryzyka: W przeciwieństwie do VaR (którego koherencja jest warunkowa i często nie jest spełniana w praktyce, zwłaszcza dla portfeli zawierających instrumenty pochodne lub dla rozkładów o “grubych ogonach”), ES jest koherentną miarą ryzyka, co oznacza, że spełnia cztery aksjomaty koherencji (zdefiniowane przez Artznera i in.):\n\nMonotoniczność: Jeśli portfel \\(X\\) zawsze generuje mniejsze lub równe straty niż portfel \\(Y\\), to miara ryzyka dla \\(X\\) jest mniejsza lub równa niż dla \\(Y\\). Oznacza to, że bardziej ryzykowne portfele są oceniane jako takie.\nTranslacyjna niezmienniczość: Dodanie bezryzykowego aktywa o wartości \\(k\\) do portfela zmniejsza miarę ryzyka o \\(k\\). Oznacza to, że miara ryzyka poprawnie odzwierciedla wolne środki dostępne do pokrycia strat.\nPozytywna jednorodność: Pomnożenie portfela przez stałą \\(c &gt; 0\\) powoduje, że miara ryzyka również jest pomnożona przez \\(c\\). Odzwierciedla skalę inwestycji – większa inwestycja powinna wiązać się z proporcjonalnie większym ryzykiem.\nSubaddytywność: Ryzyko połączonego portfela jest mniejsze lub równe sumie ryzyk poszczególnych portfeli (ryzyko dywersyfikacji). Jest to kluczowa własność, której VaR nie zawsze spełnia. Brak subaddytywności VaR oznacza, że dywersyfikacja może pozornie zwiększać ryzyko, co jest sprzeczne z podstawowymi zasadami zarządzania portfelem i zdrowym rozsądkiem finansowym. Subaddytywność ES promuje dywersyfikację jako narzędzie redukcji ryzyka.\n\n\n\nPrzewaga Expected Shortfall nad VaR:\n\nKoherencja (Subaddytywność): To najważniejsza przewaga. Jak wspomniano, VaR nie zawsze jest subaddytywny, zwłaszcza w przypadku portfeli z nieliniowymi instrumentami (np. opcjami) lub w warunkach rynkowych o “grubych ogonach”. Oznacza to, że VaR połączonego portfela może być większy niż suma VaR poszczególnych portfeli, co zniechęca do dywersyfikacji. ES zawsze spełnia warunek subaddytywności, co czyni go bardziej odpowiednim do optymalizacji portfela i alokacji kapitału, ponieważ promuje dywersyfikację jako sposób na redukcję ryzyka. Jest to kluczowe w kontekście regulacyjnym, gdzie banki są zachęcane do dywersyfikacji swoich ekspozycji w celu zwiększenia stabilności systemu finansowego.\nUjęcie ryzyka ogona (Tail Risk): VaR informuje jedynie o maksymalnej stracie, która nie zostanie przekroczona z danym prawdopodobieństwem (np. 99% VaR = 1 mln USD oznacza, że z 1% prawdopodobieństwem strata przekroczy 1 mln USD), ale nic nie mówi o wielkości strat, które przekroczą tę wartość. Może to być 1,1 mln USD, ale równie dobrze 10 mln USD, a nawet 100 mln USD, co w praktyce czyni VaR niewystarczającym w przypadku naprawdę ekstremalnych zdarzeń. ES idzie o krok dalej, kwantyfikując średnią wielkość tych ekstremalnych strat. W ten sposób ES dostarcza pełniejszego obrazu ryzyka, szczególnie w przypadku zdarzeń o “grubych ogonach” (fat tails), które są charakterystyczne dla rynków finansowych (np. kryzysy finansowe, “czarne łabędzie”, czyli nieprzewidywalne, rzadkie wydarzenia o ogromnym wpływie). Właśnie te rzadkie, ale katastrofalne zdarzenia są najbardziej interesujące dla zarządzających ryzykiem, ponieważ mogą doprowadzić do upadku instytucji.\nLepsze dla optymalizacji: Ze względu na swoją koherencję i własność wypukłości (convexity), ES jest łatwiejszy do optymalizacji niż VaR. Minimalizacja ES jest problemem wypukłym, co ułatwia znajdowanie globalnego optimum w problemach alokacji kapitału i zarządzania portfelem, ponieważ funkcja celu jest “dobrze zachowująca się” (nie ma wielu lokalnych minimów). Minimalizacja VaR jest często problemem niewypukłym i nieciągłym, co utrudnia znalezienie optymalnego rozwiązania i może prowadzić jedynie do lokalnych minimów, co jest dużym utrudnieniem w praktycznym zastosowaniu.\nBardziej stabilny: ES jest zazwyczaj bardziej stabilny w estymacji niż VaR, ponieważ uśrednia wartości z ogona rozkładu, co zmniejsza wpływ pojedynczych, ekstremalnych obserwacji. Estymacja VaR, jako kwantylu, może być bardziej wrażliwa na pojedyncze, skrajne wartości w danych historycznych, co prowadzi do większej zmienności w czasie i utrudnia porównywanie wyników.\n\nMimo że VaR jest nadal szeroko stosowany ze względu na swoją prostotę i długą historię, ES zyskuje na znaczeniu jako preferowana miara ryzyka, zwłaszcza w kontekście regulacyjnym. Bazylejski Komitet Nadzoru Bankowego (BCBS) w ramach Fundamental Review of the Trading Book (FRTB) w Bazylei III zaleca stosowanie ES jako podstawowej miary ryzyka rynkowego dla portfeli handlowych, zastępując dotychczasowe wykorzystanie VaR. Podkreśla to uznanie dla ES jako bardziej kompleksowego i odpornego narzędzia do zarządzania ryzykiem ekstremalnym. Źródło: P. Jorion, “Value at Risk: The New Benchmark for Managing Financial Risk”, McGraw-Hill. Dodatkowe informacje o ES i VaR: Investopedia - Expected Shortfall vs. VaR\n\n\n\n5. W jaki sposób można zbudować portfel o ujemnym czasie trwania (duration) i przed jakim rodzajem ryzyka taki portfel zabezpiecza?\nPortfel o ujemnym czasie trwania (Negative Duration Portfolio) to portfel aktywów i/lub pasywów, którego wartość rośnie, gdy stopy procentowe rosną, i maleje, gdy stopy procentowe spadają. Jest to odwrotność zachowania typowych instrumentów dłużnych (takich jak obligacje o stałym oprocentowaniu), których ceny spadają wraz ze wzrostem stóp procentowych i rosną wraz ze spadkiem stóp. Budowa takiego portfela jest kluczowa w strategiach zabezpieczających przed ryzykiem stopy procentowej, szczególnie dla instytucji, które posiadają znaczące ekspozycje na stałe stopy procentowe.\nJak zbudować portfel o ujemnym duration:\nBudowa portfela o ujemnym duration wymaga zastosowania strategii, które generują zyski w środowisku rosnących stóp procentowych. Główne metody to:\n\nSprzedaż krótka (short selling) długoterminowych obligacji:\n\nStrategia polega na pożyczeniu długoterminowych obligacji (które z natury mają wysokie, dodatnie duration) i natychmiastowej ich sprzedaży na rynku. Inwestor oczekuje, że stopy procentowe wzrosną, co spowoduje spadek cen tych obligacji. Następnie obligacje są odkupywane po niższej cenie i zwracane pożyczkodawcy, generując zysk z różnicy cen. Ponieważ pozycja krótka na obligacjach o dodatnim duration efektywnie tworzy ujemną ekspozycję na zmiany stóp procentowych, cały portfel zyskuje ujemne duration. Jest to prosta, ale niosąca ryzyko płynności strategia, gdyż znalezienie odpowiednich obligacji do pożyczenia i możliwość ich odkupienia w przyszłości po niższej cenie nie zawsze są gwarantowane.\n\nWykorzystanie instrumentów pochodnych na stopy procentowe: Instrumenty pochodne są często najbardziej efektywnym i elastycznym sposobem na uzyskanie ujemnego duration, ponieważ pozwalają na precyzyjne dostosowanie ekspozycji na zmiany stóp procentowych bez konieczności fizycznego posiadania bazowych instrumentów dłużnych. Pozwalają one na znacznie większą dźwignię finansową, co oznacza, że mniejszy kapitał początkowy może zabezpieczyć większą ekspozycję.\n\nInterest Rate Swaps (IRS): W IRS dwie strony wymieniają się przepływami odsetkowymi w oparciu o ustaloną wartość nominalną. Aby uzyskać ujemne duration (czyli zyskać na wzroście stóp), należy zawrzeć swap typu “płać stałą stopę, otrzymuj zmienną stopę” (Pay Fixed, Receive Floating).\n\nGdy rynkowe stopy procentowe (np. LIBOR, EURIBOR, SOFR) rosną, zmienne płatności, które otrzymujesz, zwiększają się, podczas gdy stałe płatności, które ponosisz, pozostają niezmienione. To generuje dodatni przepływ pieniężny dla posiadacza swapu, a tym samym zwiększa wartość swapu. Wzrost wartości swapu w odpowiedzi na wzrost stóp procentowych przekłada się na efektywne ujemne duration dla tej pozycji. Jest to typowa strategia banków, które mają aktywa o stałym oprocentowaniu (np. kredyty hipoteczne) i pasywa o zmiennym oprocentowaniu (np. depozyty).\n\nKontrakty Futures/Forward na obligacje: Sprzedaż kontraktów futures lub forward na długoterminowe obligacje. Wzrost stóp procentowych spowoduje spadek cen bazowych obligacji, co z kolei obniży wartość kontraktów futures/forward. Pozycja krótka na tych kontraktach przyniesie zysk, co efektywnie nadaje portfelowi ujemne duration. Jest to często wykorzystywane przez zarządzających portfelami do szybkiego dostosowania duration.\nOpcje na stopy procentowe (Interest Rate Options): Opcje oferują asymetryczną strukturę zysków i strat, co czyni je elastycznym narzędziem hedgingowym.\n\nOpcje put na obligacje: Zakup opcji put na obligacje. Wzrost stóp procentowych obniża cenę obligacji, zwiększając wewnętrzną wartość opcji put (prawo do sprzedaży po wyższej cenie wykonania), co przynosi zysk.\nOpcje call na stopy procentowe: Zakup opcji call na stopy procentowe lub swaptions. Wzrost stóp procentowych zwiększa wartość opcji call na stopy procentowe (prawo do ustalenia wyższej stopy).\nSwaptions (Opcje na swapy): Są to opcje dające posiadaczowi prawo, ale nie obowiązek, do zawarcia w przyszłości określonego swapu stopy procentowej. Aby uzyskać ujemne duration, można kupić swaption, który daje prawo do zawarcia swapu typu “płać zmienną, otrzymuj stałą” (Receive Fixed, Pay Floating). Wartość tego swaptionu wzrośnie wraz ze wzrostem stóp procentowych, ponieważ możliwość zabezpieczenia się przed dalszymi wzrostami stóp staje się cenniejsza. Alternatywnie, można sprzedać swaption, który daje prawo do zawarcia swapu typu “płać stałą, otrzymuj zmienną” (Pay Fixed, Receive Floating), ponieważ spadek jego wartości (zysk dla sprzedającego opcję) nastąpi wraz ze wzrostem stóp.\nInterest Rate Caps (Capy): Są to serie opcji call na stopy procentowe, które chronią kupującego przed wzrostem stóp procentowych powyżej określonego poziomu (strike rate). Cap działa jak ubezpieczenie od wzrostu stóp procentowych. Kupujący cap otrzymuje płatność, gdy zmienna stopa referencyjna (np. LIBOR) przekroczy uzgodnioną stopę maksymalną. Posiadanie capów generuje zyski, gdy stopy procentowe rosną, co efektywnie nadaje portfelowi ujemne duration w zakresie wzrostu stóp. Capy są szczególnie użyteczne dla podmiotów z zobowiązaniami o zmiennym oprocentowaniu (np. kredyty o zmiennej stopie), które chcą ograniczyć swoje ryzyko wzrostu kosztów.\n\n\nObligacje o zmiennym oprocentowaniu (Floating Rate Notes, FRN) z ujemnym spreadem lub Inverse Floaters:\n\nInverse Floaters: Są to obligacje, których kupon porusza się w odwrotnym kierunku do stóp rynkowych (np. Kupon = \\(X - Y \\times\\) LIBOR). Gdy LIBOR rośnie, kupon maleje, a cena obligacji spada. Ze względu na tę odwrotną zależność, ich duration jest często ujemne. Są to instrumenty bardziej złożone i rzadziej spotykane na rynku.\nFRN z ujemnym spreadem: Rzadziej spotykane, ale teoretycznie możliwe konstrukcje FRN, które reagują negatywnie na wzrost stóp, choć ich duration jest zazwyczaj bliskie zeru.\n\n\nPrzed jakim rodzajem ryzyka taki portfel zabezpiecza?\nPortfel o ujemnym czasie trwania zabezpiecza przede wszystkim przed ryzykiem wzrostu stóp procentowych (Interest Rate Risk - Rising Rates).\n\nWzrost stóp procentowych zazwyczaj powoduje spadek wartości tradycyjnych, długoterminowych instrumentów dłużnych (o dodatnim duration), co prowadzi do strat kapitałowych dla ich posiadaczy. Dzieje się tak, ponieważ istniejące obligacje o niższym oprocentowaniu stają się mniej atrakcyjne w porównaniu do nowo emitowanych obligacji z wyższymi kuponami.\nPortfel o ujemnym duration jest skonstruowany tak, aby generować zyski na wzroście stóp procentowych. Te zyski mają na celu kompensację strat poniesionych na innych aktywach w portfelu (np. na posiadanych obligacjach o dodatnim duration, kredytach o stałym oprocentowaniu) lub na zobowiązaniach (np. gdy bank ma stałe oprocentowanie na aktywach i zmienne na pasywach, wzrost stóp zwiększa koszt finansowania depozytów).\n\nJest to kluczowa strategia dla instytucji, które są narażone na ryzyko wzrostu stóp procentowych, np.: * Banki posiadające duże portfele kredytów o stałym oprocentowaniu (ich wartość rynkowa spada, gdy stopy rosną, a bank musi płacić więcej za pozyskanie depozytów o zmiennym oprocentowaniu). * Fundusze emerytalne i firmy ubezpieczeniowe z długoterminowymi zobowiązaniami, których zdyskontowana wartość wzrasta wraz ze spadkiem stóp, ale koszty ich obsługi mogą wzrosnąć w miarę wzrostu stóp. * Firmy z dużym zadłużeniem o zmiennym oprocentowaniu, które chcą zabezpieczyć się przed wzrostem kosztów obsługi długu.\nPoprzez dodanie aktywów lub pozycji pochodnych o ujemnym duration, można zimmunizować portfel przed niekorzystnymi ruchami stóp procentowych, stabilizując jego wartość lub przepływy pieniężne. Jest to forma hedgingu, która ma na celu zminimalizowanie niepewności związanej ze zmianami stóp procentowych. Źródło: F. Fabozzi, “Fixed Income Analysis”, CFA Institute Investment Series. Dodatkowe informacje o duration i strategiach zarządzania ryzykiem stopy procentowej: Corporate Finance Institute - Duration\n\n\n\n6. Scharakteryzuj strategię dopasowania przepływów pieniężnych jako metodę zarządzania ryzykiem stóp procentowych.\nStrategia dopasowania przepływów pieniężnych (Cash Flow Matching) jest pasywną, ale niezwykle skuteczną metodą zarządzania ryzykiem stóp procentowych, która ma na celu immunizację portfela przed ryzykiem zmian stóp procentowych poprzez precyzyjne dopasowanie przyszłych przepływów pieniężnych z aktywów do przyszłych zobowiązań. W przeciwieństwie do bardziej dynamicznych strategii opartych na duration, cash flow matching dąży do całkowitego wyeliminowania ryzyka reinwestycji i ryzyka cenowego poprzez dokładne synchronizowanie wpływów i wypływów gotówki.\nCharakterystyka strategii:\n\nCel: Głównym celem jest zapewnienie, że instytucja będzie miała wystarczające środki finansowe w odpowiednim czasie, aby pokryć wszystkie swoje przyszłe, z góry określone zobowiązania, niezależnie od tego, jak zmienią się stopy procentowe na rynku. Jest to strategia “ustaw i zapomnij” w sensie, że po jej wdrożeniu nie wymaga ciągłych korekt ani rebalansowania, co redukuje koszty i złożoność zarządzania. Jej głównym zadaniem jest eliminacja niepewności co do przyszłych przepływów pieniężnych.\nMechanizm: Strategia polega na zakupie instrumentów dłużnych (np. obligacji zerokuponowych, obligacji kuponowych, czy nawet niestandardowych instrumentów dostosowanych do potrzeb), których terminy płatności kuponów i wykupu oraz ich wartości dokładnie odpowiadają terminom i wartościom przyszłych zobowiązań instytucji.\n\nDla każdego przyszłego zobowiązania (np. płatności emerytalnej, spłaty długu korporacyjnego, wypłaty odszkodowania ubezpieczeniowego, kosztów operacyjnych w przyszłości) identyfikuje się odpowiedni instrument finansowy (lub kombinację instrumentów), który wygeneruje przepływ pieniężny o tej samej wartości i w tym samym terminie.\nJeśli zobowiązania są rozłożone w czasie (co jest typowe dla funduszy emerytalnych czy firm ubezpieczeniowych), tworzy się portfel obligacji z różnymi terminami zapadalności i strukturami kuponowymi, tak aby suma przepływów pieniężnych z aktywów w każdym okresie była równa lub większa niż zobowiązania w tym okresie. Proces ten często rozpoczyna się od najdalszych zobowiązań i cofa się w czasie, aby zoptymalizować wykorzystanie przepływów kuponowych w taki sposób, by minimalizować nadwyżki gotówki.\n\nPasywne zarządzanie: Po skonstruowaniu portfela, zarządzanie jest minimalne. Nie wymaga ciągłego monitorowania i rebalansowania portfela w odpowiedzi na zmiany stóp procentowych, w przeciwieństwie do strategii immunizacji duration, która wymaga regularnego rebalansowania (ponieważ duration portfela zmienia się w czasie i wraz ze zmianami stóp). W cash flow matching, przepływy pieniężne są z góry ustalone i nie zależą od przyszłych stóp, co czyni ją odporną na ich wahania.\nBrak ryzyka reinwestycji i ryzyka cenowego:\n\nRyzyko reinwestycji: Zostaje praktycznie wyeliminowane, ponieważ otrzymane przepływy pieniężne są bezpośrednio wykorzystywane do pokrycia zobowiązań, a nie reinwestowane po niepewnych przyszłych stopach rynkowych. To jest kluczowa przewaga nad strategiami duration, które zakładają reinwestycję kuponów po rynkowej stopie, która może być niższa niż oczekiwano.\nRyzyko cenowe: Zostaje wyeliminowane, ponieważ obligacje w portfelu są utrzymywane do terminu wykupu, a ich bieżące ceny rynkowe stają się mniej istotne. Zmiany cen rynkowych obligacji w portfelu nie mają wpływu na zdolność instytucji do pokrycia zobowiązań, o ile obligacje zostaną utrzymane do wykupu i emitent nie zbankrutuje.\n\n\nZalety:\n\nProstota i przejrzystość: Koncepcja jest stosunkowo łatwa do zrozumienia i wdrożenia, zwłaszcza dla prostych struktur zobowiązań. Jej logiczność jest intuicyjna, co ułatwia komunikację z interesariuszami.\nWysoka skuteczność immunizacji: Jest to jedna z najbardziej skutecznych metod eliminacji ryzyka stopy procentowej, ponieważ nie opiera się na aproksymacjach (jak duration), lecz na bezpośrednim dopasowaniu przepływów pieniężnych. Zapewnia niemal całkowitą pewność pokrycia przyszłych zobowiązań, co jest kluczowe dla instytucji o ściśle określonych płatnościach.\nMinimalne zarządzanie po wdrożeniu: Po początkowej konstrukcji portfela, wymaga niewielkich interwencji, co obniża koszty zarządzania w dłuższej perspektywie w porównaniu do aktywnych strategii hedgingowych.\n\nWady:\n\nWysokie koszty transakcyjne: Znalezienie i zakup precyzyjnie dopasowanych instrumentów dla każdego zobowiązania może być kosztowne, zwłaszcza jeśli zobowiązania są liczne, rozłożone w czasie i o nieregularnych wartościach. Rynek może nie oferować idealnie dopasowanych obligacji, co zmusza do zakupu instrumentów o zbliżonych terminach i wartościach, co może generować nadwyżki gotówki (i w konsekwencji ryzyko reinwestycji nadwyżek) lub niedobory.\nOgraniczona elastyczność: Strategia jest bardzo sztywna. Wszelkie zmiany w harmonogramie zobowiązań (np. wcześniejsze spłaty kredytów, nowe zobowiązania, zmiany w prognozach wypłat emerytalnych, czy nawet opcje call/put w obligacjach) wymagają całkowitej przebudowy portfela, co jest kosztowne i czasochłonne. Może to być problematyczne dla zobowiązań o niepewnym harmonogramie.\nTrudność w znalezieniu idealnych dopasowań: Na rynku może być trudno znaleźć instrumenty dłużne, które idealnie pasują do wszystkich przyszłych zobowiązań pod względem terminu i wartości. Może to wymagać zakupu większej liczby instrumentów niż jest to ściśle konieczne, co zwiększa koszty i może obniżyć efektywność kapitałową portfela. Obligacje zerokuponowe są idealne do cash flow matching, ale ich dostępność na wszystkie terminy zapadalności jest ograniczona.\nWymaga znacznego kapitału początkowego: Zazwyczaj wymaga zainwestowania dużej kwoty kapitału na początku, aby pokryć wszystkie przyszłe zobowiązania, co może być wyzwaniem dla instytucji z ograniczonymi środkami. W przeciwieństwie do duration matching, nie można wykorzystać reinwestycji kuponów do zmniejszenia początkowej inwestycji.\n\nStrategia dopasowania przepływów pieniężnych jest często stosowana przez instytucje z długoterminowymi i przewidywalnymi zobowiązaniami, takie jak fundusze emerytalne, firmy ubezpieczeniowe (zwłaszcza te oferujące renty dożywotnie i inne długoterminowe polisy) oraz rządy (w zarządzaniu długiem publicznym), gdzie pewność pokrycia przyszłych płatności jest absolutnym priorytetem, a elastyczność ma mniejsze znaczenie w porównaniu do pewności finansowej. Źródło: Z. Jędrzejczyk, “Zarządzanie ryzykiem finansowym”, PWE 2011. Dodatkowe informacje o cash flow matching: Corporate Finance Institute - Cash Flow Matching\n\n\n\n7. Scharakteryzuj wskaźnik Altmana. Jaki rodzaj ryzyka mierzy ten wskaźnik.\nWskaźnik Altmana (Altman Z-Score) to model statystyczny opracowany przez Edwarda I. Altmana w 1968 roku na podstawie analizy danych finansowych amerykańskich przedsiębiorstw przemysłowych. Służy on do prognozowania prawdopodobieństwa bankructwa przedsiębiorstwa w ciągu najbliższych dwóch lat. Jest to wielowymiarowy model dyskryminacyjny, który łączy pięć kluczowych wskaźników finansowych w jedną, zagregowaną wartość, pozwalając na kompleksową ocenę kondycji finansowej firmy. Model ten zdobył dużą popularność ze względu na swoją prostotę i relatywnie wysoką skuteczność.\nWzór (dla spółek publicznych):\n\\[Z = 1.2A + 1.4B + 3.3C + 0.6D + 1.0E\\]\ngdzie: * A = Kapitał obrotowy / Aktywa ogółem (Working Capital / Total Assets) * Rationale: Mierzy płynność operacyjną i wielkość aktywów obrotowych w stosunku do całkowitych aktywów. Wskazuje na zdolność firmy do pokrywania bieżących zobowiązań z aktywów obrotowych, które szybko mogą zostać zamienione na gotówkę. Niski wskaźnik może sygnalizować problemy z płynnością krótkoterminową i wskazywać na potrzebę restrukturyzacji operacyjnej. * B = Zyski zatrzymane / Aktywa ogółem (Retained Earnings / Total Assets) * Rationale: Mierzy skumulowane zyski (lub straty) w stosunku do całkowitych aktywów. Jest to wskaźnik efektywności firmy w generowaniu zysków w dłuższym okresie i ich reinwestowaniu w rozwój lub spłatę zobowiązań. Ujemne lub bardzo niskie zyski zatrzymane wskazują, że firma ma długą historię nierentowności lub znacznych strat, co osłabia jej bazę kapitałową i zwiększa uzależnienie od zewnętrznego finansowania. * C = Zysk przed odsetkami i podatkami (EBIT) / Aktywa ogółem (Earnings Before Interest and Taxes / Total Assets) * Rationale: Mierzy efektywność operacyjną firmy w generowaniu zysków z jej aktywów, niezależnie od struktury finansowania (wpływ odsetek) i obciążeń podatkowych. Jest to kluczowy wskaźnik rentowności operacyjnej, wskazujący na zdolność aktywów do generowania dochodu. Wysoki wskaźnik C świadczy o efektywnym wykorzystaniu aktywów i silnej rentowności podstawowej działalności, co jest fundamentalne dla zdolności do obsługi długu. * D = Wartość rynkowa kapitału własnego / Zobowiązania ogółem (Market Value of Equity / Total Liabilities) * Rationale: Mierzy, ile aktywów firmy jest finansowanych przez kapitał własny (wartość rynkowa odzwierciedlająca oczekiwania inwestorów co do przyszłych zysków i stabilności firmy) w stosunku do długu. Jest to wskaźnik dźwigni finansowej i zdolności firmy do pokrycia swoich zobowiązań. Wysoka wartość rynkowa kapitału własnego w stosunku do długu wskazuje na silną pozycję finansową, niskie zadłużenie i zaufanie rynku, co jest kluczowe dla pozyskiwania dalszego finansowania. Niska wartość sugeruje wysokie zadłużenie i niskie zaufanie inwestorów. * E = Sprzedaż / Aktywa ogółem (Sales / Total Assets) * Rationale: Mierzy efektywność wykorzystania aktywów do generowania sprzedaży (tzw. wskaźnik rotacji aktywów). Niska wartość może wskazywać na nieefektywne zarządzanie aktywami, przestarzałe aktywa lub problemy ze sprzedażą produktów/usług firmy, co finalnie przekłada się na niższe zyski. Wysoki wskaźnik oznacza efektywne wykorzystanie zasobów do generowania przychodów.\nInterpretacja wskaźnika Z-Score (dla spółek publicznych):\nAltman zaproponował następujące strefy interpretacji, które są powszechnie stosowane:\n\nZ &gt; 2.99: “Bezpieczna strefa” – niskie prawdopodobieństwo bankructwa. Firma jest w dobrej kondycji finansowej i wykazuje stabilność.\n1.81 &lt; Z &lt; 2.99: “Szara strefa” – umiarkowane prawdopodobieństwo bankructwa. Firma wykazuje pewne symptomy problemów finansowych i wymaga monitorowania. Decyzje kredytowe wobec takiej firmy powinny być podejmowane z większą ostrożnością, a inwestorzy mogą żądać wyższej premii za ryzyko.\nZ &lt; 1.81: “Strefa zagrożenia” – wysokie prawdopodobieństwo bankructwa w ciągu dwóch lat. Firma znajduje się w poważnych tarapatach finansowych, a ryzyko defaultu jest znaczące.\n\nJaki rodzaj ryzyka mierzy ten wskaźnik?\nWskaźnik Altmana mierzy przede wszystkim ryzyko kredytowe (Credit Risk), a dokładniej ryzyko niewypłacalności (Default Risk) lub ryzyko bankructwa (Bankruptcy Risk) przedsiębiorstwa.\nDostarcza on syntetycznej oceny kondycji finansowej firmy, wskazując na jej zdolność do generowania zysków, zarządzania aktywami i płynnością, oraz na jej strukturę kapitałową. Niski wynik Z-Score sygnalizuje, że firma ma słabą płynność (niski kapitał obrotowy), niską rentowność (niskie zyski zatrzymane i EBIT), wysoką dźwignię finansową (niska wartość rynkowa kapitału własnego w stosunku do długu) i/lub nieefektywnie wykorzystuje swoje aktywa (niska rotacja sprzedaży), co zwiększa ryzyko, że nie będzie w stanie spłacać swoich zobowiązań i w konsekwencji zbankrutuje.\nWskaźnik ten jest szeroko używany przez banki do oceny zdolności kredytowej potencjalnych kredytobiorców, przez analityków kredytowych do monitorowania portfeli kredytowych i oceny kondycji dłużników, przez inwestorów do oceny ryzyka inwestycji w obligacje korporacyjne oraz przez zarządzających do wczesnego wykrywania problemów finansowych w swoich własnych firmach i podejmowania działań korygujących. Należy jednak pamiętać, że model Altmana został opracowany na danych z sektora przemysłowego i może wymagać modyfikacji dla innych sektorów (np. finansowego, usługowego) oraz dla firm prywatnych (gdzie brakuje wartości rynkowej kapitału własnego, stąd powstają modyfikacje takie jak Altman Z’-score). Źródło: E.I. Altman, “Financial Ratios, Discriminant Analysis and the Prediction of Corporate Bankruptcy”, The Journal of Finance, Vol. 23, No. 4 (Sep., 1968), pp. 589-609. Dodatkowe informacje: Investopedia - Altman Z-Score\n\n\n\n8. Wskaż przynajmniej dwa wybrane przejawy ryzyka kredytowego (dwa rodzaje zdarzeń kredytowych), inne niż bankructwo.\nRyzyko kredytowe to ryzyko, że dłużnik nie wywiąże się ze swoich zobowiązań finansowych, co spowoduje stratę dla wierzyciela. Chociaż bankructwo jest najbardziej radykalnym i ostatecznym przejawem ryzyka kredytowego, istnieje wiele innych zdarzeń kredytowych (credit events), które sygnalizują pogorszenie zdolności kredytowej dłużnika i mogą prowadzić do znaczących strat dla wierzycieli, zanim dojdzie do formalnego bankructwa. Te zdarzenia są często precyzyjnie definiowane w umowach kredytowych, emisjach obligacji oraz w instrumentach pochodnych (np. Credit Default Swaps), ponieważ ich wystąpienie może wywołać klauzule umowne lub aktywować zabezpieczenia.\nPoniżej dwa przykłady zdarzeń kredytowych innych niż bankructwo, wraz z ich konsekwencjami:\n\nNiewykonanie zobowiązania (Default) / Opóźnienie w płatności (Payment Default):\n\nJest to sytuacja, w której dłużnik nie dokonuje płatności odsetek lub kapitału w ustalonym terminie, zgodnie z warunkami umowy kredytowej, obligacji lub innego instrumentu dłużnego. Choć nie jest to jeszcze bankructwo (które zazwyczaj wiąże się z oficjalnym postępowaniem sądowym, np. ogłoszeniem upadłości lub likwidacją), jest to wyraźny i poważny sygnał problemów finansowych dłużnika oraz naruszenie umowy. Często umowy precyzują, po jakim czasie opóźnienia płatność jest traktowana jako default (np. po 30 dniach).\nKonsekwencje dla wierzyciela: Opóźnienie w płatności może być krótkotrwałe (np. kilka dni), ale nawet takie może prowadzić do naliczania kar umownych i wzrostu kosztów. W przypadku dłuższego opóźnienia, default może skutkować wszczęciem procedur windykacyjnych, restrukturyzacji długu lub ostatecznie do bankructwa. Dla wierzyciela oznacza to utratę oczekiwanych przepływów pieniężnych, konieczność odpisów aktualizujących wartość należności w księgach oraz potencjalne straty kapitałowe. Ponadto, default jednej płatności może wywołać tzw. cross-default, czyli klauzule w innych umowach dłużnika, które automatycznie uznają go za niewypłacalnego również w stosunku do innych wierzycieli, znacząco pogarszając jego sytuację.\nPrzykład: Firma “Z” udzieliła bankowi kredytu w formie obligacji. Z powodu nagłych problemów z płynnością firma ta nie jest w stanie zapłacić kuponu od swoich obligacji w dniu jego wymagalności. Mimo że firma nadal prowadzi działalność, to zdarzenie jest uznawane za payment default i aktywuje klauzule w umowach z innymi kredytodawcami, które mogą żądać natychmiastowej spłaty całego długu.\n\nRestrukturyzacja długu (Debt Restructuring):\n\nTo zmiana pierwotnych warunków umowy kredytowej lub obligacji, zazwyczaj inicjowana przez dłużnika w obliczu trudności finansowych, aby uniknąć bankructwa i umożliwić mu kontynuowanie działalności. Restrukturyzacja jest często wynikiem intensywnych negocjacji między dłużnikiem a jego wierzycielami. Może przyjąć różne formy i zazwyczaj wiąże się z ustępstwami ze strony wierzycieli, co oznacza dla nich stratę (częściową lub całkowitą) w stosunku do pierwotnych, korzystniejszych warunków.\nPrzykłady typowych zmian w restrukturyzacji:\n\nObniżenie stopy procentowej: Zmniejszenie obciążeń odsetkowych dla dłużnika, co zmniejsza jego bieżące wydatki.\nWydłużenie terminu spłaty: Dłużnik ma więcej czasu na spłatę kapitału, co poprawia jego płynność i obniża roczne raty.\nOdroczone płatności (deferral): Przesunięcie terminów płatności odsetek lub kapitału na późniejszy okres, dając dłużnikowi czas na poprawę sytuacji finansowej.\nCzęściowe umorzenie długu (haircut): Wierzyciele zgadzają się na umorzenie części kapitału długu. Jest to bezpośrednia, definitywna strata dla wierzyciela, często akceptowana w zamian za większe prawdopodobieństwo odzyskania pozostałej części.\nKonwersja długu na kapitał własny (debt-to-equity swap): Wierzyciele zamieniają swoje roszczenia z tytułu długu na udziały w kapitale własnym dłużnika, stając się jego współwłaścicielami. Ma to na celu zmniejszenie obciążenia dłużnika długiem, ale dla wierzyciela oznacza zmianę formy roszczenia (z długu na kapitał własny, który jest bardziej ryzykowny) i często utratę części wartości.\n\nKonsekwencje dla wierzyciela: Dla wierzyciela restrukturyzacja oznacza zazwyczaj zmniejszenie wartości odzyskiwanej z długu (recovery rate) w porównaniu do pierwotnych warunków. Jest to zdarzenie kredytowe, ponieważ wskazuje na istotne pogorszenie zdolności kredytowej dłużnika i konieczność modyfikacji warunków w celu uniknięcia jeszcze większych strat (np. z bankructwa). Jest to często preferowane rozwiązanie dla wierzycieli, jeśli pozwala uniknąć pełnej utraty kapitału w przypadku bankructwa dłużnika.\nPrzykład: Kraj Y, mający poważne problemy z obsługą zadłużenia publicznego, negocjuje z międzynarodowymi wierzycielami (bankami komercyjnymi, funduszami inwestycyjnymi, innymi państwami) wydłużenie terminów spłaty swoich obligacji i obniżenie oprocentowania. Wierzyciele zgadzają się na te ustępstwa, aby uniknąć niewykonania zobowiązania przez państwo, co mogłoby mieć jeszcze bardziej destabilizujące konsekwencje.\n\n\nInne istotne przejawy ryzyka kredytowego, poza bankructwem, to m.in.: * Obniżenie ratingu kredytowego (Credit Rating Downgrade): Agencje ratingowe (np. Moody’s, S&P, Fitch) obniżają ocenę zdolności kredytowej dłużnika. Choć nie jest to bezpośredni default, sygnalizuje to wzrost ryzyka defaultu i zazwyczaj prowadzi do wzrostu kosztów finansowania dla dłużnika oraz spadku wartości rynkowej jego długu, utrudniając pozyskanie nowego kapitału. * Naruszenie kowenantów (Covenant Breach): Dłużnik narusza określone warunki finansowe lub operacyjne zawarte w umowie kredytowej (tzw. kowenanty), np. nieutrzymanie określonego wskaźnika zadłużenia do EBITDA, nieosiągnięcie minimalnego poziomu płynności, przekroczenie limitów inwestycyjnych. Naruszenie kowenantów może skutkować natychmiastową wymagalnością całego długu (tzw. acceleration clause), co stawia dłużnika w sytuacji bliskiej defaultu. * Repudiacja/Moratorium (Repudiation/Moratorium): Odmowa dłużnika (często państwa) spłaty długu lub ogłoszenie tymczasowego zawieszenia płatności. Jest to jednostronne działanie, które jest równoznaczne z defaultem, nawet jeśli nie ma formalnego postępowania upadłościowego. Źródło: Podręczniki z zakresu zarządzania ryzykiem kredytowym, np. J. C. Hull, “Risk Management and Financial Institutions”. Dodatkowe informacje: Investopedia - Credit Event\n\n\n\n9. Zdefiniuj i scharakteryzuj dwie podstawowe formy ryzyka płynności.\nRyzyko płynności (Liquidity Risk) to fundamentalne ryzyko w sektorze finansowym, które odnosi się do zagrożenia, że instytucja finansowa nie będzie w stanie wywiązać się ze swoich krótkoterminowych zobowiązań finansowych w terminie i po rozsądnej cenie. Materializacja tego ryzyka może prowadzić do poważnych problemów finansowych, a nawet do bankructwa, nawet jeśli instytucja jest solventna długoterminowo (tj. jej aktywa przewyższają pasywa). Dzieje się tak, ponieważ brak gotówki do pokrycia bieżących wypłat uniemożliwia kontynuowanie działalności. Wyróżnia się dwie podstawowe, wzajemnie powiązane formy ryzyka płynności:\n\nRyzyko płynności finansowania (Funding Liquidity Risk / Cash Flow Liquidity Risk):\n\nDefinicja: Jest to ryzyko, że instytucja nie będzie w stanie pozyskać wystarczających środków finansowych (gotówki lub aktywów łatwo zamienialnych na gotówkę) w odpowiednim czasie i po rozsądnej cenie, aby pokryć swoje bieżące i przyszłe zobowiązania. Dotyczy to zdolności do generowania gotówki w celu zaspokojenia potrzeb finansowych wynikających z napływów i wypływów środków.\nCharakterystyka:\n\nŹródło: Wynika z niedopasowania terminów zapadalności aktywów i pasywów (tzw. maturity mismatch, np. finansowanie długoterminowych kredytów krótkoterminowymi depozytami, które mogą być wycofane w dowolnym momencie), nagłych i nieoczekiwanych wypłat środków (np. masowe wycofywanie depozytów przez klientów w wyniku paniki lub utraty zaufania, tzw. bank run), niemożności rolowania krótkoterminowego zadłużenia (np. krótkoterminowych pożyczek międzybankowych, emisji krótkoterminowych papierów dłużnych), utraty dostępu do rynków finansowania (np. z powodu pogorszenia ratingu kredytowego banku) lub znacznego wzrostu kosztów pozyskania finansowania.\nSkutki: Może prowadzić do konieczności sprzedaży aktywów po niekorzystnych cenach (tzw. fire sale), aby szybko pozyskać gotówkę, co generuje straty i może prowadzić do spadku wartości aktywów bilansowych. Długoterminowo może skutkować utratą reputacji, odpływem klientów i w skrajnych przypadkach do upadłości instytucji. W kontekście systemowym, problem jednego banku z płynnością finansowania może rozprzestrzenić się na cały system.\nZarządzanie: Wymaga utrzymywania odpowiednich buforów płynności (np. gotówki, wysokiej jakości płynnych aktywów, takich jak obligacje rządowe, które są łatwo zbywalne), dywersyfikacji źródeł finansowania (np. depozyty detaliczne, depozyty hurtowe, emisje długu, linie kredytowe od innych banków) oraz aktywnego monitorowania i prognozowania przepływów pieniężnych (tzw. cash flow forecasting). Banki często tworzą plany awaryjne (Contingency Funding Plans) na wypadek kryzysu płynności.\nPrzykład: Bank A jest silnie uzależniony od krótkoterminowych pożyczek na rynku międzybankowym. W wyniku nagłego kryzysu zaufania na rynku, inne banki odmawiają mu udzielenia pożyczek, co sprawia, że Bank A nie jest w stanie pokryć bieżących wypłat depozytów i musi sprzedawać swoje aktywa po znacznie zaniżonych cenach.\n\n\nRyzyko płynności rynkowej (Market Liquidity Risk / Asset Liquidity Risk):\n\nDefinicja: Jest to ryzyko, że instytucja nie będzie w stanie szybko i efektywnie zrealizować transakcji na rynku (kupić lub sprzedać aktywa) po cenie zbliżonej do ostatniej ceny rynkowej, z powodu niewystarczającej głębokości lub szerokości rynku. Dotyczy to zdolności do szybkiej konwersji aktywów na gotówkę bez znaczącego wpływu na ich cenę.\nCharakterystyka:\n\nŹródło: Wynika z niskiej płynności danego aktywa (np. instrumenty niestandardowe, duże pakiety akcji małych spółek, niestandardowe instrumenty pochodne, obligacje o niskim wolumenie obrotu), braku wystarczającej liczby kupujących lub sprzedających na rynku, wysokich spreadów bid-ask (różnicy między ceną kupna a ceną sprzedaży, która stanowi koszt transakcyjny), lub ogólnego załamania płynności na rynku (tzw. flight to quality w czasie kryzysu, gdy inwestorzy wycofują się z ryzykownych aktywów i koncentrują się na bezpiecznych, płynnych instrumentach).\nSkutki: Może prowadzić do konieczności akceptowania znacznie niższych cen sprzedaży (lub wyższych cen zakupu) niż oczekiwano, co generuje straty transakcyjne i kapitałowe. Może również uniemożliwić instytucji zrealizowanie zaplanowanych strategii handlowych, zabezpieczających lub restrukturyzacyjnych, ponieważ niemożność wyjścia z pozycji lub wejścia w nią po rozsądnej cenie staje się barierą.\nZarządzanie: Wymaga regularnej oceny płynności posiadanych aktywów (np. poprzez analizę wolumenu obrotu, spreadów bid-ask, głębokości rynku), unikania nadmiernej koncentracji w aktywach o niskiej płynności oraz posiadania planów awaryjnych na wypadek spadku płynności rynkowej, w tym możliwości sekurytyzacji aktywów lub wykorzystania repo.\nPrzykład: Fundusz inwestycyjny musi szybko sprzedać duży pakiet akcji spółki notowanej na mniej płynnym rynku, aby sprostać żądaniom wykupu jednostek przez inwestorów. Ze względu na brak zainteresowania kupujących, fundusz jest zmuszony sprzedać akcje po cenie znacznie niższej niż ich ostatnia wycena, co generuje straty dla funduszu i jego klientów.\n\n\n\nObie formy ryzyka płynności są ze sobą ściśle powiązane i często wzajemnie się wzmacniają, tworząc tzw. spiralę płynnościową. Problemy z płynnością finansowania (np. nagły odpływ depozytów) mogą zmusić instytucję do sprzedaży aktywów. Jeśli te aktywa są mało płynne lub rynek jest w stresie, bank ujawni ryzyko płynności rynkowej, co doprowadzi do sprzedaży po zaniżonych cenach, generując straty i obniżając współczynniki kapitałowe. To z kolei może jeszcze bardziej podważyć zaufanie i pogłębić problemy z płynnością finansowania. Skuteczne zarządzanie płynnością wymaga holistycznego podejścia do obu tych aspektów i uwzględnienia ich interakcji. Źródło: Basel Committee on Banking Supervision (BCBS) - “Principles for Sound Liquidity Risk Management and Supervision”. Dodatkowe informacje: Investopedia - Liquidity Risk\n\n\n\n10. Co mierzy i jak należy intepretować wskaźnik NSFR (Net Stable Funding Ratio).\nWskaźnik NSFR (Net Stable Funding Ratio), czyli Wskaźnik Stabilnego Finansowania Netto, jest kluczowym wskaźnikiem płynności wprowadzonym w ramach regulacji Bazylea III przez Bazylejski Komitet Nadzoru Bankowego (BCBS). Jego głównym celem jest zapewnienie, że banki utrzymują wystarczającą ilość stabilnego finansowania, aby pokryć swoje długoterminowe aktywa i działalność pozabilansową. Ma to na celu zmniejszenie ryzyka płynności finansowania w horyzoncie długoterminowym (ponad jeden rok) i strukturalne wzmocnienie bilansów banków, aby były mniej podatne na przyszłe kryzysy finansowe.\nCo mierzy NSFR:\nNSFR mierzy stosunek dostępnego stabilnego finansowania (Available Stable Funding, ASF) do wymaganego stabilnego finansowania (Required Stable Funding, RSF) w horyzoncie jednego roku. Wskaźnik ten ma na celu promowanie strukturalnej stabilności finansowania banków poprzez zapewnienie, że banki finansują swoje długoterminowe aktywa i zobowiązania pozabilansowe stabilnymi źródłami, które są mniej podatne na nagłe wycofanie w warunkach rynkowych napięć.\n\nDostępne Stabilne Finansowanie (ASF): Obejmuje te komponenty bilansu i pozycji pozabilansowych, które są uznawane za stabilne źródła finansowania na horyzoncie jednego roku lub dłużej. Wartości poszczególnych pozycji są ważone współczynnikami stabilności (stable funding factors), odzwierciedlającymi ich trwałość i odporność na wycofanie w warunkach stresowych. Im dłuższy termin zapadalności i bardziej stabilne źródło finansowania, tym wyższa waga przypisana do ASF.\n\nPrzykłady i ich wagi (przykładowe):\n\nKapitał własny banku: (np. kapitał zakładowy, zyski zatrzymane, rezerwy) - waga 100% (najbardziej stabilne źródło).\nZobowiązania długoterminowe: (np. wyemitowane obligacje z terminem zapadalności powyżej 1 roku, długoterminowe kredyty bankowe) - waga 100% (jeśli termin zapadalności jest bardzo długi, np. &gt;5 lat) lub niższe wagi (np. 50% dla terminów 6 miesięcy - 1 rok).\nDepozyty klientów: Ich stabilność zależy od typu depozytu i relacji z klientem.\n\nDepozyty detaliczne (np. oszczędnościowe, bieżące): często stabilne, szczególnie te ubezpieczone i te, które nie są operacyjnie powiązane z dużymi firmami (waga 90-95%).\nDepozyty operacyjne (firm, które muszą utrzymywać środki w banku do rozliczeń): również wysoka waga (np. 85-90%).\nDepozyty hurtowe (od dużych firm, innych banków): niższa waga (np. 50% lub 0% dla bardzo krótkoterminowych), ponieważ są mniej stabilne i bardziej podatne na szybkie wycofanie.\n\nInne zobowiązania: (np. pożyczki od innych instytucji finansowych z terminem zapadalności powyżej 1 roku) - wagi zależne od terminu i kontrahenta.\n\n\nWymagane Stabilne Finansowanie (RSF): Odzwierciedla zapotrzebowanie na stabilne finansowanie, wynikające z posiadanych aktywów oraz pozycji pozabilansowych. Wartości aktywów i pozycji pozabilansowych są ważone współczynnikami (required stable funding factors), które odzwierciedlają ich płynność, długość terminu utrzymywania w bilansie banku oraz ryzyko. Aktywa o dłuższym terminie zapadalności, niższej płynności lub wyższym ryzyku wymagają większego stabilnego finansowania.\n\nPrzykłady i ich wagi (przykładowe):\n\nGotówka i rezerwy w banku centralnym: 0% RSF (są to najbardziej płynne aktywa, nie wymagają dodatkowego stabilnego finansowania).\nWysokiej jakości płynne aktywa (HQLA): (np. obligacje rządowe o wysokim ratingu) - niskie RSF, np. 5-10%, ponieważ są łatwo zbywalne.\nKredyty dla klientów: (np. kredyty hipoteczne, kredyty korporacyjne) - wymagają wysokiego RSF, np. 65-85%, ponieważ są długoterminowe i mniej płynne.\nAktywa o bardzo niskiej płynności: (np. nieruchomości, udziały w spółkach zależnych, inwestycje w infrastrukturę) - 100% RSF.\nInstrumenty pochodne i pozycje pozabilansowe: (np. niewykorzystane linie kredytowe, gwarancje, zobowiązania wynikające z transakcji finansowania papierów wartościowych) - również generują zapotrzebowanie na RSF, w zależności od ich charakteru i prawdopodobieństwa aktywacji w warunkach stresu.\n\n\n\nWzór NSFR:\n\\[NSFR = \\frac{\\text{Dostępne Stabilne Finansowanie (ASF)}}{\\text{Wymagane Stabilne Finansowanie (RSF)}} \\ge 100\\%\\]\nJak należy interpretować wskaźnik NSFR:\n\nNSFR \\(\\ge 100\\%\\): Oznacza, że bank posiada wystarczającą ilość dostępnego stabilnego finansowania, aby pokryć swoje wymagane stabilne finansowanie. Jest to minimalny wymóg regulacyjny, który wszedł w życie 1 stycznia 2018 r. dla większości jurysdykcji. Banki dążą do utrzymywania NSFR powyżej 100%, co świadczy o ich stabilności finansowej, odporności na szoki płynnościowe i zdolności do finansowania długoterminowych aktywów za pomocą stabilnych źródeł. Wyższy wskaźnik oznacza większą odporność na potencjalne kryzysy płynnościowe. Organy nadzoru monitorują ten wskaźnik, aby upewnić się, że banki są odpowiednio przygotowane na długoterminowe wyzwania.\nNSFR \\(&lt; 100\\%\\): Oznacza, że bank nie posiada wystarczającej ilości stabilnego finansowania w stosunku do swoich aktywów i działalności pozabilansowej. Taka sytuacja sygnalizuje podwyższone ryzyko płynności finansowania, ponieważ bank jest nadmiernie uzależniony od krótkoterminowego, niestabilnego finansowania. W przypadku trudności na rynkach finansowania, bank może mieć problem z rolowaniem długu lub pozyskaniem nowych środków, co może prowadzić do problemów z płynnością, konieczności sprzedaży aktywów po zaniżonych cenach i utraty zaufania. Niski NSFR może prowadzić do interwencji regulacyjnych i narzucenia dodatkowych wymogów kapitałowych lub płynnościowych.\n\nCel i znaczenie NSFR:\nGłównym celem wprowadzenia NSFR jest:\n\nZwiększenie długoterminowej stabilności finansowania banków: Poprzez promowanie finansowania aktywów długoterminowych stabilnymi źródłami, NSFR zmniejsza ryzyko niedopasowania terminów zapadalności między aktywami a pasywami, które było jednym z kluczowych czynników kryzysu finansowego w 2008 roku.\nZmniejszenie zależności od krótkoterminowego finansowania hurtowego: Wskaźnik ten zniechęca banki do nadmiernego polegania na niestabilnych, wrażliwych na wahania rynkowe źródłach finansowania (np. krótkoterminowych pożyczkach międzybankowych), które mogą szybko zniknąć w czasie kryzysu finansowego.\nPoprawa odporności na szoki finansowania: Wzmacnia zdolność banków do przetrwania okresów stresu rynkowego, gdy dostęp do finansowania jest ograniczony lub jego koszt gwałtownie wzrasta, bez konieczności interwencji publicznych.\nWspieranie zdrowych praktyk zarządzania płynnością: Zachęca banki do bardziej ostrożnego i konserwatywnego zarządzania strukturą bilansu i źródłami finansowania, promując długoterminowe i stabilne źródła kapitału oraz minimalizując ryzykowne strategie finansowania.\n\nNSFR jest uzupełnieniem innego kluczowego wskaźnika płynności z Bazylei III – Wskaźnika Pokrycia Płynności (Liquidity Coverage Ratio, LCR), który koncentruje się na krótkoterminowej (30-dniowej) odporności na szoki płynnościowe. Podczas gdy LCR zapewnia, że bank ma wystarczające płynne aktywa, aby przetrwać krótkotrwały kryzys, NSFR ma szerszy horyzont (1 rok) i koncentruje się na strukturalnej stabilności finansowania banku, zapewniając, że jego długoterminowa działalność jest odpowiednio finansowana. Razem, te dwa wskaźniki tworzą kompleksowy zestaw narzędzi regulacyjnych do zarządzania ryzykiem płynności. Źródło: Basel Committee on Banking Supervision (BCBS) - “Basel III: The Net Stable Funding Ratio”. Pełna dokumentacja: www.bis.org/bcbs/publ/d295.pdf"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in the bwrob blog. Welcome!\nThis blog is a battleground of sorts, but instead of swords and shields, we wield the weapons of Python and C++. I’m a mathematician turned quantitative analyst turned software engineer. You can expect high standard deviation of topics here.\nHere, I’ll document my coding conquests, from building practical and impractical tools, exploring financial concepts, to playing around with physics simulations.\nExpect a healthy dose of humor alongside the technical discussions. Let’s be honest, even the most complex problems are more enjoyable with a sprinkle of laughter. So, grab a cup of coffee and join me on this exploration – even if it’s just for one interested reader!\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/startup-script/index.html#why-a-startup-script",
    "href": "posts/startup-script/index.html#why-a-startup-script",
    "title": "Python Startup Script",
    "section": "Why a startup script?",
    "text": "Why a startup script?\nConfession time. Pre-COVID I worked for a Swiss bank — it was the whole corporate package. Working from a crowded office, open space, dedicated desks, dedicated desktop PCs, hundreds of people. And we never turned the PCs off, some of them were running constantly for months. Not very eco-friendly behaviour, either from the company side or from the employees. But there were legit reasons for this and the company had much bigger sins on their books.\nAs for the reasons for constantly turned on machines — the proprietary frameworks and tooling we used were awfully heavy and slow. If you were occasionally forced to kill all the processes — due to an update or system crash — getting them all up again took an hour or more. Developer tools, pricing systems, connections to Monte Carlo farms, downloading trade data, analysis definitions — you name it, we used it.\nOne tidbit to get this point across — in 2019 we still used 32-bit Win7, which had a cap on single-process memory consumption to 4GB. We had a universally used hack to extend this to 8GB for Excel, since the default wasn’t enough for many of our pricing sheets.\nWhen I parted ways with the company post-COVID, I got a corporate laptop from the new employer. The office was much sparser, quieter and with ‘hot seats’ approach. I worked mostly remotely either way. This meant switching off the company machine each day, as the VPN connections and certificates wouldn’t last overnight. I was extremely annoyed with opening all of the daily tools again and again, after getting used to having it all waiting for me to jump right in.\nHence the need for a startup script to open all of the apps, tools and files programatically. It won’t cover everything, like authorizations or connections but still a little helper to start the day.\nTo spice things up, we will overengineer the hell out of it and use generic typing, generators and decorators :D."
  },
  {
    "objectID": "posts/startup-script/index.html#the-startup-script",
    "href": "posts/startup-script/index.html#the-startup-script",
    "title": "Python Startup Script",
    "section": "The startup script",
    "text": "The startup script\n\nPublic interface\nLet’s first think about the design and what we want to achieve. Imagine the code being split into two parts:\n\nthe hidden logic layer, the worker that does stuff and\nthe public interface that integrates with the rest of the codebase or is called at the top level, the manager.\n\nWe can start by creating the public interface, see what we want to achieve and later deal with filling in a working implementation. You can either define the logic functions as mocks, or just live with linting issues. This is what my desired usage is:\n\ndef run_startup_script() -&gt; None:\n    \"\"\"Run the startup script.\"\"\"\n    logger.info(f\" Welcome {os.getlogin()}! \".center(40, \"*\"))\n    start_programs(\n        [\n            Program.POWERSHELL,\n            Program.NOTEPAD,\n            (Program.FIREFOX, 8),\n        ],\n    )\n    start_work_files([Path.home() / \".temp\"])\n    run_commands(['Write-Output \"test\"'])\n\nWe specify programs to be launched, open all files in a chosen temp folder and run a list of shell commands. After each step there should be some delay to avoid spamming system with process calls. Certain steps might be more time consuming, like cloud services authorization. Those need longer delay. On the other hand, specifying delay for each task would be cumbersome, most cases would be fine with some default value. We end up with a design that our soon-to-be workers start_programs, start_work_files, and run_commands expect lists of either task or (task, delay_seconds). We can now start the implementation by figuring out how the delay time should be defaulted if not specified.\n\n\nDecorator defaulting the time delays\nNow we can start the implementation. We want the workers to be called with a list of tasks, but a task can be either a command or a tuple including the delay. Let’s not include some complicated conditionals in each of the workers — that would be annoying and potentially get out of sync at some point.\nOther way to do this is to add a default delay to all non-tuple items. We can implement that as a separate defaulting function, which we would call in each worker. But — being more clever! — we could also use a decorator that changes the workers’s signature.\n\nfrom functools import wraps\nfrom collections.abc import Callable\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\nTask = tuple[T, int]\nTaskList = list[Task[T]]\nTaskListOptionalDelay = list[Task[T] | T]\n\n\nDEFAULT_DELAY_SECONDS = 4\n\ndef with_optional_delay(\n    task_worker: Callable[[TaskList[T]], None],\n) -&gt; Callable[[TaskListOptionalDelay[T]], None]:\n    \"\"\"Add default delay to all non-tuple items.\n\n    Args:\n    ----\n        task_worker: A function that takes a list of tasks.\n\n    \"\"\"\n\n    @wraps(task_worker)\n    def task_defaulted_worker(task_list: TaskListOptionalDelay[T]) -&gt; None:\n        \"\"\"Add a default delay to tasks in a task list if no delay is specified.\n\n        Args:\n        ----\n            task_list: A list of tasks with optional delays.\n\n        \"\"\"\n        tasks_with_defaulted_delays: TaskList[T] = [\n            item if isinstance(item, tuple) else (item, DEFAULT_DELAY_SECONDS)\n            for item in task_list\n        ]\n        return task_worker(tasks_with_defaulted_delays)\n\n    return task_defaulted_worker\n\nFirst, for convenience, let’s define a template type annotation:\n\nThe generic variable type is conventionally denoted by T.\nA Task is a tuple of a generic task T and an int delay.\nA TaskList is a list of Tasks. Simple.\nA TaskListOptionalDelay is a list of Tasks or Ts. Those are the guys we are going to turn into TaskLists.\n\nThe decorator with_optional_delay adds a default delay of 4 seconds to all non-tuple items. Its input is a worker function that already expects a TaskList. It fills in the missing delay with the default value and passes it to the decorated function.\n\n\nMain workers\nWith the preparation done, we can start with the workers. For the programs we will be launching, we need to look up the exact paths of the executables. Let’s define a Program enum that would wrap those up in readable nice names. For working with system paths we will use pathlib.Path that provides high-level interface.\n\nfrom enum import Enum\nfrom pathlib import Path\n\n\nclass Program(Enum):\n    \"\"\"Types of programs.\"\"\"\n\n    POWERSHELL = Path(r\"C:\\windows\\system32\\windowspowershell\\v1.0\\powershell.exe\")\n    NOTEPAD = Path(r\"C:\\Program Files\\Notepad++\\notepad++.exe\")\n    FIREFOX = Path(r\"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Firefox.lnk\")\n\nOther than that, the main workers start_programs, start_work_files, and run_commands are simple. They just iterate over the provided TaskList and do the respective action for a given Task.\n\n@with_optional_delay\ndef start_programs(\n    programs: TaskList[Program],\n) -&gt; None:\n    \"\"\"Start listed programs.\n\n    Args:\n    ----\n        programs: List of programs to start.\n            Can be a string or a tuple. If a tuple is given, the first\n            element is the name, the second is the delay.\n\n    \"\"\"\n    for program, delay in programs:\n        start_process(\n            name=program.name,\n            path=program.value,\n            delay=delay,\n        )\n\n\n@with_optional_delay\ndef start_work_files(\n    directory_tasks: TaskList[Path],\n) -&gt; None:\n    \"\"\"Start all  files in the work folders.\n\n    Args:\n    ----\n        directory_tasks: List of tasks with paths to work folders.\n\n    \"\"\"\n    for path, delay in path_files(directory_tasks):\n        start_process(\n            name=path.name,\n            path=path,\n            delay=delay,\n        )\n\n\n@with_optional_delay\ndef run_commands(\n    commands: TaskList[str],\n) -&gt; None:\n    \"\"\"Run all commands in the command list.\n\n    Args:\n    ----\n        commands: List of commands to run.\n\n    \"\"\"\n    for command, delay in commands:\n        run_command(command, delay)\n\n\n\nList all files in list of directories\nNotice the use of path_files generator above. When working with complex iterations, it’s a good practice to create a generator that wraps the iteration details. It is beneficial for readability and maintainability, especially in cases where you need to:\n\nyield multiple values at once (ex. yield path, delay for path in directory),\nhave nested iterators (ex. for directory in list for path in directory),\nfilter the iteration (ex. for path in directory if filter(path)).\n\nHere we’ll have all three of them combined!\n\nNAME_EXCLUDES = (\"$\", \"tmp\")\nEXT_EXCLUDES = (\"exe\",)\n\n\ndef filter_excluded(\n    path: Path,\n) -&gt; bool:\n    \"\"\"Filter path based on name and extension exclude lists.\n\n    Args:\n    ----\n        path: Path to filter.\n\n    \"\"\"\n    return (path.stem not in NAME_EXCLUDES) and (path.suffix not in EXT_EXCLUDES)\n\n\n\ndef path_files(\n    directory_tasks: TaskList[Path],\n) -&gt; Generator[tuple[Path, int], None, None]:\n    \"\"\"Generate all files in the work folder that are not excluded.\n\n    Yields the folder path at beginning of the generator.\n\n    Args:\n    ----\n        directory_tasks: List of tasks with paths to work folders.\n\n    \"\"\"\n    for folder, delay in directory_tasks:\n        yield folder, delay\n\n        all_files = folder.glob(FILES_IN_TREE_PATTERN)\n        filtered = filter(filter_excluded, all_files)\n\n        for file in filtered:\n            yield file, delay\n\nThe filter_excluded function filters out files based on exclusions in name and extension lists. Path.stem and Path.suffix are used to check if the file name or extension is in the lists respectively.\n\n\nInteracting with the OS\nWith all of the framework prepared, the next step is to interact with the OS. To open a file, folder or run an app, we can use the os.startfile function. All the rest of the start_process function is just utility logging. For running a shell command we can use the subprocess module, calling powershell with the powershell.exe and adding the command to run.\n\nimport os\nimport subprocess\nimport time\n\n\ndef start_process(\n    *,\n    name: str,\n    path: Path,\n    delay: int = DEFAULT_DELAY_SECONDS,\n) -&gt; None:\n    \"\"\"Given a path, starts the target.\n\n    Behavior:\n        * Minimizes all windows.\n        * Depending on the path target:\n            * executable files are run,\n            * content files are opened with system default program,\n            * folders are opened with system explorer.\n\n    Args:\n    ----\n        name: Name of the process to start.\n        path: Path to the target.\n        delay: Time to wait after starting the process.\n\n    \"\"\"\n    if path.is_dir():\n        logger.info(\"Opening folder %s\", name)\n\n    if path.suffix in (\".exe\", \".lnk\"):\n        logger.info(\"Running app %s\", name)\n    else:\n        logger.info(\"Opening file %s\", name)\n\n    os.startfile(path)\n    time.sleep(delay)\n\n\ndef run_command(\n    command: str,\n    delay: int,\n) -&gt; None:\n    \"\"\"Run a powershell command.\n\n    Args:\n    ----\n        command: Command to run.\n        delay: Time to wait after starting the process.\n\n    \"\"\"\n    _ = subprocess.call(\n        f\"powershell.exe {command}\",\n        shell=False,\n    )\n    time.sleep(delay)"
  },
  {
    "objectID": "posts/startup-script/index.html#the-last-bit-of-convenience",
    "href": "posts/startup-script/index.html#the-last-bit-of-convenience",
    "title": "Python Startup Script",
    "section": "The last bit of convenience",
    "text": "The last bit of convenience\nWe got it, friends, the script works and the job is done. But… do you recall the last time you googled a shortcut for a semi-frequently used functionality? Do you still remember the shortcut, or use it each time you need the functionality? Convenience needs to be convenient (obviously). So let’s make the usage of our script as seamless as possible.\nIn Windows OS the best way for me would be to have a shortcut that would run it with one click. We could pin it to the taskbar and start menu. To create one:\n\nGo to any folder, right-click and select New &gt; Shortcut.\nIn the guide that pops up paste in %systemroot%\\System32\\cmd.exe /c \"python.exe $1\" where $1 should be replaced by the path to your script. You can also replace python.exe with interpreter path of any venv you wish.\nOptionally, you can later change the icon for the shortcut (needs to be .ico file). I like to roll with Win-98 style ‘My Computer’ icon.\nCopy the shortcut to start menu directory. For Win11 it’s C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs. You should be able to see it in start menu already. Now you can pin it to the taskbar.\n\n\nThat’s a good enough reminder and convenience tool for me. You might need some different setup, especially for another OS. For Linux, you might try to leverage activate or bashrc scripts in your working setup."
  },
  {
    "objectID": "posts/startup-script/index.html#further-extensions",
    "href": "posts/startup-script/index.html#further-extensions",
    "title": "Python Startup Script",
    "section": "Further extensions",
    "text": "Further extensions\nThere are a couple more things I wish this guy could do for me still:\n\nChanging Teams status to green - there’s a MS Graph API that could do this but we would need to manage Azure authorizations through the script. I am not up to that, especially on a work account. Might experiment on personal one in the future.\nDisplay placement of opened processes — I have 2 displays (which you could count as 4, due to the size format) and I am very particular about where each app should go. I would love the apps to open where they should. This is however OS specific, for Win it require to mingle with win32api. Yet another project for the future.\n\n\n\n\n\n\n\nNote\n\n\n\nDownload the startup script and example Windows shortcut."
  },
  {
    "objectID": "posts/linux-python-dev-env/index.html",
    "href": "posts/linux-python-dev-env/index.html",
    "title": "Linux Python Dev Env",
    "section": "",
    "text": "Installing Python dev tools on Linux is a bit of a pain, but it doesn’t have to be. This post will show you how to set up a great Python dev environment on Linux using brew, pipx, and poetry.\nbrew install python@3.12 python@3.13\nDev tools should be accessable globally, but should’t be in the defualt global python env. Solution - pipx\nbrew install pipx\npipx ensurepath\npipx install argcomplete --force\nAdd pipix completions to config\nnano  .zshrc\n\nautoload -U compinit && compinit\neval \"$(register-python-argcomplete pipx)\"\n\n\n\n\n\nInstall dev tools\npipx install --force ruff hapless poethepoet poetry pre-commit uv pytest basedpyright\n\n\n\n\n\nnano $(which poetry)\n\n\n\n\n\nShebang Line (#!): #!/home/bwrob/.local/share/pipx/venvs/poetry/bin/python: This line specifies the interpreter used to run the script. In this case, it’s a Python interpreter located in a specific virtual environment (poetry).\nThis script acts as a launcher for the poetry command. It sets up the environment and handles potential script extensions before delegating the actual command execution to the poetry library.\nWe can see that each of the toolos install with pipx is installed in its own venv, but is available globally\nls /home/bwrob/.local/share/pipx/venvs/ -la\n\n\n\n\n\nCopy your\n# Instal dependencies\npoetry install\n# Install pre-commit\npre-commit install --install-hooks --overwrite --allow-missing-config\n# Update pre-commit\npre-commit autoupdate\n# Run pre-commit to test setup\npre-commit run --all-files\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/linux-in-windows/index.html#windows-linux-and-you-ménage-à-trois",
    "href": "posts/linux-in-windows/index.html#windows-linux-and-you-ménage-à-trois",
    "title": "Linux in Windows via WSL",
    "section": "Windows, Linux, and You: Ménage à trois",
    "text": "Windows, Linux, and You: Ménage à trois\nTired of the same old Windows vs. Linux beef among PC superusers? Well, get ready to become a mediator in this feud. I’ll show you how to get the best of both worlds.\n\nPros and cons\nWindows OS has long been the dominant platform for mainstream consumers and businesses. It offers good hardware compatibility, de facto the PC gaming experience and is friendly to the casual user. However, Windows has significant limitations in terms of system control and software development tools.\nLinux, on the other hand, is an operating system created by developers and for developers (and system administrators). It provides infinite flexibility and a deep pool of open-source tools. But the learning curve is steep, the open-source projects often get abandoned and with great power (sudo) comes great responsibility (and sometimes system reinstall).\n\n\n\n\n\n\nNote\n\n\n\nActually, to publish this post in the most convenient and elegant way, I needed to switch to Linux. The Windows quarto CLI fails with some certification errors, coming from deno, that I can’t be bothered to clean up. Discovered this while writing these words as my previous approach was much messier. Irony is the ambrosia of life (for me at least).\n\n\n\n\nBridging the gap\nAt this point even Microsoft — a strong contrarian to Linux in the past — embraced the usefulness of Linux shell at your fingertips. Imagine having the familiar interface of Windows for your everyday tasks. Combine it with a the raw power and controllability of Linux for when you need to dive deep into development or system administration. And limited stakes once you (inevitably) remove half of your file system with a bash script. Enter Windows Subsystem for Linux (WSL): a ticket to 10x-ing your software development on Windows.\n\n\nWSL vs. Virtual Machines: What’s the Difference?\nYou might be wondering how WSL differs from a traditional virtual machine (VM). While both provide a way to run Linux on Windows, they operate in different ways. A VM emulates a virtual computer within your computer, complete with its own operating system and make-belive hardware resources. This makes VMs resource-intensive and can impact overall system performance. They are also hard to set up and maintain.\nWSL, on the other hand, is a more lightweight approach. It integrates Linux directly into the Windows kernel, allowing for faster boot times, better performance, and seamless file sharing between Windows and Linux environments."
  },
  {
    "objectID": "posts/linux-in-windows/index.html#installing-and-setting-up-wsl",
    "href": "posts/linux-in-windows/index.html#installing-and-setting-up-wsl",
    "title": "Linux in Windows via WSL",
    "section": "Installing and setting up WSL",
    "text": "Installing and setting up WSL\nFirst, we need to set up the WSL and install a chosen Linux distribution. Fortunately, this is “super easy, barely an inconvenience”. You can choose from a list of distros pre-packaged by Microsoft or download and build an image from scratch. You can even build Arch and be legally allowed to say BTW, I use Arch (on Windows). For this guide, we’ll take a more conventional approach and opt for the long-term support (LTS) version of Ubuntu. Now, open the Powershell with administrative privileges and run:\nwsl --update\nwsl --version\nThese commands ensure that WSL is up-to-date and displays the installed WSL version.\n\nOur next command will be:\nwsl -l -o\nThis yields a curated list of pre-packaged Linux distributions that Microsoft provides, making the process almost effortless.\n\nFor the installation itself:\nwsl --install -d 'Ubuntu-24.04'\n\nReboot the Windows system and you’ll see `Ubuntu’ among your applications."
  },
  {
    "objectID": "posts/linux-in-windows/index.html#base-setup-new-shell-and-package-manager",
    "href": "posts/linux-in-windows/index.html#base-setup-new-shell-and-package-manager",
    "title": "Linux in Windows via WSL",
    "section": "Base setup — new shell and package manager",
    "text": "Base setup — new shell and package manager\nThere is an additional benefit we can reap with just a bit of more work — a fully system-agnostic setup. By having Linux kernel run on Windows, we unified 2 out of 3 giants. The only pillar that is missing is the Mac OS. But wait, it’s based on Unix as well! It just uses different default shell and lacks a package manager, as Apple doesn’t trust its clients. zsh offers a more interactive and customizable shell experience compared to the default bash. Homebrew, often referred to as the “missing package manager for macOS”, provides a convenient way to install additional software on Linux systems. Let’s change the terminal shell to zsh in our Ubuntu installation and compile a secondary (to apt-get) package manager – brew.\n\nBrewing starts\nBefore we dive into installing Homebrew, we need to equip our system with the essential tools. The build-essential package provides a collection of compilers and libraries necessary for building software from the source code. Git is a version control system used for managing code projects.\nLet’s install these prerequisites using the following command:\nsudo apt-get upgrade -y\nsudo apt-get install build-essential git -y\nExecute the installation script for Homebrew:\nINSTALL_PATH=\"https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh\"\n/bin/bash -c \"$(curl -fsSL $INSTALL_PATH)\"\n\nTo make Homebrew accessible from your shell, you need to load its environment variables. The following command achieves this and subsequently runs a diagnostic check:\neval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"\nbrew doctor\n\nDoctor’s orders to append brew to some set of paths! Let’s do this then:\necho 'export XDG_DATA_DIRS=\"/home/linuxbrew/.linuxbrew/share:$XDG_DATA_DIRS\"' &gt;&gt; ~/.profile"
  },
  {
    "objectID": "posts/linux-in-windows/index.html#z-shell-sea-shell",
    "href": "posts/linux-in-windows/index.html#z-shell-sea-shell",
    "title": "Linux in Windows via WSL",
    "section": "Z-shell — sea-shell",
    "text": "Z-shell — sea-shell\nHomebrew makes package management a breeze. Let’s install zsh, a powerful and customizable shell.\nbrew install zsh\nzsh --version\nzsh\nThis will take you to interactive .zshrc file setup. The file contains commands that are run each time a shell is spawned. You can either generate empty file with 0 or go through the interactive setup with 1. \nAdd the brew initialization to .zshrc file as well. This way brew will always be by your side!\n(echo; echo 'eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"') &gt;&gt; /home/bwrob/.zshrc\nCheck the default shell and set it to zsh:\necho $SHELL\nsudo chsh -s $(which zsh)\necho $SHELL"
  },
  {
    "objectID": "posts/linux-in-windows/index.html#github-command-line-tool",
    "href": "posts/linux-in-windows/index.html#github-command-line-tool",
    "title": "Linux in Windows via WSL",
    "section": "GitHub command line tool",
    "text": "GitHub command line tool\nRemember git != GitHub, we need a way to authenticate and use Github from CLI. There’s a tool for that!\nbrew install gh\ngh auth login\n\nNow create a convenient directory and copy your favourite GitHub repo:\nmkdir repos && cd repos\ngh repo clone python_playground"
  },
  {
    "objectID": "posts/linux-in-windows/index.html#connect-to-visual-studio-code",
    "href": "posts/linux-in-windows/index.html#connect-to-visual-studio-code",
    "title": "Linux in Windows via WSL",
    "section": "Connect to Visual Studio Code",
    "text": "Connect to Visual Studio Code\nWhile WSL grants us the power of Linux, let’s not forget the user-friendly interface of Windows. When it comes to software development, we can achieve the perfect blend by integrating Visual Studio Code (VSC) with our WSL environment.\nHere’s how:\n\nInstall the WSL Extension in VSC: Fire up VSC on your Windows machine and head over to the Extensions tab. Search for “WSL” and install the official extension by Microsoft: WSL extension.\nLaunching VSC from WSL: Within your WSL terminal, you can directly invoke VSC as if it were running natively on Windows. Use the following command:\n\ncode ~\\repos\\python_playground\n\nIn the next post I will show you how to set up Python environment in Linux. Stay tuned :) .\n\n\n\n\n\n\nNote\n\n\n\nDownload the Ubuntu shell script here."
  },
  {
    "objectID": "posts/linux_shell_setup/index.html",
    "href": "posts/linux_shell_setup/index.html",
    "title": "Prettify Dev Terminal Setup",
    "section": "",
    "text": "Oh My Posh is a prompt theme engine for any shell, including Zsh. It allows you to customize your terminal prompt with themes and segments.\nbrew install jandedobbeleer/oh-my-posh/oh-my-posh\necho 'eval \"$(oh-my-posh init zsh)\"' &gt;&gt; .zshrc\necho 'OH_MY_POSH_THEME=\"kali\"' &gt;&gt; .zshrc"
  },
  {
    "objectID": "posts/linux_shell_setup/index.html#oh-my-posh",
    "href": "posts/linux_shell_setup/index.html#oh-my-posh",
    "title": "Prettify Dev Terminal Setup",
    "section": "",
    "text": "Oh My Posh is a prompt theme engine for any shell, including Zsh. It allows you to customize your terminal prompt with themes and segments.\nbrew install jandedobbeleer/oh-my-posh/oh-my-posh\necho 'eval \"$(oh-my-posh init zsh)\"' &gt;&gt; .zshrc\necho 'OH_MY_POSH_THEME=\"kali\"' &gt;&gt; .zshrc"
  },
  {
    "objectID": "posts/linux_shell_setup/index.html#autosuggestions",
    "href": "posts/linux_shell_setup/index.html#autosuggestions",
    "title": "Prettify Dev Terminal Setup",
    "section": "autosuggestions",
    "text": "autosuggestions\nZsh autosuggestions provide command suggestions based on your history and current input, enhancing your command line experience.\nbrew install zsh-autosuggestions\n# To activate the autosuggestions, add the following at the end of your .zshrc:\nsource $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
  },
  {
    "objectID": "posts/linux_shell_setup/index.html#aliases",
    "href": "posts/linux_shell_setup/index.html#aliases",
    "title": "Prettify Dev Terminal Setup",
    "section": "Aliases",
    "text": "Aliases\nCreate a file ~/.bash_aliases and add your aliases there, or directly in .zshrc.\n# Alias definitions.\n# You may want to put all your additions into a separate file like\n# ~/.bash_aliases, instead of adding them here directly.\n# See /usr/share/doc/bash-doc/examples in the bash-doc package.\n\nif [ -f ~/.bash_aliases ]; then\n    . ~/.bash_aliases\nfi\n\nalias zshconfig='nano ~/.zshrc'\nalias ls='eza -la --group-directories-first --icons'"
  },
  {
    "objectID": "posts/linux_shell_setup/index.html#minor-packages",
    "href": "posts/linux_shell_setup/index.html#minor-packages",
    "title": "Prettify Dev Terminal Setup",
    "section": "Minor packages",
    "text": "Minor packages\n\nfzf\nFuzzy finder for command line, useful for searching files, history, etc.\nbrew install fzf\n# Set up fzf key bindings and fuzzy completion\necho 'source &lt;(fzf --zsh)' &gt;&gt; .zshrc\n\n\neza\nBetter alternative to ls with icons and better defaults.\nbrew install eza\necho 'alias ls='eza -la --group-directories-first --icons'' &gt;&gt; .zshrc\n\n\nthefuck\nA tool to correct mistyped commands in the terminal.\nbrew install thefuck\necho 'eval $(thefuck --alias)' &gt;&gt; .zshrc\n\n\ntmux\nA terminal multiplexer that allows you to manage multiple terminal sessions from a single window.\nbrew install tmux\necho 'alias tmux=\"tmux -2\"' &gt;&gt; .zshrc\n\n\nfastfetch\nA tool to display system information in the terminal, similar to neofetch but faster.\nbrew install fastfetch\necho 'alias ff=\"fastfetch\"' &gt;&gt; .zshrc\necho 'ff' &gt;&gt; .zshrc"
  },
  {
    "objectID": "posts/mathematician-in-finance/index.html#summary",
    "href": "posts/mathematician-in-finance/index.html#summary",
    "title": "Mathematician in the financial markets (PL)",
    "section": "Summary",
    "text": "Summary\nThis post accompanies a lecture I delivered at the University of Wroclaw on career planning for mathematicians. It explores the skills, roles, and opportunities in the financial industry, highlighting how mathematical expertise can be applied to areas like risk management, quantitative analysis, and algorithmic trading."
  },
  {
    "objectID": "posts/mathematician-in-finance/index.html#rynki-finansowe",
    "href": "posts/mathematician-in-finance/index.html#rynki-finansowe",
    "title": "Mathematician in the financial markets (PL)",
    "section": "Rynki Finansowe",
    "text": "Rynki Finansowe\nRynki finansowe to złożone ekosystemy, w których handluje się aktywami, takimi jak akcje, obligacje i instrumenty pochodne. Rynki te ułatwiają przepływ kapitału między inwestorami a przedsiębiorstwami, napędzając wzrost gospodarczy. Pozwalają takze na transfer już istniejącego ryzyka finansowego.\nCharakteryzują się:\n\nCiągłymi zmianami i zmiennością.\nOgromnymi wolumenami danych.\nWzajemnymi powiązaniami globalnych gospodarek.\nPotrzebą precyzyjnej wyceny i oceny ryzyka.\n\nGłówne postaci na parkietach rynkiowych:\n\nSpekulant:\n\nCel: Zysk z przewidywania zmian cen.\nDziałanie: Kupno/sprzedaż z ryzykiem.\nZnaczenie: Płynność, zmienność.\n\nArbitrażysta:\n\nCel: Zysk bez ryzyka z różnic cen.\nDziałanie: Szybkie transakcje wykorzystujące niespójności.\nZnaczenie: Efektywność rynków.\n\nHedger:\n\nCel: Zmniejszenie ryzyka.\nDziałanie: Zabezpieczanie się instrumentami finansowymi.\nZnaczenie: Stabilność rynków.\n\nPośrednik:\n\nCel: Ułatwienie transakcji.\nDziałanie: Łączenie kupujących i sprzedających.\nZnaczenie: Płynność, dostęp do rynków."
  },
  {
    "objectID": "posts/mathematician-in-finance/index.html#rola-matematyków",
    "href": "posts/mathematician-in-finance/index.html#rola-matematyków",
    "title": "Mathematician in the financial markets (PL)",
    "section": "Rola Matematyków",
    "text": "Rola Matematyków\n\nModelowanie niepewności:\n\nRynki finansowe charakteryzują się inherentną niepewnością.\nMatematycy wykorzystują zaawansowane narzędzia rachunku prawdopodobieństwa i statystyki do modelowania oraz kwantyfikacji tej niepewności, co umożliwia efektywne zarządzanie ryzykiem.\n\nPrecyzyjna wycena instrumentów finansowych:\n\nWycena instrumentów finansowych, w szczególności instrumentów pochodnych, wymaga stosowania złożonych modeli matematycznych.\nRachunek stochastyczny, równania różniczkowe cząstkowe oraz metody numeryczne stanowią fundamentalne narzędzia w tym procesie.\n\nZarządzanie ryzykiem finansowym:\n\nMatematycy opracowują zaawansowane modele służące do pomiaru i zarządzania różnorodnymi rodzajami ryzyka finansowego, w tym ryzykiem rynkowym, kredytowym oraz operacyjnym.\nZapewnia to stabilność i odporność instytucji finansowych na potencjalne wstrząsy.\n\nHandel algorytmiczny:\n\nHandel wysokiej częstotliwości oraz inne strategie algorytmiczne opierają się na optymalizacji matematycznej i analizie statystycznej w celu identyfikacji i wykorzystania możliwości rynkowych.\n\nAnaliza danych finansowych:\n\nAnaliza i interpretacja ogromnych zbiorów danych finansowych wymaga zastosowania zaawansowanych technik matematycznych i statystycznych.\nMatematycy posiadają kompetencje w zakresie ekstrakcji istotnych informacji ze złożonych zbiorów danych.\n\nOptymalizacja portfela inwestycyjnego:\n\nOptymalizacja portfela inwestycyjnego oraz inne problemy finansowe wymagają znalezienia optymalnych rozwiązań przy uwzględnieniu określonych ograniczeń.\nTechniki optymalizacji matematycznej mają kluczowe znaczenie w osiąganiu pożądanych wyników.\n\nZgodność z regulacjami prawnymi:\n\nPrzepisy regulujące sektor finansowy wymagają rygorystycznej analizy ilościowej oraz walidacji modeli.\nMatematycy odgrywają istotną rolę w zapewnieniu zgodności instytucji finansowych z obowiązującymi regulacjami. zgodności z tymi przepisami."
  },
  {
    "objectID": "posts/mathematician-in-finance/index.html#rodzaje-analityków-ilościowych",
    "href": "posts/mathematician-in-finance/index.html#rodzaje-analityków-ilościowych",
    "title": "Mathematician in the financial markets (PL)",
    "section": "Rodzaje analityków ilościowych",
    "text": "Rodzaje analityków ilościowych\n\n\nFront Office QuantMarket Risk QuantCredit Risk QuantValidation QuantQuant ResearcherAlgorithmic TraderQuant Developer\n\n\nOpracowuje i stosuje modele ilościowe do wyceny, zarządzania ryzykiem i strategii handlowych w dziale transakcyjnym instytucji finansowej.\n        \n        \n        \n                            \n                                            \n\n\nOpracowuje i waliduje modele do pomiaru i zarządzania ryzykiem rynkowym, zapewniając zgodność z wymogami regulacyjnymi.\n                            \n                                            \n\n\nOpracowuje i waliduje modele do pomiaru i zarządzania ryzykiem kredytowym, oceniając prawdopodobieństwo niewypłacalności pożyczkobiorcy.\n                            \n                                            \n\n\nNiezależnie ocenia i waliduje modele finansowe opracowane przez innych kwantów, zapewniając ich dokładność i solidność.\n                            \n                                            \n\n\nProwadzi nowatorskie badania w dziedzinie finansów ilościowych, opracowując nowe modele i techniki handlu, zarządzania ryzykiem i wyceny aktywów.\n                            \n                                            \n\n\nOpracowuje i wdraża zautomatyzowane strategie handlowe przy użyciu modeli ilościowych i algorytmów, często koncentrując się na handlu wysokiej częstotliwości.\n                            \n                                            \n\n\nProjektuje i wdraża rozwiązania programowe dla systemów handlu ilościowego, platform zarządzania ryzykiem i narzędzi modelowania finansowego."
  },
  {
    "objectID": "posts/mathematician-in-finance/index.html#codzienne-doświadczenia-quanta",
    "href": "posts/mathematician-in-finance/index.html#codzienne-doświadczenia-quanta",
    "title": "Mathematician in the financial markets (PL)",
    "section": "Codzienne Doświadczenia Quanta",
    "text": "Codzienne Doświadczenia Quanta\nŻycie analityka ilościowego wykracza daleko poza samo przetwarzanie liczb. To różnorodne połączenie wiedzy technicznej i umiejętności interpersonalnych.\n\nRozwój i Testowanie Modeli:\n\nZnaczną część dnia poświęca się na rozwój, udoskonalanie lub testowanie modeli ilościowych.\nObejmuje to kodowanie, analizę statystyczną i rygorystyczne testowanie, co wymaga silnych umiejętności rozwiązywania problemów i myślenia analitycznego.\n\nWspółpraca i Komunikacja:\n\nQuanci ściśle współpracują z traderami, menedżerami ryzyka i programistami.\nWyjaśnianie złożonych modeli i wyników nietechnicznym współpracownikom jest kluczowe, co podkreśla znaczenie jasnej komunikacji.\nPraca w zespołach wymaga doskonałych umiejętności współpracy.\n\nRozwiązywanie Problemów pod Presją:\n\nRynki finansowe mogą być niestabilne, co wymaga od kwantów szybkiego dostosowywania się do zmieniających się warunków.\nWymaga to zdolności adaptacji i umiejętności zachowania spokoju pod presją.\nPoziom presji znacznie różni się w zależności od stanowiska.\n\nCiągłe Uczenie się:\n\nDziedzina finansów ilościowych stale się rozwija, co wymaga od kwantów bycia na bieżąco z nowymi technikami i technologiami.\nZaangażowanie w całożyciowe uczenie się jest niezbędne, co może sprawić, że praca jest ciekawa.\n\nBycie na bieżąco\n\nNiektóre profesje wymagają stałej znajomości przeglądu danych rynkowych, wiadomości i raportów, aby być na bieżąco z globalnymi trendami finansowymi.\nWymaga to dbałości o szczegóły i umiejętności szybkiego przyswajania złożonych informacji.\n\nZgodność z Regulacjami:\n\nWielu quantów spędza czas na upewnianiu się, że modele i procesy są zgodne z obowiązującymi przepisami. Wymaga to dużej dbałości o szczegóły i umiejętności rozumienia złożonych dokumentów."
  },
  {
    "objectID": "posts/mathematician-in-finance/index.html#potencjali-pracodawcy",
    "href": "posts/mathematician-in-finance/index.html#potencjali-pracodawcy",
    "title": "Mathematician in the financial markets (PL)",
    "section": "Potencjali pracodawcy",
    "text": "Potencjali pracodawcy\n\nWrocławPolska\n\n\n\nAllianz Deutchland (ubezpieczenia)\nBNY Mellon\nEY (konsulting)\nQube RT\nSantander\nUBS\n\n\n\n\nCiti\nCommerzbank\nGoldman Sachs\nHSBC\nmBank\nNatwest\nPoint 72\nRevolut\nStandard Chartered"
  },
  {
    "objectID": "posts/mathematician-in-finance/index.html#przegląd-mojej-edukacji-i-kariery",
    "href": "posts/mathematician-in-finance/index.html#przegląd-mojej-edukacji-i-kariery",
    "title": "Mathematician in the financial markets (PL)",
    "section": "Przegląd mojej edukacji i kariery",
    "text": "Przegląd mojej edukacji i kariery\nResume"
  },
  {
    "objectID": "posts/mathematician-in-finance/index.html#materiały",
    "href": "posts/mathematician-in-finance/index.html#materiały",
    "title": "Mathematician in the financial markets (PL)",
    "section": "Materiały",
    "text": "Materiały\n\nKsiążki popularne\n\nThe Quants: How a New Breed of Math Whizzes Conquered Wall Street and Nearly Destroyed It – Scott Patterson\nA Random Walk Down Wall Street: The Time-Tested Strategy for Successful Investing – Burton G. Malkiel\nThe Money Formula: Dodgy Finance, Pseudo Science, and How Mathematicians Took Over the Markets – Paul Wilmott, David Orrell\n\n\n\nBiografie\n\nA Man for All Markets: From Las Vegas to Wall Street, How I Beat the Dealer and the Market – Edward O. Thorp\nThe Man Who Solved the Market: How Jim Simons Launched the Quant Revolution – Gregory Zuckerman\nMy Life as a Quant: Reflections on Physics and Finance – Emanuel Derman\n\n\n\nPodstawy matematyki finansowej/finansów ilościowych\n\nFinancial Calculus: An Introduction to Derivative Pricing – Martin Baxter, Andrew Rennie\nPaul Wilmott Introduces Quantitative Finance – Paul Wilmott\nStochastic Calculus for Finance I: The Binomial Asset Pricing Model – Steven Shreve\nMathematical Modeling and Computation in Finance: With Exercises and Python and MATLAB Computer Codes – Cornelis W Oosterlee & Lech A Grzelak\n\n\n\nPrzygotowanie do rozmów rekrutacyjnych\n\nFrequently Asked Questions in Quantitative Finance – Paul Wilmott\nQuant Job Interview Questions and Answers - Mark Joshi\n150 Most Frequently Asked Questions on Quant Interviews – Dan Stefanica, Radoš Radoičić, Tai-Ho Wang\n\n\n\nYouTube\n\nComputations in Finance\nDimitri Bianco"
  },
  {
    "objectID": "posts/exit-stack/index.html",
    "href": "posts/exit-stack/index.html",
    "title": "Exit stack to the rescue",
    "section": "",
    "text": "As a quantitative finance professional you’ll often find yourself with risk management systems (RMS). RMS’s are extensive frameworks that let you properly define a book (portfolio) of your financial transactions and run varia of pricing and risk analysis on it. For big financial players, like investment banks, the RMS will be internal proprietary codbase that is run in-house. For smaller enterprises or second-line reporting it’s not feasable to tackle creating such vast infrastructure. Hence, where there’s a need, someone will try to make money on it. This leads us to third-party (or vendor) RMS, of which there are plenty (ex. Murex, Acadia).\nWorking with vendor RMS, especially one that covers computations for you, entails juggling multiple resources to obtain your risk metrics. Defining OTC products, benchmarks, portfolios, and running risk analysis can involve numerous API calls, each requiring proper setup and cleanup. This can lead to messy code and potential errors or performance bottlenecks if resources aren’t handled correctly.\nThankfully, Python provides a powerful concept called context managers (CM) that streamline resource managment. True to the language’s ‘batteries included’ philosophy, there’s also a contextlib library that contains variety of tools for easing up your work with CMs. Today we’ll look at a (mock-up) usage of ExitStack class in real-life scenario of running risk analysis on RMS. If you need a refresher on CMs, check out this tutorial by RealPython."
  },
  {
    "objectID": "posts/exit-stack/index.html#working-with-risk-managment-systems",
    "href": "posts/exit-stack/index.html#working-with-risk-managment-systems",
    "title": "Exit stack to the rescue",
    "section": "",
    "text": "As a quantitative finance professional you’ll often find yourself with risk management systems (RMS). RMS’s are extensive frameworks that let you properly define a book (portfolio) of your financial transactions and run varia of pricing and risk analysis on it. For big financial players, like investment banks, the RMS will be internal proprietary codbase that is run in-house. For smaller enterprises or second-line reporting it’s not feasable to tackle creating such vast infrastructure. Hence, where there’s a need, someone will try to make money on it. This leads us to third-party (or vendor) RMS, of which there are plenty (ex. Murex, Acadia).\nWorking with vendor RMS, especially one that covers computations for you, entails juggling multiple resources to obtain your risk metrics. Defining OTC products, benchmarks, portfolios, and running risk analysis can involve numerous API calls, each requiring proper setup and cleanup. This can lead to messy code and potential errors or performance bottlenecks if resources aren’t handled correctly.\nThankfully, Python provides a powerful concept called context managers (CM) that streamline resource managment. True to the language’s ‘batteries included’ philosophy, there’s also a contextlib library that contains variety of tools for easing up your work with CMs. Today we’ll look at a (mock-up) usage of ExitStack class in real-life scenario of running risk analysis on RMS. If you need a refresher on CMs, check out this tutorial by RealPython."
  },
  {
    "objectID": "posts/exit-stack/index.html#setting-the-stage",
    "href": "posts/exit-stack/index.html#setting-the-stage",
    "title": "Exit stack to the rescue",
    "section": "Setting the stage",
    "text": "Setting the stage\nTo run an analysis, the RMS first needs to know what our positions are. In case of tradable assets it’s simple — we provide a market identifier and how much of the instrument we are holding. What do we do if we have some bespoke agreement with specific counterparty (an over-the-counter transaction)? We will need to define it from scratch in the RMS using data from the term sheet (assuming this kind of agreement is covered).\nNext, we need to specify the risk metrics we want to calculate — define the analysis scope. Let’s say we hold some equity options and we are intertested in their deltas and beta exposures. The betas are defined with respect to some benchmark — ex. portfolio holding 1 stock in US500 ETF. So we define the benchmark and link it to our analysis.\nFinally — once portfolio and analysis are defined in RMS — we call the API to start the calculation and respond with results. This is the control flow we execute to get to this point:\n\n\n\n\n\nflowchart LR\n  A[OTC Products] --&gt; B[Portfolio]\n  B --&gt; C{Analysis Run}\n  D[Benchmarks] --&gt; E[Analysis Definition]\n  E --&gt; C\n  C --&gt; F(Results)\n\n\n\n\n\n\nIf we know we’re never going to use all of the resources, we should clean up the server artifacts after receving the results. So for each resource we should have a CM.\n\nMock functions\nThe setup described above comes from a real-life situation I worked through. I can’t show you the actual API usage or data (or even the name of RMS itself), so we need to define some mocker functions. Mocks like this are actually not an uncommon thing — such approach is prevalent in testing API client code. In our case it would look like this:\n\nfrom enum import StrEnum\nfrom uuid import uuid4\n\n\nclass MockObject(StrEnum):\n    \"\"\"Types of mock objects.\"\"\"\n\n    ANALYSIS = \"analysis\"\n    BENCHMARK = \"benchmark\"\n    OTC_PRODUCTS = \"otc_products\"\n    PORTFOLIO = \"portfolio\"\n\n\ndef mock_object(object_type: MockObject) -&gt; str:\n    \"\"\"Mock a UUID for a given object type.\n\n    Args:\n        object_type: Type of object.\n    \"\"\"\n    return f\"{object_type}_{uuid4()}\"\n\n\ndef mock_preparation(object_type: MockObject, **kwargs) -&gt; None:\n    \"\"\"Mock preparation of an object.\n\n    Args:\n        object_type: Type of object.\n    \"\"\"\n    print(f\"Preparing {object_type}\" + (f\" using {kwargs}\" if kwargs else \".\"))\n\n\ndef mock_clean_up(object_uuid: str) -&gt; None:\n    \"\"\"Mock clean up of an object.\n\n    Args:\n        object_uuid: Uuid of the object.\n    \"\"\"\n    print(f\"Cleaning up after {object_uuid}.\")\n\nFor each of the four types of resources we mock the preparation, object (ex. API response, some id of definition on server) and the clean up process.\n\n\nContext managers\nEasiest way to define a CM is through contextlib.contextmanager decorator. To use it, you need a function that returns a generator. Code executed on enter should come before yield statement and the one for the exit afterwards. The generator yields the result of the CM (ex. handle to an opened file), the y in with x(*args) as y:.\n\nfrom contextlib import contextmanager\nfrom typing import Generator\n\n@contextmanager\ndef analysis(\n    *,\n    benchmark_uuid: str,\n) -&gt; Generator[str, None, None]:\n    \"\"\"Mock definition of an analysis.\n\n    Example: equity delta and correlation with benchmark.\n\n    Args:\n        benchmark_uuid: Uuid of the benchmark.\n    \"\"\"\n    mock_preparation(\n        MockObject.ANALYSIS,\n        benchmark_name=benchmark_uuid,\n    )\n    analysis_uuid = mock_object(MockObject.ANALYSIS)\n    yield analysis_uuid\n    mock_clean_up(analysis_uuid)\n\nModern approach to Python development leans heavily towards type annotations. Dynamical typing is powerful but can lead to unwieldy code. To properly annotate the analysis function we need to import Generator from typing module. Remember, the @contextmanager decorator takes the function and turns it into CM — a class with __enter__ and __exit__ methods. The Generator needs three inputs but in our case only the first one is important — YieldType, here str (see for more).\nWith this done implementing the 3 remaining CMs is easy, just remember our flow chart.\n\n@contextmanager\ndef benchmark() -&gt; Generator[str, None, None]:\n    \"\"\"Mock definition of a benchmark.\n\n    Args:\n        otc_products_uuid: Uuid of the otc products.\n    \"\"\"\n    mock_preparation(\n        MockObject.BENCHMARK,\n    )\n    benchmark_uuid = mock_object(MockObject.BENCHMARK)\n    yield benchmark_uuid\n    mock_clean_up(benchmark_uuid)\n\n\n@contextmanager\ndef otc_products() -&gt; Generator[str, None, None]:\n    \"\"\"Mock definition of an otc products.\n\n    Args:\n        otc_products_uuid: Uuid of the otc products.\n    \"\"\"\n    mock_preparation(MockObject.OTC_PRODUCTS)\n    otcs_uuid = mock_object(MockObject.OTC_PRODUCTS)\n    yield otcs_uuid\n    mock_clean_up(otcs_uuid)\n\n\n@contextmanager\ndef portfolio(\n    *,\n    portfolio_name: str,\n    otc_products_uuid: str,\n) -&gt; Generator[str, None, None]:\n    \"\"\"Mock definition of a portfolio.\n\n    Args:\n        otc_products_uuid: Uuid of the otc products.\n    \"\"\"\n    mock_preparation(\n        MockObject.PORTFOLIO,\n        portfolio_name=portfolio_name,\n        otc_products_uuid=otc_products_uuid,\n    )\n    portfolio_uuid = mock_object(MockObject.PORTFOLIO)\n    yield portfolio_uuid\n    mock_clean_up(portfolio_uuid)\n\n\n\nAnalysis results\nNo stress or complexity here, to run the analysis we need to specify which analysis to run on which portfolio.\n\nimport pandas as pd\n\ndef analysis_results(\n    *,\n    analysis_uuid: str,\n    portfolio_uuid: str,\n) -&gt; pd.DataFrame:\n    \"\"\"Mock running the analysis on a given portfolio.\n\n    Returns empty dataframe.\n\n    Args:\n        analysis_uuid: Uuid of the analysis.\n        portfolio_uuid: Uuid of the portfolio.\n    \"\"\"\n    print(f\"Running analysis {analysis_uuid} on portfolio {portfolio_uuid}.\")\n    return pd.DataFrame()"
  },
  {
    "objectID": "posts/exit-stack/index.html#section",
    "href": "posts/exit-stack/index.html#section",
    "title": "Exit stack to the rescue",
    "section": "",
    "text": "Finally, we can run some (mock) risk analysis!\n\nUsing contexts directly\nFirst, we use the managers directly through with clause, remembering the dependencies from our flow chart.\n\nPORTFOLIO = \"portfolio_1\"\n\ndef run_analysis() -&gt; pd.DataFrame:\n    \"\"\"Mock running the analysis using with clauses.\"\"\"\n    with otc_products() as otc_uuid:\n        with benchmark() as benchmark_uuid:\n            with portfolio(\n                portfolio_name=PORTFOLIO,\n                otc_products_uuid=otc_uuid,\n            ) as portfolio_uuid:\n                with analysis(\n                    benchmark_uuid=benchmark_uuid,\n                ) as analysis_uuid:\n                    results = analysis_results(\n                        analysis_uuid=analysis_uuid,\n                        portfolio_uuid=portfolio_uuid,\n                    )\n    return results\n\nThis is terrible! I am already getting lost, needed few tries to get it right. We ended up with 6 levels of indentation, the code is confusing, the flow is obtuse. Let’s run it either way, to see if at least works.\n\ndef print_title(title: str) -&gt; None:\n    \"\"\"Print a title padded, surrounded by dashes and empty lines.\"\"\"\n    print(\"\\n\" + title.center(60, \"-\") + \"\\n\")\n\nprint_title(\"Running analysis.\")\nrun_analysis()\n\n\n---------------------Running analysis.----------------------\n\nPreparing otc_products.\nPreparing benchmark.\nPreparing portfolio using {'portfolio_name': 'portfolio_1', 'otc_products_uuid': 'otc_products_d92080bf-a618-45ca-b745-5f210c271e01'}\nPreparing analysis using {'benchmark_name': 'benchmark_b84b80ba-f955-484e-baa0-245dd2e37971'}\nRunning analysis analysis_08cea7f1-86fc-4c06-9497-0206ee22a48f on portfolio portfolio_28c398e6-0bed-400b-8058-ec1084897178.\nCleaning up after analysis_08cea7f1-86fc-4c06-9497-0206ee22a48f.\nCleaning up after portfolio_28c398e6-0bed-400b-8058-ec1084897178.\nCleaning up after benchmark_b84b80ba-f955-484e-baa0-245dd2e37971.\nCleaning up after otc_products_d92080bf-a618-45ca-b745-5f210c271e01.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGreat, the behaviour is as expected, everything is cleaned after nicely. We achieved the goal but the code is unmaintainable. Looks like a subject of the joke “good code makes your job safe for a day, but terrible code in production makes it safe for a lifetime”. Being reckless and with no regard to job security as we are, we’ll fix it.\nI can clearly recall the most unamanagable and unreadable code I’ve seen in my career and the culprit was fired in the end. Different reasons, long time later, but still. So the joke is just a joke, don’t rely on a bad code as your job insurance."
  },
  {
    "objectID": "posts/exit-stack/index.html#the-exitstack",
    "href": "posts/exit-stack/index.html#the-exitstack",
    "title": "Exit stack to the rescue",
    "section": "The ExitStack",
    "text": "The ExitStack\nHere comes in the MVP — ExitStack from contextlib, made for streamlining complex context managment situationships. Conceptually it’s just a First-In-Last-Out (FILO) stack. You put CMs on top, one by one. When CM is pushed to stack, its __enter__ method is called and you can intercept the result. ExitStack is a CM itself, it’s __exit__ method is just calling the exits of CMs in reverse order.\n\n\n\n\n\nflowchart LR\n    A(Enter CM A) ---&gt; B(Enter CM B)\n    B ---&gt; C(Enter CM C)\n    C ---&gt; D[Do stuff]\n    D ---&gt; E(Exit CM C)\n    E ---&gt; F(Exit CM B)\n    F ---&gt; G(Exit CM A)\n    A -.- G\n    B -.- F\n    C -.- E\n\n\n\n\n\n\n\nSo the flow is exactly the same as in our first attempt. Let’s try it!\n\nfrom contextlib import ExitStack\n\ndef run_analysis_with_exit_stack() -&gt; None:\n    \"\"\"Mock running the analysis using exit stack.\"\"\"\n    with ExitStack() as stack:\n        otc_uuid = stack.enter_context(otc_products())\n        benchmark_uuid = stack.enter_context(benchmark())\n        portfolio_uuid = stack.enter_context(\n            portfolio(\n                portfolio_name=PORTFOLIO,\n                otc_products_uuid=otc_uuid,\n            )\n        )\n        analysis_uuid = stack.enter_context(\n            analysis(\n                benchmark_uuid=benchmark_uuid,\n            )\n        )\n        results = analysis_results(\n            analysis_uuid=analysis_uuid,\n            portfolio_uuid=portfolio_uuid,\n        )\n\nThat’s amazing (if the approach works)! In our code we end up with only single with clause and the outputs of CMs are defined just like the regular variables. We just need to wrap the CM calls in stack.enter_context method that pushes each CM to the stack.\n\nprint_title(\"Running analysis with exit stack.\")\nrun_analysis_with_exit_stack()\n\n\n-------------Running analysis with exit stack.--------------\n\nPreparing otc_products.\nPreparing benchmark.\nPreparing portfolio using {'portfolio_name': 'portfolio_1', 'otc_products_uuid': 'otc_products_5335b37e-da8b-4e0f-93b8-d22182c20f84'}\nPreparing analysis using {'benchmark_name': 'benchmark_a5f91a53-e401-4e49-9a3a-d2e494f6a79d'}\nRunning analysis analysis_3492a174-58a4-40fd-b45d-6dc429f4578c on portfolio portfolio_534cfbff-0ab6-404d-9c9b-dca42b04e1c0.\nCleaning up after analysis_3492a174-58a4-40fd-b45d-6dc429f4578c.\nCleaning up after portfolio_534cfbff-0ab6-404d-9c9b-dca42b04e1c0.\nCleaning up after benchmark_a5f91a53-e401-4e49-9a3a-d2e494f6a79d.\nCleaning up after otc_products_5335b37e-da8b-4e0f-93b8-d22182c20f84.\n\n\nIt works as well! We also get a package of benefits for free.\n\nDisabling the clean up\nWorking with API is tricky and debugging could be a painful experience. If we notice something iffy with the results we are reciving, it could be due to a bug at any of the stages. In such case disabling the artifact clean up and examining them is a good way to investigate. How do we do that? Comment out the exit code in our resource CMs? Nope, now we know better. With exit stack approach we just need to clean up the stack before exiting its context.\n\ndef run_analysis_with_exit_stack(\n    clean_up: bool = True,\n) -&gt; None:\n    \"\"\"Mock running the analysis using exit stack.\n\n    Args:\n        clean_up: Whether to clean up after the objects.\n    \"\"\"\n\n    with ExitStack() as stack:\n        otc_uuid = stack.enter_context(otc_products())\n        benchmark_uuid = stack.enter_context(benchmark())\n        portfolio_uuid = stack.enter_context(\n            portfolio(\n                portfolio_name=PORTFOLIO,\n                otc_products_uuid=otc_uuid,\n            )\n        )\n        analysis_uuid = stack.enter_context(\n            analysis(\n                benchmark_uuid=benchmark_uuid,\n            )\n        )\n        results = analysis_results(\n            analysis_uuid=analysis_uuid,\n            portfolio_uuid=portfolio_uuid,\n        )\n\n        if not clean_up:\n            _ = stack.pop_all()\n    return results\n\nThe _ = some_function() is a Pythonic way of disregarding outputs of some_function. Method pop_all actually moves the stack contents to a new stack, but we don’t care about that. We just want to get rid of them from our current one.\n\nprint_title(\"Running analysis with exit stack and no clean up.\")\nrun_analysis_with_exit_stack(clean_up=False)\n\n\n-----Running analysis with exit stack and no clean up.------\n\nPreparing otc_products.\nPreparing benchmark.\nPreparing portfolio using {'portfolio_name': 'portfolio_1', 'otc_products_uuid': 'otc_products_0b8ce854-0956-46cd-9477-f2db6c075630'}\nPreparing analysis using {'benchmark_name': 'benchmark_117998ba-9372-41df-8390-5f475e87ef15'}\nRunning analysis analysis_bdee8015-85f9-49ea-842a-6d19e2264c8e on portfolio portfolio_eff325dd-e5e2-48e9-a754-8fc061babe3d.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMultiple portfolios\nBenefit #2 — what do we do if we have multiple managers and many portfolios to re-run for? Or — outside of the example scope — we want to held multiple files open at the same time? Easy, we just push to the stack in a loop or a list comprehension.\n\nPORTFOLIOS = [\"portfolio_1\", \"portfolio_2\", \"portfolio_3\"]\n\ndef run_analysis_with_exit_stack(clean_up: bool = True):\n    \"\"\"Mock running the analysis for multiple portfolios using exit stack.\n\n    Args:\n        clean_up: Whether to clean up after the objects.\n    \"\"\"\n    with ExitStack() as stack:\n        otc_uuid = stack.enter_context(otc_products())\n        benchmark_uuid = stack.enter_context(benchmark())\n        portfolio_uuids = [\n            stack.enter_context(\n                portfolio(\n                    portfolio_name=portfolio_name,\n                    otc_products_uuid=otc_uuid,\n                )\n            )\n            for portfolio_name in PORTFOLIOS\n        ]\n        analysis_uuid = stack.enter_context(\n            analysis(\n                benchmark_uuid=benchmark_uuid,\n            )\n        )\n        result_parts = [\n            analysis_results(\n                analysis_uuid=analysis_uuid,\n                portfolio_uuid=portfolio_uuid,\n            )\n            for portfolio_uuid in portfolio_uuids\n        ]\n        results = pd.concat(result_parts)\n\n        if not clean_up:\n            _ = stack.pop_all()\n    return results\n\nprint_title(\"Running analysis with exit stack on multiple portfolios.\")\nrun_analysis_with_exit_stack(clean_up=True)\n\n\n--Running analysis with exit stack on multiple portfolios.--\n\nPreparing otc_products.\nPreparing benchmark.\nPreparing portfolio using {'portfolio_name': 'portfolio_1', 'otc_products_uuid': 'otc_products_56f2a75e-89cf-4239-9d8d-7fb6a13c6ba9'}\nPreparing portfolio using {'portfolio_name': 'portfolio_2', 'otc_products_uuid': 'otc_products_56f2a75e-89cf-4239-9d8d-7fb6a13c6ba9'}\nPreparing portfolio using {'portfolio_name': 'portfolio_3', 'otc_products_uuid': 'otc_products_56f2a75e-89cf-4239-9d8d-7fb6a13c6ba9'}\nPreparing analysis using {'benchmark_name': 'benchmark_cd693212-f28d-4321-83ad-7ea03f379a70'}\nRunning analysis analysis_cf52685a-a719-4208-b997-4229473d1981 on portfolio portfolio_47d63955-2d58-4919-ad10-f10eab83e790.\nRunning analysis analysis_cf52685a-a719-4208-b997-4229473d1981 on portfolio portfolio_2c28da60-7756-4741-95e1-e834e5f7994f.\nRunning analysis analysis_cf52685a-a719-4208-b997-4229473d1981 on portfolio portfolio_fdba5faf-5b18-4e9e-9ad7-a090e0f68606.\nCleaning up after analysis_cf52685a-a719-4208-b997-4229473d1981.\nCleaning up after portfolio_fdba5faf-5b18-4e9e-9ad7-a090e0f68606.\nCleaning up after portfolio_2c28da60-7756-4741-95e1-e834e5f7994f.\nCleaning up after portfolio_47d63955-2d58-4919-ad10-f10eab83e790.\nCleaning up after benchmark_cd693212-f28d-4321-83ad-7ea03f379a70.\nCleaning up after otc_products_56f2a75e-89cf-4239-9d8d-7fb6a13c6ba9."
  },
  {
    "objectID": "posts/exit-stack/index.html#conclusion",
    "href": "posts/exit-stack/index.html#conclusion",
    "title": "Exit stack to the rescue",
    "section": "Conclusion",
    "text": "Conclusion\nToday we’ve learnt a new Python tool and seen an example of how quantitative developer might set up risk reporting job on vendor RMS. Sound like a very niche and unlikely situation for you? Maybe. But the moral here is to go and explore the Python standard library. Without using any additional packages we improved readability and flexibility of our initial attempt. Python really has ‘batteries included’, see for yourself!\n\n\n\n\n\n\nNote\n\n\n\nDownload the whole code here."
  },
  {
    "objectID": "posts/strategy-pattern-integration/index.html",
    "href": "posts/strategy-pattern-integration/index.html",
    "title": "Strategies for Numerical Integration",
    "section": "",
    "text": "Calculation of many financial methods or metrics relies on a mathematical tool called numerical integration. In simple terms, numerical integration takes a function that represents a continuous process (like the changing value of an investment over time) and approximates the area under its curve. This area can then be used to calculate important quantities, like the total return of the investment or price of a derivative instrument.\nSo we are tasked with a problem, and one that has many different ways of solving, or rather approximating the solution. You most likely (taking into account you’re still reading this) encountered rectangle rule, or Riemann summation in your Calculus 101 course/self-learning. But there are many other techniques, which we call schemes.\nFor quantitative analysts, the choice of the integration method matters. Different integration schemes offer varying levels of accuracy and efficiency. Unfortunately there’s no best technique. Same algorithm can be a perfect fit for problems with certain characteristics, but unusable for others. And then there is the old as time performance vs. accuracy trade-off.\nAs programmers working in finance, we need to be adaptable and leverage solutions that allow us to switch between these methods seamlessly."
  },
  {
    "objectID": "posts/strategy-pattern-integration/index.html#numerical-integration",
    "href": "posts/strategy-pattern-integration/index.html#numerical-integration",
    "title": "Strategies for Numerical Integration",
    "section": "",
    "text": "Calculation of many financial methods or metrics relies on a mathematical tool called numerical integration. In simple terms, numerical integration takes a function that represents a continuous process (like the changing value of an investment over time) and approximates the area under its curve. This area can then be used to calculate important quantities, like the total return of the investment or price of a derivative instrument.\nSo we are tasked with a problem, and one that has many different ways of solving, or rather approximating the solution. You most likely (taking into account you’re still reading this) encountered rectangle rule, or Riemann summation in your Calculus 101 course/self-learning. But there are many other techniques, which we call schemes.\nFor quantitative analysts, the choice of the integration method matters. Different integration schemes offer varying levels of accuracy and efficiency. Unfortunately there’s no best technique. Same algorithm can be a perfect fit for problems with certain characteristics, but unusable for others. And then there is the old as time performance vs. accuracy trade-off.\nAs programmers working in finance, we need to be adaptable and leverage solutions that allow us to switch between these methods seamlessly."
  },
  {
    "objectID": "posts/strategy-pattern-integration/index.html#design-patterns",
    "href": "posts/strategy-pattern-integration/index.html#design-patterns",
    "title": "Strategies for Numerical Integration",
    "section": "Design patterns",
    "text": "Design patterns\nThis is where design patterns come in. Design patterns are reusable solutions to common programming problems. Their widespread adoption in software development is largely attributed to the publication of Design Patterns: Elements of Reusable Object-Oriented Software in 1994. Authored by E. Gamma, R. Helm, R. Johnson, and J. Vlissides (often referred to as the “Gang of Four” or GoF), this book cataloged 23 essential software design patterns. These patterns provided solutions to common design problems in object-oriented programming, promoting code reusability, maintainability, and flexibility.\nSome design patterns can feel clunky or inelegant when implemented in Python. The language itself often has built-in features or idioms that achieve the same result in a more Pythonic way (meaning it follows Python’s style and conventions). Sometimes, design patterns can be seen as overcomplicating simple problems. On the other hand, usage of well-known and understood patterns may enhance your engineering skills and improve code readability.\nUltimately, the decision of whether or not to use design patterns in Python depends on the specific context of your project and your coding style. There’s no right or wrong answer. But first, you need to know the classics to diss the classics. We’ll hold on with the dissing for now, cause in the example below chosen design pattern makes for a very clean implementation. You’ll see for yourself."
  },
  {
    "objectID": "posts/strategy-pattern-integration/index.html#strategy-pattern",
    "href": "posts/strategy-pattern-integration/index.html#strategy-pattern",
    "title": "Strategies for Numerical Integration",
    "section": "Strategy pattern",
    "text": "Strategy pattern\nWe know the stage now — one problem statement, multiple strategies to tackle. Important observation here is that we don’t actually care which one is used. When you substitute the integral value to client code — a formula or further algorithm — it’s irrelevant how it was computed, as long its correct to required level of accuracy. This means that the problem should be decoupled from algorithms to solve it. We should target a implementation where you can state a problem Calculate the integral of \\(\\sin(x)\\) from \\(0\\) to \\(\\pi\\) and then just throw different algorithms at it to obtain a solution. So let’s get coding!\n\n\n\n\n\n\nNote\n\n\n\nI will show you this pattern through an example. If you prefer more generic setup see Refactoring Guru’s implementation. The customary ‘software engineering’ example used to present the SDP is sorting a list of integers using different sorting algorithms."
  },
  {
    "objectID": "posts/strategy-pattern-integration/index.html#abstract-schema",
    "href": "posts/strategy-pattern-integration/index.html#abstract-schema",
    "title": "Strategies for Numerical Integration",
    "section": "Abstract schema",
    "text": "Abstract schema\nEach scheme that we’d come up with, even the most complex ones, would have the same main purpose — ‘integrate’. To make the implementation for it, we create a template class that all concrete schemes will inherit from.\n\nfrom abc import ABC, abstractmethod\nfrom typing import Callable\n\nclass IntegrationScheme(ABC):\n    \"\"\"Abstract base class for integration schemas.\"\"\"\n\n    @abstractmethod\n    def integrate(\n        self,\n        integrand: Callable[[float], float],\n        *,\n        start: float,\n        end: float,\n    ) -&gt; float:\n        \"\"\"Abstract method for integrating a function.\"\"\"\n\nUnpacking this, we already used some nifty Pythonic tricks in those few lines:\n\nABC is a way of defining abstract classes. If you try to create an object of a class inheriting from ABC you’d get an error. It is used as a base class for concrete subclasses and serves as a template. Think of an example of animal and cat from the real world. You’ve never seen an abstract animal being in your life (that would be a truly transcendental experience). But you’ve hopefully seen many cats.\nDecorator @abstractmethod signifies that the method is just a mock-up. It needs to be present and overridden in all concrete classes that inherit from IntegrationScheme\nType annotations like start: float don’t affect the script behavior in any way. Those are only for us to not get lost in Python’s dynamic typing magic. They can also be leveraged by static type checkers like mypy to flag problems with your code before you run it — just like in compiled languages.\nCallable annotation signifies a function-like object something you can call through (), like some_func(one, second=two)’ — here some_func is a callable. Calls to an object can be implemented by writing the __call__ method for the class."
  },
  {
    "objectID": "posts/strategy-pattern-integration/index.html#concrete-schema-implementations",
    "href": "posts/strategy-pattern-integration/index.html#concrete-schema-implementations",
    "title": "Strategies for Numerical Integration",
    "section": "Concrete schema implementations",
    "text": "Concrete schema implementations\n\nRectangle Rule\nIt’s the simplest way of estimating the area under a curve you can think of — cover it with smaller and smaller rectangles with the value of a function at the leftmost point as height constant width.\n\nImplementing this idea is trivial when using numpy, but let’s add some syntactic sugar so the class is sweeter to work with.\n\nimport numpy as np\n\nclass RectangleScheme(IntegrationScheme):\n    \"\"\"Schema for rectangle integration.\"\"\"\n\n    def __init__(\n        self,\n        steps: int,\n    ) -&gt; None:\n        \"\"\"Initializes the rectangle integration config.\"\"\"\n        if steps &lt;= 0:\n            raise ValueError(\"Steps must be greater than 0.\")\n        self._steps = steps\n\n    def __str__(self) -&gt; str:\n        \"\"\"Returns the string representation of the schema.\"\"\"\n        return f\"Rectangle schema with {self._steps} steps\"\n\n    def integrate(\n        self,\n        integrand: Callable[[float], float],\n        *,\n        start: float,\n        end: float,\n    ) -&gt; float:\n        \"\"\"Integrates a function using rectangle integration.\"\"\"\n        x_points = np.linspace(start, end, self._steps)\n        values = integrand(x_points)\n        dx = (end - start) / np.float64(self._steps)\n        return np.sum(values) * dx\n\n\nRectangleScheme subclasses IntegrationScheme so we need to implement the integrate method.\n__init__ method is run each time object of this class is requested. It sets the stage — in this case all we need is the number of rectangles we are to use. To be cautious, we check if the steps number is positive.\n__str__ is called when we try to represent the object as string — ex. in f-strings or directly calling str(). We just taught our class objects to introduce themselves nicely.\nintegrate is as simple as the idea behind it:\n\nget the equaly spaced x values,\ncalculate integrand values at the points,\nsum it up,\nmultiply the sum by the distance between two consecutive points.\n\n\n\n\nSimple Monte Carlo\nThis guy sounds fancy with its luxurious Monaco vibes, but it’s just a peasant in a nice suit. Instead of looking at equaly-spaced points, we shuffle them from uniform distribution on the interval of integration. We calculate the integrand function values at those points and sum them up. Then multiply the sum by the average distance between points and through the magic of probability theory (and not opening actual probability textbook in 10 years) you get a good probabilistic estimator of the integral value. The implementation is analogous to the RectangleScheme.\n\nfrom typing import Optional\n\nclass MonteCarloScheme(IntegrationScheme):\n    \"\"\"Schema for Monte Carlo integration.\"\"\"\n\n    def __init__(\n        self,\n        random_points: int,\n        random_seed: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\"Initializes the rectangle integration config.\"\"\"\n        if random_points &lt;= 0:\n            raise ValueError(\"Points must be greater than 0.\")\n        self.__random_points = random_points\n        self.__random_seed = random_seed\n\n    def __str__(self) -&gt; str:\n        \"\"\"Returns the string representation of the schema.\"\"\"\n        points_msg = f\"Monte Carlo schema with {self.__random_points} random points\"\n        seed_msg = f\" and seed {self.__random_seed}\" if self.__random_seed else \"\"\n        return f\"{points_msg}{seed_msg}\"\n\n    def integrate(\n        self,\n        integrand: Callable[[float], float],\n        *,\n        start: float,\n        end: float,\n    ) -&gt; float:\n        \"\"\"Integrates a function using Monte Carlo integration.\"\"\"\n        np.random.seed(seed=self.__random_seed)\n        x_points = np.random.uniform(start, end, self.__random_points)\n        values = integrand(x_points)\n        average_dx = (end - start) / np.float64(self.__random_points)\n        return np.sum(values) * average_dx\n\n\nOptional[int] annotation means that the value of random_seed can be a float or None. With a set seed we get a reproducable results — good for testing but not for actual usage. Hence the default value here is None.\n\n\n\n\n\n\n\nNote\n\n\n\nThe Optional stands for could be None as well, it doesn’t affect if the input is mandatory or not. In our case it’s not, but thats stated by the = None part. In Python 3.11 onwards it’s recommended to use int | None instead."
  },
  {
    "objectID": "posts/strategy-pattern-integration/index.html#integrator",
    "href": "posts/strategy-pattern-integration/index.html#integrator",
    "title": "Strategies for Numerical Integration",
    "section": "Integrator",
    "text": "Integrator\nWhat’s left is to have a way of defining the problem to solve and define how our schemes (strategies) interact with it.\n\n\"\"\"An integrator class that allows to perform integration using different schemas.\"\"\"\nfrom typing import Callable\n\nclass Integrator:\n    \"\"\"An integrator class that allows to perform integration using different\n    schemas as strategies.\"\"\"\n\n    def __init__(\n        self,\n        integrand: Callable[[float], float],\n        interval_start: float,\n        interval_end: float,\n    ) -&gt; None:\n        \"\"\"Initializes the integrator class.\"\"\"\n        if interval_start &gt;= interval_end:\n            raise ValueError(\"Start value must be less than end value.\")\n        self.__integrand = integrand\n        self.__interval_start = interval_start\n        self.__interval_end = interval_end\n\n    def __call__(\n        self,\n        schema: IntegrationScheme,\n    ) -&gt; float:\n        \"\"\"\n        Calculates the definite integral value of a function.\n\n        Args:\n            schema: integration schema\n        \"\"\"\n        print(f\"Using {schema}.\")\n        return schema.integrate(\n            self.__integrand,\n            start=self.__interval_start,\n            end=self.__interval_end,\n        )\n\n\nThe __init__ takes in the obvious parameters — function to integrate, start and end of the interval. It also checks if it’s a proper integral.\nWe get to implement our own __call__ method now. It’s clear what Integrator class does. No need to have a method with a descriptive name like Integrator.integrate. To use it you pass through the integration scheme into the integrator — notice annotation of the abstract IntegrationScheme. It prints the info on strategy used (using the __str__ methods) and calls integrate method of the scheme. No care in the world on how the value is actually calculated."
  },
  {
    "objectID": "posts/strategy-pattern-integration/index.html#lets-integrate",
    "href": "posts/strategy-pattern-integration/index.html#lets-integrate",
    "title": "Strategies for Numerical Integration",
    "section": "Let’s integrate!",
    "text": "Let’s integrate!\nOk, now to the integrating! Let’s set up the stage:\n\nstart, end = 0, np.pi / 2.0\n\ndef f(x: float) -&gt; float:\n    return np.sin(x) + np.cos(x)\n\nExcited? Don’t be… yet.\nWe should get some benchmark value first. As none of us would bother to integrate this by hand, we’ll use SciPy. Unexpectedly (SciPy uses C and Fortran underneath), we get the result in a breeze and it is very close to actual value of 2.0.\n\nfrom scipy.integrate import quad\n\nscipy_quad, err = quad(f, start, end)\nprint(scipy_quad)\n\n1.9999999999999998\n\n\nNow let’s use our Integrator class and see.\n\nintegrator = Integrator(\n    f,\n    interval_start=start,\n    interval_end=end,\n)\n\niterations = [2**i for i in range(0,21,5)]\nrectangle_results = [integrator(RectangleScheme(steps=i)) for i in iterations]\nmc_results = [integrator(MonteCarloScheme(random_points=i)) for i in iterations]\n\nprint(f\"Rectangle schema results:\\n{rectangle_results}.\")\nprint(f\"Monte Carlo schema results:\\n{mc_results}.\")\n\nUsing Rectangle schema with 1 steps.\nUsing Rectangle schema with 32 steps.\nUsing Rectangle schema with 1024 steps.\nUsing Rectangle schema with 32768 steps.\nUsing Rectangle schema with 1048576 steps.\nUsing Monte Carlo schema with 1 random points.\nUsing Monte Carlo schema with 32 random points.\nUsing Monte Carlo schema with 1024 random points.\nUsing Monte Carlo schema with 32768 random points.\nUsing Monte Carlo schema with 1048576 random points.\nRectangle schema results:\n[np.float64(1.5707963267948966), np.float64(1.986172817555692), np.float64(1.9995804632216618), np.float64(1.9999869013603688), np.float64(1.9999995906791057)].\nMonte Carlo schema results:\n[np.float64(1.6744749528914122), np.float64(1.9909974700320354), np.float64(2.000216564426225), np.float64(1.9996264538512554), np.float64(2.0002108183415483)].\n\n\nThe performance and convergence of those schemes is terrible. Like anything in Python, if you want robust and performing code, you need to implement it with C or use any/all of the enhancement frameworks that Python provides (see Numba). Additionally, the simple methods we implemented are very naive. The standard numerical packages use sophisticated algorithms honed for many decades.\nBut I was wrong! You should be excited! We just learned new approach for setting up extensible and readable code! Look how cleanly the problem statement is separated form different strategies to solve it.\nIf you are now wondering how much we could improve by using more advanced techniques (like stratified Monte Carlo or adaptive quadrature) you just need to implement new subclass of `IntegrationSchema’ and you’re done. No changes to the existing code are needed, just simple extension. And that’s the idea behind strategy pattern.\n\n\n\n\n\n\nNote\n\n\n\nDownload the whole code here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "bwrob blog",
    "section": "",
    "text": "This blog is a battleground of sorts, but instead of swords and shields, we wield the weapons of Python and C++. I’m a mathematician turned quantitative analyst turned software engineer. You can expect high standard deviation of topics here.\nHere, I’ll document my coding conquests, from building practical and impractical tools, exploring financial concepts, to playing around with physics simulations.\nExpect a healthy dose of humor alongside the technical discussions. Let’s be honest, even the most complex problems are more enjoyable with a sprinkle of laughter. So, grab a cup of coffee and join me on this exploration – even if it’s just for one interested reader!\n\n\n\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nInvestment Banking (PL)\n\n\n\nFinancial Markets\n\n\n\nInvestment Banking - exam review\n\n\n\nbwrob\n\n\nJun 22, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nMathematician in the financial markets (PL)\n\n\n\nCareer\n\nFinancial Markets\n\n\n\nHow to survive in the whirlpool of finance.\n\n\n\nbwrob\n\n\nMar 22, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nPrettify Dev Terminal Setup\n\n\n\nDev Env\n\n\n\nHow to have a great dev terminal setup.\n\n\n\nbwrob\n\n\nAug 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinux in Windows via WSL\n\n\n\nDev Env\n\n\n\nHow to have a great dev setup and still play CS over a coffee break.\n\n\n\nbwrob\n\n\nAug 11, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinux Python Dev Env\n\n\n\nDev Env\n\n\n\nHow to have a great Python dev setup.\n\n\n\nbwrob\n\n\nAug 11, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Startup Script\n\n\n\nPythonic Distractions\n\n\n\nHow to start your day with a cup of coffee, not opening the same apps all over again.\n\n\n\nbwrob\n\n\nMay 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nExit stack to the rescue\n\n\n\nPythonic Distractions\n\n\n\nHow to chain resource managers in an elegant way.\n\n\n\nbwrob\n\n\nMay 12, 2024\n\n\n\n\n\n\n\n\n\n\n\nStrategies for Numerical Integration\n\n\n\nPythonic Distractions\n\n\n\nHow to apply strategy design pattern in Python.\n\n\n\nbwrob\n\n\nApr 28, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\nHow to enjoy the ride with me.\n\n\n\nbwrob\n\n\nApr 23, 2024\n\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "pages/resume.html",
    "href": "pages/resume.html",
    "title": "Bartosz Wróblewski",
    "section": "",
    "text": "Mathematician at heart, quantitative finance technologist by trade. I leverage diverse experiences in academia, derivatives valuation, market risk, and quantitative development to bring a generalist’s perspective to quantitative finance and software engineering.\n\n \n  \n   \n  \n    \n     LinkedIn\n  \n  \n    \n     Github\n  \n  \n    \n     Contact"
  },
  {
    "objectID": "pages/resume.html#professional-experience",
    "href": "pages/resume.html#professional-experience",
    "title": "Bartosz Wróblewski",
    "section": "Professional Experience",
    "text": "Professional Experience\n\nDXC Luxoft\n\nSenior Software Developer | Sep 2024 – Present\nRisk Engine Engineer role in the counterparty credit risk (CCR) modelling and analytics team within R&C model development group.\n\n\n\nSyberry\n\nFinancial Software Engineer | Sep 2023 – Sep 2024\nDevelopment of a financial platform for a hedge fund client.\n\nQuantitative developer bridging the gap between hedge fund risk managers and software engineers.\nDeveloping risk management platform that pipes and transforms trading data.\nResponsible for integration of vendor risk management system into the platform, efficient orchestration of asynchronous API calls and resources.\nWorking directly with client’s risk manager and CRO on specifying the business needs and requirements.\n\nTechnologies\n\nBackend: Python, Dagster, FastAPI, Pytest, Pandas, NumPy, SQLAlchemy.\nDatabases: PostgreSQL, DuckDB.\nInfrastructure/pipelines: Amazon Web Services, Terraform, Terraspace, Docker, GitHub Actions.\n\n\n\n\nBank of New York Mellon\n\nSenior Specialist, Model Development | Jul 2022 – Sep 2023\nIndependent specialist at Risk and Compliance department (MO). Market Risk team responsible for modeling of VaR and SVaR, comprehensive test scenarios and portfolio sensitivity exposures.\n\nDeveloping and maintaining market risk models — VaR, SVaR — and stress testing frameworks implemented in C++.\nCalibrating and benchmarking vendor pricing models (Murex risk management system).\nDesigning, creating and analyzing risk-related reports and ad hoc analyses for front office and risk management.\nResponsible for Market Risk RWA projections submission for CCAR 2023.\nCoordinating development projects with IT, Validation and Risk Management.\nDeveloped a method for directly comparing interest rate sensitivities between FO and MO systems using different conventions and curves setups.\nRe-implemented legacy C++ volatility surface builder in Python without performance loss.\n\nTechnologies\n\nInternal risk models: C++.\nVendor pricing system: Murex.\nDatabases: MS SQL.\nTooling: Python, Quantlib, VBA.\n\n\n\n\nCredit Suisse\n\nQuantitative Analyst | Nov 2018 – Jun 2022\nJunior analyst at Credit Derivatives division, part of global front office QuantStrats department (700+ quants, developers and data analysts).\n\nDevelopment and maintenance of an in-house valuation framework used across bank’s systems (COM C++ and .Net). Contributions to valuation models and market data object builders used in pricing.\nProviding direct support to traders and Middle Office in ad hoc investigations on valuation, risks and technical issues.\nExtending and creating COM-addin-based Excel pricing sheets used by Trading and Product Control.\nAssisting with calculation and analysis of risk profiles, PnL reports, transition impact assessments of trade portfolios.\nRepresented the company by giving lectures and taking part in campus recruitment programs.\nCoordinated resolution of strategic process of calculating Collateral Adjusted Valuation for the xVA desk.\n\nStructured Notes\nCredit Suisse issued structured note products (corporate bonds with derivatives attached to payout).\n\nContributed to structured notes valuation model framework implemented in factorized C++.\nUpdated credit curve models and utilities to be compatible with OIS discounting in preparation to LIBOR cessation (F#).\nExtended trading pricing sheets with logic needed to price instruments with compounding rates financing (Excel, COM-addins, .Net extensions).\nCollaborated with quantitative developers from in-house risk management system project on addition of new market data builders (C#).\n\nLongevity Derivatives\nLongevity-based (insurance policies and pension schemes) financial derivatives.\n\nMigrated existing legacy tools to 64-bit environment.\nProvided technical support to Product Control in their monthly tie-in processes.\n\nTechnologies\n\nPricing framework: F#, C++, COM.\nRisk Managment: C#.\nTrading tools: Excel, VBA.\nCI/CD: Perforce, TeamCity."
  },
  {
    "objectID": "pages/resume.html#academic-experience",
    "href": "pages/resume.html#academic-experience",
    "title": "Bartosz Wróblewski",
    "section": "Academic Experience",
    "text": "Academic Experience\n\nWrocław University of Science and Technology\n\nTeaching Assistant | Oct 2024 – Present\nTeaching computer science for Mathematics students.\n\n\n\nUniversity of Wrocław\n\nPhD Candidate | Oct 2016 – Jan 2019\nResearched evolution equations involving non-local unbounded operators. Focused on applications of functional and harmonic analysis. Main ‘hero’ of my research was the fractional Laplacian operator — jump-diffusion analogue of the classical Laplacian.\nAlso interested in hydrodynamic models and applications of PDEs in physics (porous medium modelling, flocking models, quantum mechanics).\nUnfinished.\n\n\nJunior Researcher | Apr 2017 – Jan 2019\nParticipated in the Polish National Science Center research grant Nonlocal parabolic problems: regularity, blowup, pattern formation. Principal Investigator Prof. Piotr Biler.\n\n\nTeaching Assistant | Mar 2017 – Jul 2018\nNon-linear Functional Analysis, Ordinary Differential Equations, Honors Ordinary Differential Equations.\n\n\n\nUniversity of Warsaw\n\nResearch Intern | Dec 2016 – Mar 2017\nVisiting position during CrossFields PDEs semester organised and sponsored by The Simons Foundation.\nCollaboration with Raphael Dunchin, Piotr B. Mucha and with Jan Peszek in the research on fractional Euler alignment system (hydrodynamic flocking dynamics).\n\nRegular solutions to the fractional Euler alignment system in the Besov spaces framework published in Mathematical Models and Methods in Applied Sciences Vol. 29, No. 01, pp. 89-119\n\n\n\nTeaching Assistant | Jan 2017 – Mar 2017\nAnalysis 1, Analysis 2."
  },
  {
    "objectID": "pages/resume.html#education",
    "href": "pages/resume.html#education",
    "title": "Bartosz Wróblewski",
    "section": "Education",
    "text": "Education\n\nUniversity of Wrocław\n\nMsc in Theoretical Mathematics | Oct 2014 – Sep 2016\nThesis topic: “The anomalous diffusion and fractional Laplacian on the half-line” written under the supervision of Prof. Grzegorz Karch.\n\n\n\nWrocław University of Science and Technology\n\nBSc in Theoretical Mathematics | Oct 2011 – Jul 2014"
  },
  {
    "objectID": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024.html",
    "href": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024.html",
    "title": "Wstęp do programowania (PWr Zima 2024)",
    "section": "",
    "text": "Laboratoria komputerowe do wykładu Andrzeja Giniewicza."
  },
  {
    "objectID": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024.html#zasady-zaliczenia",
    "href": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024.html#zasady-zaliczenia",
    "title": "Wstęp do programowania (PWr Zima 2024)",
    "section": "Zasady zaliczenia",
    "text": "Zasady zaliczenia\nOgólne zasady zaliczenia kursu można znaleźć na stronie kursu u wykładowcy.\nDoprecyzowania obowiazujace w moich grupach:\n\nListy zadańZadanie domoweOdpowiedź ustnaProjekt grupowyAktywność\n\n\nConajmniej pierwsze 4 listy będziemy robić na zajęciach, w systemie deklaracyjnym. Po zajęciach proszę o przesłanie rozwiązań. Kolejne listy zadań będą w formie zadań domowych, do zrobienia i przesłania przed zajęciami. Rozwiązania będą omiawiane i wyrywkowo sprawdzane w trakcie zajęć.\n\n\nWyobraź sobie, że pomagasz młodszemu koledze lub koleżance, którzy dalej są w liceum. Chcesz przygotować interaktywny notebook tłumaczący jakieś zagadnienie z zakresu matematyki, fizyki, informatyki lub chemii. Wybrany temat może, ale nie musi pochodzić z zakresu nauczania w szkole średniej. Ma być zrozumiały i dostępny dla ucznia liceum. Kod Python nie musi być zrozumiały dla licealisty. Polecam wybrać temat, który Ciebie też interesuje.\nW Twoim dokumencie powinny znaleźć się prawidłowo sformatowane komórki tekstowe, z nagłówkami oraz wzorami. Umieść również obliczenia wykonane w języku Python, jako ilustrację do niektórych przykładów, rozwiązanie zadań, lub wizualizację. Można, ale nie trzeba używać modułów Python nie przedstawionych na kursie.\nZa zadanie domowe można dostać maksymalnie 10 punktów. Po 3 za użycie Pythona, skład i formatowanie komórek Markdown oraz treść tłumaczaca zagadnienie. Dodatkowy punkt za ogólna schludność i estetykę zeszytu.\nGdybyś chciał wydrukować notatnik, powinien zająć przynajmniej dwie strony A4 przy standardowym rozmiarze kroju pisma (podpowiedź - możesz sprawdzić podgląd wydruku w menu File w narzędziu Jupyter Lab, jeśli trudno ocenić Ci ile już napisałeś).\nTermin oddania do 19 listopada (grupa wtorkowa) / 21 listopada (grupa czwartkowa). Zadanie domowe proszę przesyłać mailowo. Proszę załaczyć informację czy zgadzasz się na pokazanie Twojej pracy innym studentom i opublikowanie jej tutaj jako przyklad.\n\n\nOd 7-mych zajęć można zgłaszać się na ochotnika, co najmniej 3 ochotników jest wymaganych na jednych zajęciach.\n\n\nMożna się łączyć w grupy w obrębie moich 2 zajęć (wtorek 7:30 i czwartek 7:30), ale nie poza. Zakładam w sumie 5-8 grup projektowych.\n\n\nPunkty zostaną przydzielone na zasadzie normalizacji rozkładu aktywności na zajęciach. Gwarantuję, że jedna duża aktywność (np. przedstawienie pełnego rozwiązania z listy) będzie dawała co najmniej jeden punkt."
  },
  {
    "objectID": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024.html#python",
    "href": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024.html#python",
    "title": "Wstęp do programowania (PWr Zima 2024)",
    "section": "Python",
    "text": "Python\nKomentarze do list zadań"
  },
  {
    "objectID": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024.html#bash-i-git",
    "href": "pages/courses/pwr-intro-to-cs-2024/pwr-intro-to-cs-2024.html#bash-i-git",
    "title": "Wstęp do programowania (PWr Zima 2024)",
    "section": "Bash i git",
    "text": "Bash i git\n\nNawigacja systemu plikówSkryptowanieGit i GitLab\n\n\nPrzyklady komend uzytych na zajeciach (rozszyfrowanie ich jako zadanie dla czytelnika):\nhistory -c\npwd\ncd ~\nmkdir test\ncd test\ntouch test.txt\ncode test.txt\ncp test.txt test2.txt\nmv test2.txt test3.txt\nrm test2.txt\necho \"Hello World\" &gt;&gt; test3.txt\ncat test3.txt\nwc &lt; test3.txt\ncat test.txt test3.txt &gt; test4.txt\ncd ..\nrm -ri test\nls -la\nhistory 1 &gt; notatki.txt\n\n\nPrzykladowy skrypt zapisany jako plik hello.sh:\n#! bash\n\necho \"Hello $1 !\"\n\nif [ \"$1\"==\"Flip\" ] ; then\n    echo ”Long time no see ! ”\nelif [ \"$1\"==\"Flap\" ] ; then\n    echo \"What do you want?\"\nelse\n    echo \"Who are you again ?\"\nfi\n\nif ! [ -f log.txt ] ; then\n    touch log.txt\nfi\necho \"$(date) User $1 visited.\" &gt;&gt; log.txt\n\nfor i in $(seq 5 -1 1)\ndo\n    echo \"Konczymy za $i\"\ndone\nJego wykonanie:\nchmod +x hello.sh\n./hello.sh Flap\nSkrypt w pythonie:\n\n\nHello !\nNice to meet you -f\nNice to meet you /private/var/folders/cp/8hw2xqrd443d0znxcbb7vjmm0000gn/T/tmpzgk7w64w.json\nNice to meet you --HistoryManager.hist_file=:memory:\n\n\nJego wykonanie:\nchmod +x hello.py\n./hello.py Flip Flap Flop\n\n\nGenerowanie klucza SSH (warto przeczytać oficjalne instrukcje)\nssh-keygen -t ed25519 -C \"imie nazwisk, indeks\"\nKlucz publiczny powinien byc w pliku ~/.ssh/id_ed25519.pub. Na koncie GitLab powinien byc dodany klucz publiczny SSH.\nUstawienie klucza SSH w systemie lokalnym:\neval $(ssh-agent)\nssh-add &lt;sciezka klucza&gt;\nssh git@gitlab.com\nTworzymy repozytorium lekcja-1na stronie GitLab. Klikamy na niebieskie przycisk Code i kopiujemy to co pod SSH.\nKlonujemy repozytorium GitLab, ustawiamy uzycie klucza SSH, tworzymy gałąź main.\ngit clone &lt;sciezka ssh&gt;\ngit config --global user.name \"&lt;imie nazwisko&gt;\"\ngit config --global user.email \"&lt;email pwr&gt;\"\ngit config --local gpg.format ssh\ngit config --local user.signingkey /ścieżka/do/klucza/id_ec25519.pub\ngit switch --create main\nTworzymy plik README.md, dodajemy go do repozytorium, commitujemy i pushujemy.\ntouch README.md\ngit add README.md\ngit commit -S -m \"puste readme\"\ngit status\ngit push"
  },
  {
    "objectID": "pages/courses/uwr-odes-1r-2018.html",
    "href": "pages/courses/uwr-odes-1r-2018.html",
    "title": "Równania Różniczkowe 1R (UWr Lato 2018)",
    "section": "",
    "text": "Prowadzę ćwiczenia do wykładu Piotra Bilera. Program kursu można znaleźć tutaj."
  },
  {
    "objectID": "pages/courses/uwr-odes-1r-2018.html#materiały-do-nauki",
    "href": "pages/courses/uwr-odes-1r-2018.html#materiały-do-nauki",
    "title": "Równania Różniczkowe 1R (UWr Lato 2018)",
    "section": "Materiały do nauki",
    "text": "Materiały do nauki\n\nRównania różniczkowe zwyczajne\n\nSkrypt Raczyńskiego\nSkrypt Palczewskiego\nZadania Palczewskiego\nCzynnik całkujący\nKrzywe ortogonalne\n\n\n\nRównania różniczkowych cząstkowych\n\nMetoda charakterystyk\nMetoda rozdzielania zmiennych\nRównanie fali\nRównanie ciepła\nRównanie Laplace’a"
  },
  {
    "objectID": "pages/courses/uwr-odes-1r-2018.html#listy-zadań",
    "href": "pages/courses/uwr-odes-1r-2018.html#listy-zadań",
    "title": "Równania Różniczkowe 1R (UWr Lato 2018)",
    "section": "Listy zadań",
    "text": "Listy zadań\n\nLista 00 - lista uzupełniająca/powtórzeniowa dotycząca zagadnień z analizy.\nLista 01 - lista z równań liniowych pierwszego rzędu i równań o zmiennych rozdzielonych.\nLista 02 - lista z równań w postaci różniczki zupełnej i zastosowań równań pierwszego rzędu.\nLista 03 - lista z twierdzeń o istnieniu i jednoznaczności.\nLista 04 - lista z liniowych układów równań.\nLista 05 - lista z równań skalarnych wyższych rzędów.\nLista 06 - lista ze stabilności i portretów fazowych.\nLista 07 - lista z metody charakterystyk.\nLista 08 - lista z metody rozdzielania zmiennych\nLista 09 - lista z własności równania fali, równania ciepła i równania Laplace’a.\nLista 10 - lista nieobowiązkow z transformaty Laplace’a."
  },
  {
    "objectID": "pages/courses/uwr-odes-1r-2018.html#kolokwia",
    "href": "pages/courses/uwr-odes-1r-2018.html#kolokwia",
    "title": "Równania Różniczkowe 1R (UWr Lato 2018)",
    "section": "Kolokwia",
    "text": "Kolokwia\n\nKolokwium 1 (16.04):\n\nRozwiązania\n\nKolokwium 2 (11.06):\n\nRozwiązania"
  },
  {
    "objectID": "pages/courses/uwr-odes-1-2018.html",
    "href": "pages/courses/uwr-odes-1-2018.html",
    "title": "Równania Różniczkowe 1 (UWr Lato 2018)",
    "section": "",
    "text": "Prowadzę jedną z grup ćwiczeniowych do wykładu Andrzeja Raczyńskiego.\nZasady zaliczania kursu dostępne są na serwisie Moodle oraz tutaj."
  },
  {
    "objectID": "pages/courses/uwr-odes-1-2018.html#materiały-do-nauki-równań-różniczkowych-zwyczajnych",
    "href": "pages/courses/uwr-odes-1-2018.html#materiały-do-nauki-równań-różniczkowych-zwyczajnych",
    "title": "Równania Różniczkowe 1 (UWr Lato 2018)",
    "section": "Materiały do nauki równań różniczkowych zwyczajnych:",
    "text": "Materiały do nauki równań różniczkowych zwyczajnych:\n\nSkrypt do kursu: Napisany przez Andrzeja Raczyńskiego. RR 1A - Raczyński\nSkrypt do zajęć na UW: Napisany przez Andrzeja Palczewskiego. RRZ skrypt - Palczewski\nZbiór zadań: Dostosowany do skryptu AP. RRZ zadania - Palczewski"
  },
  {
    "objectID": "pages/courses/uwr-odes-1-2018.html#materiały-do-nauki-równań-różniczkowych-cząstkowych",
    "href": "pages/courses/uwr-odes-1-2018.html#materiały-do-nauki-równań-różniczkowych-cząstkowych",
    "title": "Równania Różniczkowe 1 (UWr Lato 2018)",
    "section": "Materiały do nauki równań różniczkowych cząstkowych:",
    "text": "Materiały do nauki równań różniczkowych cząstkowych:\n\nMetoda charakterystyk: charakterystyki\nMetoda rozdzielania zmiennych: rozdzielaniezmiennych\nRównanie fali: fala\n\n\nListy zadań:\n\nLista 1\nLista 2\nLista 3\nLista 4\nLista 5\nLista 6\n\nListy zadań dostępne są również na serwisie Moodle."
  },
  {
    "objectID": "pages/courses/uwr-nonlinear-fa-2017.html",
    "href": "pages/courses/uwr-nonlinear-fa-2017.html",
    "title": "Nieliniowa analiza funkcjonalna (UWr Lato 2017)",
    "section": "",
    "text": "Prowadzę ćwiczenia do wykładu Grzegorza Karcha. Opis kursu.\nMateriały do kursu będą się regularnie pojawiały na stronie wykładowcy.\n\nLista 1\nLista 2"
  },
  {
    "objectID": "pages/courses/uwr-nonlinear-fa-2017.html#nieliniowa-analiza-funkcjonalna",
    "href": "pages/courses/uwr-nonlinear-fa-2017.html#nieliniowa-analiza-funkcjonalna",
    "title": "Nieliniowa analiza funkcjonalna (UWr Lato 2017)",
    "section": "",
    "text": "Prowadzę ćwiczenia do wykładu Grzegorza Karcha. Opis kursu.\nMateriały do kursu będą się regularnie pojawiały na stronie wykładowcy.\n\nLista 1\nLista 2"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-log.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-log.html",
    "title": "Logowanie",
    "section": "",
    "text": "Używamy tej recepty wzbogaconej o pakiet rich do ustawienia logowania w projekcie. Dostajemy wtedy kolorowe logi na poziomie INFO i wyżej w terminalu, a dodatkowe informacje na poziomie DEBUG w pliku log.txt.\nimport logging\nfrom rich.logging import RichHandler\n\nlogger = logging.getLogger(\"simple_example\")\nlogger.setLevel(logging.DEBUG)\n\n# logger jest tworzony tylko raz, więc nie dodajemy handlerów więcej niż raz\nif not logger.hasHandlers():\n    # zapisujemy logi DEBUG i wyżej do pliku\n    fh = logging.FileHandler(\"simple_example.log\")\n    fh.setLevel(logging.DEBUG)\n    # ustalamy format logów\n    formatter = logging.Formatter(\n        \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n    # dodajemy formatter do handlera\n    fh.setFormatter(formatter)\n    # dodajemy handler do loggera\n    logger.addHandler(fh)\n\n    # wypisujemy logi INFO i wyżej do terminala\n    # używamy RichHandler do kolorowych  czytelnych logów\n    ch = RichHandler()\n    ch.setLevel(logging.INFO)\n    logger.addHandler(ch)\n\n# przykładowe logi\nlogger.debug(\"debug message\")\nlogger.info(\"info message\")\nlogger.warning(\"warn message\")\nlogger.error(\"error message\")\n\n[06/01/25 11:34:56] INFO     info message                                                           621881346.py:29\n\n\n\n                    WARNING  warn message                                                           621881346.py:30\n\n\n\n                    ERROR    error message                                                          621881346.py:31\nW pliku dostajemy logi w formacie:"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-log.html#zadanie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-log.html#zadanie",
    "title": "Logowanie",
    "section": "Zadanie",
    "text": "Zadanie\nWybierz jedną z dotychczasowych list zadań i dodaj do niej logowanie.\n\nZamien print na logger.info lub logger.debug w odpowiednich miejscach.\nDodaj logowanie błędów w miejscach, gdzie wcześniej był print z błędem.\nDodaj dodatkowe logi DEBUG w miejscach, które sprawiły Ci trudność lub były niejasne."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-dual.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-dual.html",
    "title": "Liczby dualne",
    "section": "",
    "text": "Implementujemy liczby dualne w Pythonie. Nasza implementacja powinna być napisana w pliku dual_numbers.py.\nCelem tego zadania jest zaimplementowanie klasy DualNumber w Pythonie. Liczby dualne są rozszerzeniem liczb rzeczywistych o specjalny element ‘ε’ (epsilon), taki że ε² = 0. Są one używane w automatycznym różniczkowaniu.\nLiczba dualna: Liczba postaci a + bε, gdzie ‘a’ i ‘b’ są liczbami rzeczywistymi, a ε jest jednostką nieskończenie małą.\nInstrukcje:\n\nDefinicja klasy:\n\nUtwórz klasę o nazwie DualNumber.\nKonstruktor __init__ powinien przyjmować dwa argumenty, real i dual, reprezentujące odpowiednio ‘a’ i ‘b’ w a + bε. Oba powinny domyślnie wynosić 0.\nZapisz te wartości jako atrybuty self.real i self.dual.\n\nReprezentacja jako napis:\n\nZaimplementuj metody __str__ i __repr__, aby zapewnić przyjazną dla użytkownika reprezentację napisową liczby dualnej. Powinna ona wyglądać odpowiednio jak “a + bε” lub “a - bε” dla __str__ i “DualNumber(a,b)” dla __repr__.\n\nOperacje arytmetyczne:\n\nZaimplementuj następujące operacje arytmetyczne, aby umożliwić obliczenia na liczbach dualnych:\n\n__add__ (+): (a + bε) + (c + dε) = (a + c) + (b + d)ε\n__sub__ (-): (a + bε) - (c + dε) = (a - c) + (b - d)ε\n__mul__ (): (a + bε)  (c + dε) = ac + (ad + bc)ε\n__truediv__ (/): (a + bε) / (c + dε) = (a/c) + ((bc - ad)/c²)ε (Załóż, że c != 0)\n__pow__ (**): (a + bε)^n = a^n + na^(n-1)bε\n__neg__ (-): -(a + bε) = -a - bε\n\nZaimplementuj prawostronne wersje tych operacji, aby obsługiwać przypadki takie jak 2 + (a + bε):\n\n__radd__\n__rsub__\n__rmul__\n__rtruediv__\n__rpow__\n\n\nOperacje porównania:\n\nZaimplementuj następujące operacje porównania:\n\n__eq__ (==): (a + bε) == (c + dε) jeśli a == c i b == d\n__ne__ (!=): (a + bε) != (c + dε) jeśli a != c lub b != d\n\n\nKonwersja na int i float:\n\nZaimplementuj metody __int__ i __float__, aby umożliwić konwersję liczby dualnej na typy int i float. Konwersja powinna zwracać tylko część rzeczywistą liczby dualnej.\n\nDodatkowe funkcje matematyczne (opcjonalne):\n\nZaimplementuj inne funkcje matematyczne jako metody klasy:\n\nsqrt(z): Pierwiastek kwadratowy liczby dualnej.\nexp(z): Funkcja wykładnicza liczby dualnej.\nsin(z): Sinus liczby dualnej.\ncos(z): Cosinus liczby dualnej.\n\n\n\nPoniżej znajduje się przykład użycia klasy DualNumber, (kod kliencki). Twoja implementacja powinna umożliwić poprawne działanie tego kodu.\n\nfrom dual_numbers import DualNumber, epsilon\n\n\nfuncje_zaimplementowane = False\n\n# Utwórz kilka liczb dualnych\na = DualNumber(2, 3)  # 2 + 3ε\nb = DualNumber(1, 4)  # 1 + 4ε\nc = DualNumber(5, 0)  # 5 + 0ε (odpowiednik liczby rzeczywistej 5)\nd = 1 + 2 * epsilon  # 1 + 2ε\n\n# Wypisz liczby dualne\nprint(\"Liczba dualna a:\", a)\nprint(\"Liczba dualna b:\", b)\nprint(\"Epsilon:\", epsilon)\n\n# Podstawowe operacje arytmetyczne\nprint(\"Dodawanie:\", a + b)\nprint(\"Odejmowanie:\", a - b)\nprint(\"Mnożenie:\", a * b)\nprint(\"Dzielenie:\", a / b)\nprint(\"Potęgowanie:\", a**2)\nprint(\"Negacja\", -a)\n\n# Operacje prawostronne\nprint(\"Dodawanie prawe:\", 1 + a)\nprint(\"Odejmowanie prawe:\", 5 - a)\nprint(\"Mnożenie prawe:\", 2 * a)\nprint(\"Dzielenie prawe:\", 10 / a)\nprint(\"Potęgowanie prawe\", 2**a)\n\n# Operacje porównania\nprint(\"Równość:\", a == b)\nprint(\"Nierówność:\", a != b)\nprint(\"Równość:\", a == DualNumber(2, 3))\n\n# Konwersja na int i float\nprint(\"Konwersja na int:\", int(a))\nprint(\"Konwersja na float:\", float(a))\n\n# Opcjonalne funkcje na liczbach dualnych\nif funcje_zaimplementowane:\n    print(\"Pierwiastek kwadratowy z a:\", DualNumber.sqrt(a))\n    print(\"Funkcja wykładnicza z a:\", DualNumber.exp(a))\n    print(\"Sinus z a:\", DualNumber.sin(a))\n    print(\"Cosinus z a:\", DualNumber.cos(a))"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-dual.html#zadanie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-dual.html#zadanie",
    "title": "Liczby dualne",
    "section": "",
    "text": "Implementujemy liczby dualne w Pythonie. Nasza implementacja powinna być napisana w pliku dual_numbers.py.\nCelem tego zadania jest zaimplementowanie klasy DualNumber w Pythonie. Liczby dualne są rozszerzeniem liczb rzeczywistych o specjalny element ‘ε’ (epsilon), taki że ε² = 0. Są one używane w automatycznym różniczkowaniu.\nLiczba dualna: Liczba postaci a + bε, gdzie ‘a’ i ‘b’ są liczbami rzeczywistymi, a ε jest jednostką nieskończenie małą.\nInstrukcje:\n\nDefinicja klasy:\n\nUtwórz klasę o nazwie DualNumber.\nKonstruktor __init__ powinien przyjmować dwa argumenty, real i dual, reprezentujące odpowiednio ‘a’ i ‘b’ w a + bε. Oba powinny domyślnie wynosić 0.\nZapisz te wartości jako atrybuty self.real i self.dual.\n\nReprezentacja jako napis:\n\nZaimplementuj metody __str__ i __repr__, aby zapewnić przyjazną dla użytkownika reprezentację napisową liczby dualnej. Powinna ona wyglądać odpowiednio jak “a + bε” lub “a - bε” dla __str__ i “DualNumber(a,b)” dla __repr__.\n\nOperacje arytmetyczne:\n\nZaimplementuj następujące operacje arytmetyczne, aby umożliwić obliczenia na liczbach dualnych:\n\n__add__ (+): (a + bε) + (c + dε) = (a + c) + (b + d)ε\n__sub__ (-): (a + bε) - (c + dε) = (a - c) + (b - d)ε\n__mul__ (): (a + bε)  (c + dε) = ac + (ad + bc)ε\n__truediv__ (/): (a + bε) / (c + dε) = (a/c) + ((bc - ad)/c²)ε (Załóż, że c != 0)\n__pow__ (**): (a + bε)^n = a^n + na^(n-1)bε\n__neg__ (-): -(a + bε) = -a - bε\n\nZaimplementuj prawostronne wersje tych operacji, aby obsługiwać przypadki takie jak 2 + (a + bε):\n\n__radd__\n__rsub__\n__rmul__\n__rtruediv__\n__rpow__\n\n\nOperacje porównania:\n\nZaimplementuj następujące operacje porównania:\n\n__eq__ (==): (a + bε) == (c + dε) jeśli a == c i b == d\n__ne__ (!=): (a + bε) != (c + dε) jeśli a != c lub b != d\n\n\nKonwersja na int i float:\n\nZaimplementuj metody __int__ i __float__, aby umożliwić konwersję liczby dualnej na typy int i float. Konwersja powinna zwracać tylko część rzeczywistą liczby dualnej.\n\nDodatkowe funkcje matematyczne (opcjonalne):\n\nZaimplementuj inne funkcje matematyczne jako metody klasy:\n\nsqrt(z): Pierwiastek kwadratowy liczby dualnej.\nexp(z): Funkcja wykładnicza liczby dualnej.\nsin(z): Sinus liczby dualnej.\ncos(z): Cosinus liczby dualnej.\n\n\n\nPoniżej znajduje się przykład użycia klasy DualNumber, (kod kliencki). Twoja implementacja powinna umożliwić poprawne działanie tego kodu.\n\nfrom dual_numbers import DualNumber, epsilon\n\n\nfuncje_zaimplementowane = False\n\n# Utwórz kilka liczb dualnych\na = DualNumber(2, 3)  # 2 + 3ε\nb = DualNumber(1, 4)  # 1 + 4ε\nc = DualNumber(5, 0)  # 5 + 0ε (odpowiednik liczby rzeczywistej 5)\nd = 1 + 2 * epsilon  # 1 + 2ε\n\n# Wypisz liczby dualne\nprint(\"Liczba dualna a:\", a)\nprint(\"Liczba dualna b:\", b)\nprint(\"Epsilon:\", epsilon)\n\n# Podstawowe operacje arytmetyczne\nprint(\"Dodawanie:\", a + b)\nprint(\"Odejmowanie:\", a - b)\nprint(\"Mnożenie:\", a * b)\nprint(\"Dzielenie:\", a / b)\nprint(\"Potęgowanie:\", a**2)\nprint(\"Negacja\", -a)\n\n# Operacje prawostronne\nprint(\"Dodawanie prawe:\", 1 + a)\nprint(\"Odejmowanie prawe:\", 5 - a)\nprint(\"Mnożenie prawe:\", 2 * a)\nprint(\"Dzielenie prawe:\", 10 / a)\nprint(\"Potęgowanie prawe\", 2**a)\n\n# Operacje porównania\nprint(\"Równość:\", a == b)\nprint(\"Nierówność:\", a != b)\nprint(\"Równość:\", a == DualNumber(2, 3))\n\n# Konwersja na int i float\nprint(\"Konwersja na int:\", int(a))\nprint(\"Konwersja na float:\", float(a))\n\n# Opcjonalne funkcje na liczbach dualnych\nif funcje_zaimplementowane:\n    print(\"Pierwiastek kwadratowy z a:\", DualNumber.sqrt(a))\n    print(\"Funkcja wykładnicza z a:\", DualNumber.exp(a))\n    print(\"Sinus z a:\", DualNumber.sin(a))\n    print(\"Cosinus z a:\", DualNumber.cos(a))"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-dual.html#rozwiązanie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-dual.html#rozwiązanie",
    "title": "Liczby dualne",
    "section": "Rozwiązanie",
    "text": "Rozwiązanie\n\nfrom __future__ import annotations\n\nimport math\n\n\nclass DualNumber:\n    \"\"\"Reprezentuje liczbę dualną postaci a + bε.\"\"\"\n\n    def __init__(self, real: float = 0.0, dual: float = 0.0) -&gt; None:\n        \"\"\"Inicjalizuje liczbę dualną.\n\n        Args:\n            real: Część rzeczywista (a). Domyślnie 0.0.\n            dual: Część dualna (b). Domyślnie 0.0.\n\n        \"\"\"\n        self.real = float(real)\n        self.dual = float(dual)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Zwraca reprezentację łańcuchową liczby dualnej.\"\"\"\n        sign = \"+\" if self.dual &gt;= 0 else \"-\"\n        return f\"{self.real} {sign} {abs(self.dual)}ε\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Zwraca oficjalną reprezentację łańcuchową liczby dualnej.\"\"\"\n        return f\"DualNumber({self.real}, {self.dual})\"\n\n    def __add__(self, other: DualNumber | float) -&gt; DualNumber:\n        \"\"\"Dodaje dwie liczby dualne lub liczbę dualną i liczbę rzeczywistą.\"\"\"\n        if isinstance(other, DualNumber):\n            return DualNumber(self.real + other.real, self.dual + other.dual)\n        if isinstance(other, int | float):\n            return DualNumber(self.real + other, self.dual)\n        return NotImplemented\n\n    def __radd__(self, other: float) -&gt; DualNumber:\n        \"\"\"Obsługuje dodawanie z liczbą rzeczywistą po lewej stronie.\n\n        other + self\n        \"\"\"\n        return self + other\n\n    def __sub__(self, other: DualNumber | float) -&gt; DualNumber:\n        \"\"\"Odejmuje dwie liczby dualne lub liczbę dualną i liczbę rzeczywistą.\"\"\"\n        if isinstance(other, DualNumber):\n            return DualNumber(self.real - other.real, self.dual - other.dual)\n        if isinstance(other, int | float):\n            return DualNumber(self.real - other, self.dual)\n        return NotImplemented\n\n    def __rsub__(self, other: float) -&gt; DualNumber:\n        \"\"\"Obsługuje odejmowanie z liczbą rzeczywistą po lewej stronie.\"\"\"\n        return DualNumber(other - self.real, -self.dual)\n\n    def __mul__(self, other: DualNumber | float) -&gt; DualNumber:\n        \"\"\"Mnoży dwie liczby dualne lub liczbę dualną i liczbę rzeczywistą.\"\"\"\n        if isinstance(other, DualNumber):\n            real_part = self.real * other.real\n            dual_part = (self.real * other.dual) + (self.dual * other.real)\n            return DualNumber(real_part, dual_part)\n        if isinstance(other, int | float):\n            return DualNumber(self.real * other, self.dual * other)\n        return NotImplemented\n\n    def __rmul__(self, other: float) -&gt; DualNumber:\n        \"\"\"Obsługuje mnożenie z liczbą rzeczywistą po lewej stronie.\"\"\"\n        return self * other\n\n    def __truediv__(self, other: DualNumber | float) -&gt; DualNumber:\n        \"\"\"Dzieli dwie liczby dualne lub liczbę dualną i liczbę rzeczywistą.\"\"\"\n        if isinstance(other, DualNumber):\n            if other.real == 0:\n                msg = \"Dzielenie przez zero\"\n                raise ZeroDivisionError(msg)\n            real_part = self.real / other.real\n            dual_part = (self.dual * other.real - self.real * other.dual) / (\n                other.real**2\n            )\n            return DualNumber(real_part, dual_part)\n        if isinstance(other, int | float):\n            if other == 0:\n                msg = \"Dzielenie przez zero\"\n                raise ZeroDivisionError(msg)\n            return DualNumber(self.real / other, self.dual / other)\n        return NotImplemented\n\n    def __rtruediv__(self, other: float) -&gt; DualNumber:\n        \"\"\"Obsługuje dzielenie z liczbą rzeczywistą po lewej stronie.\"\"\"\n        if self.real == 0:\n            msg = \"Dzielenie przez zero\"\n            raise ZeroDivisionError(msg)\n        real_part = other / self.real\n        dual_part = (0 - other * self.dual) / (self.real**2)\n        return DualNumber(real_part, dual_part)\n\n    def __pow__(self, n: float) -&gt; DualNumber:\n        \"\"\"Podnosi liczbę dualną do potęgi n (n jest liczbą całkowitą lub zmiennoprzecinkową).\"\"\"\n        if isinstance(n, int | float):\n            real_part = self.real**n\n            dual_part = n * (self.real ** (n - 1)) * self.dual\n            return DualNumber(real_part, dual_part)\n        return NotImplemented\n\n    def __rpow__(self, other: float) -&gt; DualNumber:\n        \"\"\"Obsługuje przypadek, gdy liczba rzeczywista jest podnoszona do potęgi liczby dualnej.\"\"\"\n        if isinstance(other, int | float):\n            real_part = other**self.real\n            dual_part = real_part * math.log(other) * self.dual\n            return DualNumber(real_part, dual_part)\n        return NotImplemented\n\n    def __neg__(self) -&gt; DualNumber:\n        \"\"\"Zwraca negację liczby dualnej.\"\"\"\n        return DualNumber(-self.real, -self.dual)\n\n    def __eq__(self, other: DualNumber) -&gt; bool:\n        \"\"\"Sprawdza, czy dwie liczby dualne są równe.\"\"\"\n        if isinstance(other, DualNumber):\n            return self.real == other.real and self.dual == other.dual\n        return False\n\n    def __ne__(self, other: DualNumber) -&gt; bool:\n        \"\"\"Sprawdza, czy dwie liczby dualne nie są równe.\"\"\"\n        return not self == other\n\n    def __int__(self) -&gt; int:\n        \"\"\"Konwertuje liczbę dualną na liczbę całkowitą (zwraca część rzeczywistą).\"\"\"\n        return int(self.real)\n\n    def __float__(self) -&gt; float:\n        \"\"\"Konwertuje liczbę dualną na liczbę zmiennoprzecinkową (zwraca część rzeczywistą).\"\"\"\n        return float(self.real)\n\n    @staticmethod\n    def sqrt(z: DualNumber) -&gt; DualNumber:\n        \"\"\"Oblicza pierwiastek kwadratowy z liczby dualnej.\"\"\"\n        if z.real &lt; 0:\n            msg = \"Pierwiastek kwadratowy z ujemnej części rzeczywistej nie jest zdefiniowany dla liczb dualnych w tej implementacji\"\n            raise ValueError(\n                msg,\n            )\n        real_part = math.sqrt(z.real)\n        dual_part = z.dual / (2 * real_part) if real_part != 0 else 0\n        return DualNumber(real_part, dual_part)\n\n    @staticmethod\n    def exp(z: DualNumber) -&gt; DualNumber:\n        \"\"\"Oblicza funkcję wykładniczą liczby dualnej.\"\"\"\n        real_part = math.exp(z.real)\n        dual_part = real_part * z.dual\n        return DualNumber(real_part, dual_part)\n\n    @staticmethod\n    def sin(z: DualNumber) -&gt; DualNumber:\n        \"\"\"Oblicza sinus liczby dualnej.\"\"\"\n        real_part = math.sin(z.real)\n        dual_part = math.cos(z.real) * z.dual\n        return DualNumber(real_part, dual_part)\n\n    @staticmethod\n    def cos(z: DualNumber) -&gt; DualNumber:\n        \"\"\"Oblicza cosinus liczby dualnej.\"\"\"\n        real_part = math.cos(z.real)\n        dual_part = -math.sin(z.real) * z.dual\n        return DualNumber(real_part, dual_part)\n\n\nepsilon = DualNumber(0, 1)  # Nieskończenie mała jednostka epsilon"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-leetcode.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-leetcode.html",
    "title": "LeetCode - zadania programistyczne",
    "section": "",
    "text": "LeetCode to platforma do nauki programowania poprzez rozwiązywanie zadań. Jest to świetne narzędzie do ćwiczenia umiejętności algorytmicznych i przygotowania się do rozmów kwalifikacyjnych.\nIstnieje więcej platform tego typu, ale LeetCode jest jedną z najpopularniejszych i najbardziej rozbudowanych.\nŁatwo znalezć rozwiązania do zadań, a także można korzystać z gotowych rozwiązań innych użytkowników. Warto jednak pamiętać, że celem jest nauka i zrozumienie algorytmów, a nie tylko kopiowanie rozwiązań.\n\n\n\nTwo Sum\nSingle Number\nValid Anagram\nContains Duplicate"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-leetcode.html#leetcode",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-leetcode.html#leetcode",
    "title": "LeetCode - zadania programistyczne",
    "section": "",
    "text": "LeetCode to platforma do nauki programowania poprzez rozwiązywanie zadań. Jest to świetne narzędzie do ćwiczenia umiejętności algorytmicznych i przygotowania się do rozmów kwalifikacyjnych.\nIstnieje więcej platform tego typu, ale LeetCode jest jedną z najpopularniejszych i najbardziej rozbudowanych.\nŁatwo znalezć rozwiązania do zadań, a także można korzystać z gotowych rozwiązań innych użytkowników. Warto jednak pamiętać, że celem jest nauka i zrozumienie algorytmów, a nie tylko kopiowanie rozwiązań.\n\n\n\nTwo Sum\nSingle Number\nValid Anagram\nContains Duplicate"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-env.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-env.html",
    "title": "Zarzadzanie środowiskami",
    "section": "",
    "text": "Wyjaśniliśmy, dlaczego warto używać środowisk wirtualnych. Na labolatoriach korzystamy z anacondy, dla przypomnienia komendy które mogą się przydać:\nNajbardziej waniliowym sposobem na zarządzanie środowiskami jest venv. Wtedy robimy to tak:\nInnymi sposobami na zarządzanie środowiskami są poetry i uv. W szczególności poetry jest bardzo wygodne, uv jest bardziej skomplikowane, ale daje więcej możliwości i jest znacznie szybsze."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-env.html#zadanie",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-env.html#zadanie",
    "title": "Zarzadzanie środowiskami",
    "section": "Zadanie",
    "text": "Zadanie\nWybierz jeden z powyższych sposobów na zarządzanie środowiskami i utwórz środowisko dla tego kursu. Zainstaluj w nim pakiety, które będziemy używać na zajęciach.\n\nrich\nnumpy\npygame\n\nPamiętaj o aktyywowaniu środowiska zarówno w terminalu, jak i w VS Code."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-pythonw.html",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-pythonw.html",
    "title": "Pythonw - tryb oknowy Pythona",
    "section": "",
    "text": "Zarówno python.exe, jak i pythonw.exe to interpretery Pythona, ale działają w nieco inny sposób, szczególnie w kontekście aplikacji graficznych takich jak te pisane w Pygame.\n\npython.exe: Kiedy uruchamiasz skrypt Pythona za pomocą python.exe, otworzy się dodatkowe okno konsoli (cmd), które będzie działać w tle obok okna gry. W tej konsoli będą wyświetlane wszystkie komunikaty print() oraz ewentualne błędy. Dla programisty jest to bardzo przydatne do debugowania, ale dla końcowego użytkownika (czyli grającego w grę) jest to zbędne i może być mylące.\npythonw.exe: Służy do uruchamiania skryptów Pythona, które nie wymagają okna konsoli. Idealnie nadaje się do aplikacji z graficznym interfejsem użytkownika (GUI), takich jak gry Pygame. Kiedy uruchomisz grę za pomocą pythonw.exe, otworzy się tylko okno gry, bez żadnej dodatkowej konsoli. Nie będą wyświetlane żadne komunikaty print(). To sprawia, że gra wygląda i działa bardziej jak “prawdziwa” aplikacja. Dla zasygnalizowania, że skrypt powinien być w trybie często stosuje się rozszerzenie .pyw zamiast .py, ale nie jest to konieczne."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-pythonw.html#python-vs.-pythonw-jaka-jest-różnica",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-pythonw.html#python-vs.-pythonw-jaka-jest-różnica",
    "title": "Pythonw - tryb oknowy Pythona",
    "section": "",
    "text": "Zarówno python.exe, jak i pythonw.exe to interpretery Pythona, ale działają w nieco inny sposób, szczególnie w kontekście aplikacji graficznych takich jak te pisane w Pygame.\n\npython.exe: Kiedy uruchamiasz skrypt Pythona za pomocą python.exe, otworzy się dodatkowe okno konsoli (cmd), które będzie działać w tle obok okna gry. W tej konsoli będą wyświetlane wszystkie komunikaty print() oraz ewentualne błędy. Dla programisty jest to bardzo przydatne do debugowania, ale dla końcowego użytkownika (czyli grającego w grę) jest to zbędne i może być mylące.\npythonw.exe: Służy do uruchamiania skryptów Pythona, które nie wymagają okna konsoli. Idealnie nadaje się do aplikacji z graficznym interfejsem użytkownika (GUI), takich jak gry Pygame. Kiedy uruchomisz grę za pomocą pythonw.exe, otworzy się tylko okno gry, bez żadnej dodatkowej konsoli. Nie będą wyświetlane żadne komunikaty print(). To sprawia, że gra wygląda i działa bardziej jak “prawdziwa” aplikacja. Dla zasygnalizowania, że skrypt powinien być w trybie często stosuje się rozszerzenie .pyw zamiast .py, ale nie jest to konieczne."
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-pythonw.html#tworzenie-skrótu-do-gry-pygame",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-pythonw.html#tworzenie-skrótu-do-gry-pygame",
    "title": "Pythonw - tryb oknowy Pythona",
    "section": "Tworzenie skrótu do gry Pygame",
    "text": "Tworzenie skrótu do gry Pygame\nStworzenie skrótu jest proste i pozwala na uruchomienie gry jednym kliknięciem.\n\nZnajdź plik .py gry: Upewnij się, że wiesz, gdzie jest zapisany główny plik .pyw twojej gry (np. moja_gra.pyw).\nZnajdź pythonw.exe:\n\nNajczęstsza lokalizacja to folder Scripts w katalogu instalacyjnym Pythona. Na przykład: C:\\Users\\bwrob\\AppData\\Local\\Programs\\Python\\Python313\\pythonw.exe (ścieżka może się różnić w zależności od wersji Pythona i sposobu instalacji).\nMożesz też użyć wyszukiwarki plików w Windowsie i poszukać pythonw.exe.\n\nUtwórz nowy skrót:\n\nKliknij prawym przyciskiem myszy na pulpicie (lub w dowolnym innym folderze, gdzie chcesz mieć skrót).\nWybierz “Nowy” &gt; “Skrót”.\n\nWpisz lokalizację elementu: W polu “Wpisz lokalizację elementu:” wpisz następującą ścieżkę, zastępując odpowiednie fragmenty:\n\"C:\\Ścieżka\\Do\\Twojego\\Pythona\\pythonw.exe\" \"C:\\Ścieżka\\Do\\Twojej\\Gry\\moja_gra.py\"\nPamiętaj o cudzysłowach! Są one ważne, jeśli w ścieżkach są spacje.\nPrzykład: Jeśli pythonw.exe jest w C:\\Python\\Python313\\pythonw.exe, a gra moja_gra.py jest w D:\\Gry\\MojaGra\\moja_gra.py, to ścieżka będzie wyglądać tak:\n\"C:\\Python\\Python39\\pythonw.exe\" \"D:\\Gry\\MojaGra\\moja_gra.py\"\nNazwij skrót: Kliknij “Dalej”, a następnie wpisz nazwę dla swojego skrótu (np. “Moja Niesamowita Gra”).\nZakończ: Kliknij “Zakończ”. Teraz masz działający skrót do swojej gry!"
  },
  {
    "objectID": "pages/courses/pwr-programming-2025/pwr-programming-2025-pythonw.html#ustawianie-własnej-ikony-dla-skrótu",
    "href": "pages/courses/pwr-programming-2025/pwr-programming-2025-pythonw.html#ustawianie-własnej-ikony-dla-skrótu",
    "title": "Pythonw - tryb oknowy Pythona",
    "section": "Ustawianie własnej ikony dla skrótu",
    "text": "Ustawianie własnej ikony dla skrótu\nStandardowa ikona skrótu Pythona nie jest zbyt atrakcyjna dla gry. Możesz ustawić własną ikonę, co sprawi, że skrót będzie wyglądał znacznie lepiej.\n\nPrzygotuj plik ikony: Potrzebujesz pliku z ikoną w formacie .ico. Jeśli masz obrazek (np. .png lub .jpg), możesz go łatwo przekonwertować na .ico za pomocą darmowych narzędzi online (np. ICO Converter, Favicon.io). Upewnij się, że ikona ma dobrą rozdzielczość (np. 256x256 pikseli).\nLokalizacja pliku ikony: Umieść plik .ico w bezpiecznym miejscu, najlepiej w folderze z grą lub w osobnym folderze ikony w katalogu projektu, aby nie został przypadkowo usunięty.\nZmień ikonę skrótu:\n\nKliknij prawym przyciskiem myszy na nowo utworzonym skrócie.\nWybierz “Właściwości”.\nW zakładce “Skrót” kliknij przycisk “Zmień ikonę…”.\nPojawi się okno. Kliknij “Przeglądaj…” i znajdź swój plik .ico.\nWybierz plik .ico i kliknij “Otwórz”, a następnie “OK” w oknie “Zmień ikonę” i ponownie “OK” w oknie “Właściwości”."
  }
]