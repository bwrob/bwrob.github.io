---
title: "Strategies for Numerical Integration"
description: "How to apply strategy design pattern to decouple integration problem from method it's solved with."
author: "bwrob"

date: "2024-04-28"

categories: [Pythonic Distractions, Patterns]

draft: true
---


## Numerical integration

Calculation of many financial methods or metrics rely on a mathematical tool called numerical integration. In simple terms, numerical integration takes a function that represents a continuous process (like the changing value of an investment over time) and approximates the area under its curve. This area can then be used to calculate important quantities, like the total return of the investment or price of a derivative instrument.

For quantitative analysts, the choice of the integration method matters. Different integration schemes offer varying levels of accuracy and efficiency. Unfortunatlelly there's no 'best technique'. Same algorithm can be perfect for problems with certain characteristics, but unusable for others. And then there is the old as time performance vs. accuracy trade-off.

As programmers working in finance, we need to be adaptable and leverage solutions that allow us to switch between these methods seamlessly.


## Design patterns

This is where design patterns come in. Design patterns are reusable solutions to common programming problems. The widespread adoption of design patterns in software development is largely attributed to the publication of the book [Design Patterns: Elements of Reusable Object-Oriented Software](https://www.oreilly.com/library/view/design-patterns-elements/0201633612/) in 1994. Authored by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (often referred to as the "Gang of Four" or GoF), this book cataloged 23 essential software design patterns. These patterns provided solutions to common design problems in object-oriented programming, promoting code reusability, maintainability, and flexibility.

Some design patterns can feel clunky or inelegant when implemented in Python. The language itself often has built-in features or idioms that achieve the same result in a more Pythonic way (meaning it follows Python's style and conventions). Sometimes, design patterns can be seen as overcomplicating simple problems. On the other hand, usage of well-known and understood patterns may enhance your engineering skills and imove code readability. 

Ultimately, the decision of whether or not to use design patterns in Python depends on the specific context of your project and your coding style. There's no right or wrong answer. But you first need to know the classics to diss the classics.


## Strategy pattern

In this blog post, we'll explore how the Strategy Design Pattern (*SDP*) can be used to create a flexible and maintainable numerical integrator that works with different integration schemes. We want to 

I will show you this patter through example, if you prefer more generic setup see Refactoring Guru's [implementation](https://refactoring.guru/design-patterns/strategy/python/example).


## Abstract schema:

```{python}
from abc import ABC, abstractmethod
from typing import Callable

class IntegrationSchema(ABC):
    """Abstract base class for integration schemas."""

    @abstractmethod
    def integrate(
        self,
        integrand: Callable[[float], float],
        *,
        start: float,
        end: float,
    ) -> float:
        """Abstract method for integrating a function."""
```

## Integrator

```{python}
"""An integrator class that allows to perform integration using different schemas."""
from typing import Callable

class Integrator:
    """An integrator class that allows to perform integration using different
    schemas as strategies."""

    def __init__(
        self,
        integrand: Callable[[float], float],
        interval_start: float,
        interval_end: float,
    ) -> None:
        """Initializes the integrator class."""
        if interval_start >= interval_end:
            raise ValueError("Start value must be less than end value.")
        self.__integrand = integrand
        self.__interval_start = interval_start
        self.__interval_end = interval_end

    def __call__(
        self,
        schema: IntegrationSchema,
    ) -> float:
        """
        Calculates the definite integral value of a function.

        Args:
            schema: integration schema
        """
        print(f"Using {schema}.")
        return schema.integrate(
            self.__integrand,
            start=self.__interval_start,
            end=self.__interval_end,
        )
```



## Concrete schema implementations

### Rectangle Rule

```{python}
from typing import Optional

import numpy as np

class RectangleSchema(IntegrationSchema):
    """Schema for rectangle integration."""

    def __init__(
        self,
        steps: int,
    ) -> None:
        """Initializes the rectangle integration config."""
        if steps <= 0:
            raise ValueError("Steps must be greater than 0.")
        self.__steps = steps

    def __str__(self) -> str:
        """Returns the string representation of the schema."""
        return f"Rectangle schema with {self.__steps} steps."

    def integrate(
        self,
        integrand: Callable[[float], float],
        *,
        start: float,
        end: float,
    ) -> float:
        """Integrates a function using rectangle integration."""
        x_points = np.linspace(start, end, self.__steps)
        values = integrand(x_points)
        dx = (end - start) / np.float64(self.__steps)
        return np.sum(values) * dx
```

### Simple Monte Carlo

```{python}
class MonteCarloSchema(IntegrationSchema):
    """Schema for Monte Carlo integration."""

    def __init__(
        self,
        random_points: int,
        random_seed: Optional[int] = None,
    ) -> None:
        """Initializes the rectangle integration config."""
        if random_points <= 0:
            raise ValueError("Points must be greater than 0.")
        self.__random_points = random_points
        self.__random_seed = random_seed

    def __str__(self) -> str:
        """Returns the string representation of the schema."""
        points_msg = f"Monte Carlo schema with {self.__random_points} random points"
        seed_msg = f" and seed {self.__random_seed}" if self.__random_seed else ""
        return f"{points_msg}{seed_msg}."

    def integrate(
        self,
        integrand: Callable[[float], float],
        *,
        start: float,
        end: float,
    ) -> float:
        """Integrates a function using Monte Carlo integration."""
        np.random.seed(seed=self.__random_seed)
        x_points = np.random.uniform(start, end, self.__random_points)
        values = integrand(x_points)
        average_dx = (end - start) / np.float64(self.__random_points)
        return np.sum(values) * average_dx
```


## Let's integrate!

Ok, now to the integrating. Let's set up the scene.

```{python}
start, end = 0, np.pi / 2.0

def f(x: float) -> float:
    return np.sin(x) + np.cos(x)
```

Excited? Don't be... The performance and convergence of those schemas is gonna be terrible. Like anything in Python, if you want robust and performant code you need to implement it with C or use any/all of the enhancement frameworks that Python provides (see Numba). Additionally, the simple methods we implemented are very na√Øve. The standard numerical packages use sophisticated algorithms honed for many decades.

Maybe then we should get some benchmark value first. As none of us would bother to integrate this by hand, we'll use SciPy. Unexpectedly (SciPy uses C and Fortran underneath), we get the result in a breeze and it is very close to actual value of 2.0.

```{python}
from scipy.integrate import quad

scipy_quad, err = quad(f, start, end)
print(scipy_quad)
```

Now, lets use our `Integrator` class and see

```{python}
integrator = Integrator(
    f,
    interval_start=start,
    interval_end=end,
)

iterations = [2**i for i in range(0,21,5)]
rectangle_results = [integrator(RectangleSchema(steps=i)) for i in iterations]
mc_results = [integrator(MonteCarloSchema(random_points=i)) for i in iterations]

print(f"Rectangle schema results:\n{rectangle_results}.")
print(f"Monte Carlo schema results:\n{mc_results}.")
```

But I was wrong! You *should* be excited! We just learned new approach for setting up extensible and readable code! Look how cleanly the pproblem statement is separated form approaches to solve it.

If you are now wondering how much we could improve by using more advanced technique (like [stratified Monte Carlo](http://proceedings.mlr.press/v28/carpentier13.pdf) or [adaptive quadrature](https://www.wikiwand.com/en/Adaptive_quadrature)) you just need to implement new subclass of \`IntegrationSchema' and you're done. No changes to the existing code are need, just simple extension. And that's the idea behind strategy pattern.