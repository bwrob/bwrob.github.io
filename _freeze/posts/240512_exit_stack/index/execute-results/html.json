{
  "hash": "7918ded044f785e356915f60ae75e994",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Exit stack to the rescue\"\ndescription: \"How to chain resource managers in elegant way.\"\nauthor: \"bwrob\"\n\ndate: \"2024-05-12\"\n\ncategories: [Pythonic Distractions, Context Managers]\n\nimage: python_mug.png\n\nformat-links: [html]\n---\n\n## Working with risk managment systems\n\nAs a quantitative finance professional you'll often find yourself with risk management systems (RMS). RMS's are extensive frameworks that let you properly define a book (portfolio) of your financial transactions and run varia of pricing and risk analysis on it. For big financial players, like investment banks, the RMS will be internal proprietary framework that is run in-house. For smaller enterprises or second-line reporting it's not feasable to tackle creating such vast framework. Hence, where there's a need, someone will try to make money on it. This leads us to third-party (or vendor) RMS, of which there are plenty (ex. Murex, Acadia).\n\nWorking with vendor RMS, especially one that covers computations for you, entails juggling multiple resources to obtain your risk metrics. Defining OTC products, benchmarks, portfolios, and running risk analysis can involve numerous API calls, each requiring proper setup and cleanup. This can lead to messy code and potential errors or performance bottlenecks if resources aren't handled correctly.\n\nThankfully, Python provides a powerful concept called context managers (**CM**) that streamline resource managment. True to the language's 'batteries included' philosophy, there's also a `contextlib` library that contains variety of tools for easing up your work with CMs. Today we'll look at a (mock-up) usage of `ExitStack` class in real-life scenario of running risk analysis on RMS. If you need a refresher on CMs, check out this [tutorial](https://realpython.com/python-with-statement/) by RealPython.\n\n## Setting the stage\n\nTo run an analysis, the RMS first needs to know what our positions are. In case of tradable assets it's simple --- we provide a market identifier and how much of the instrument we are holding. What do we do if we have some bespoke agreement with specific counterparty (an over-the-counter transaction)? We will need to define it from scratch in the RMS using data from the term sheet (assuming this kind of agreement is covered).\n\nNext, we need to specify the risk metrics we want to calculate --- define the analysis scope. Let's say we hold some equity options and we are intertested in their deltas and beta exposures. The betas are defined with respect to some benchmark --- ex. portfolio holding 1 stock in US500 ETF. So we define the benchmark and link it to our analysis.\n\nFinally --- once portfolio and analysis are defined in RMS --- we call the API to start the calculation and respond with results. This is the control flow we execute to get to this point:\n\n\n```{mermaid}\nflowchart LR\n  A[OTC Products] --> B[Portfolio]\n  B --> C{Analysis Run}\n  D[Benchmarks] --> E[Analysis Definition]\n  E --> C\n  C --> F(Results)\n```\n\n\nIf we know we're never going to use all of the resources, we should clean up the server artifacts after receving the results. So for each resource we should have a CM.\n\n### Mock functions\n\nThe setup described above comes from a real-life situation I worked through. I can't show you the actual API usage or data (or even the name of RMS itself), so we need to define some mocker functions. Mocks like this are actually not an uncommon thing --- such approach is prevalent in testing API client code. In our case it would look like this:\n\n::: {#de718061 .cell execution_count=1}\n``` {.python .cell-code}\nfrom enum import StrEnum\nfrom uuid import uuid4\n\n\nclass MockObject(StrEnum):\n    \"\"\"Types of mock objects.\"\"\"\n\n    ANALYSIS = \"analysis\"\n    BENCHMARK = \"benchmark\"\n    OTC_PRODUCTS = \"otc_products\"\n    PORTFOLIO = \"portfolio\"\n\n\ndef mock_object(object_type: MockObject) -> str:\n    \"\"\"Mock a UUID for a given object type.\n\n    Args:\n        object_type: Type of object.\n    \"\"\"\n    return f\"{object_type}_{uuid4()}\"\n\n\ndef mock_preparation(object_type: MockObject, **kwargs) -> None:\n    \"\"\"Mock preparation of an object.\n\n    Args:\n        object_type: Type of object.\n    \"\"\"\n    print(f\"Preparing {object_type}\" + (f\" using {kwargs}\" if kwargs else \".\"))\n\n\ndef mock_clean_up(object_uuid: str) -> None:\n    \"\"\"Mock clean up of an object.\n\n    Args:\n        object_uuid: Uuid of the object.\n    \"\"\"\n    print(f\"Cleaning up after {object_uuid}.\")\n```\n:::\n\n\nFor each of the four types of resources we mock the preparation, object (ex. API response, some id of definition on server) and the clean up process.\n\n### Context managers\n\nEasiest way to define a CM is through `contextlib.contextmanager` decorator. To use it, you need a function that returns a generator. Code executed on enter should come before `yield` statement and the one for the exit afterwards. The generator yields the result of the CM (ex. handle to an opened file), the `y` in `with x(*args) as y:`.\n\n::: {#202b286e .cell execution_count=2}\n``` {.python .cell-code}\nfrom contextlib import contextmanager\nfrom typing import Generator\n\n@contextmanager\ndef analysis(\n    *,\n    benchmark_uuid: str,\n) -> Generator[str, None, None]:\n    \"\"\"Mock definition of an analysis.\n\n    Example: equity delta and correlation with benchmark.\n\n    Args:\n        benchmark_uuid: Uuid of the benchmark.\n    \"\"\"\n    mock_preparation(\n        MockObject.ANALYSIS,\n        benchmark_name=benchmark_uuid,\n    )\n    analysis_uuid = mock_object(MockObject.ANALYSIS)\n    yield analysis_uuid\n    mock_clean_up(analysis_uuid)\n```\n:::\n\n\nModern approach to Python development leans heavily towards type annotations. Dynamical typing is powerful but can lead to unwieldy code. To properly annotate the `analysis` function we need to import `Generator` from `typing` module. Remember, the `@contextmanager` decorator takes the function and turns it into CM --- a class with `__enter__` and `__exit__` methods. The `Generator` needs three inputs but in our case only the first one is important --- `YieldType`, here `str` ([see](https://docs.python.org/3/library/typing.html#typing.Generator) for more).\n\nWith this done implementing the 3 remaining CMs is easy, just remember our flow chart.\n\n::: {#c5b2c0e8 .cell execution_count=3}\n``` {.python .cell-code}\n@contextmanager\ndef benchmark() -> Generator[str, None, None]:\n    \"\"\"Mock definition of a benchmark.\n\n    Args:\n        otc_products_uuid: Uuid of the otc products.\n    \"\"\"\n    mock_preparation(\n        MockObject.BENCHMARK,\n    )\n    benchmark_uuid = mock_object(MockObject.BENCHMARK)\n    yield benchmark_uuid\n    mock_clean_up(benchmark_uuid)\n\n\n@contextmanager\ndef otc_products() -> Generator[str, None, None]:\n    \"\"\"Mock definition of an otc products.\n\n    Args:\n        otc_products_uuid: Uuid of the otc products.\n    \"\"\"\n    mock_preparation(MockObject.OTC_PRODUCTS)\n    otcs_uuid = mock_object(MockObject.OTC_PRODUCTS)\n    yield otcs_uuid\n    mock_clean_up(otcs_uuid)\n\n\n@contextmanager\ndef portfolio(\n    *,\n    portfolio_name: str,\n    otc_products_uuid: str,\n) -> Generator[str, None, None]:\n    \"\"\"Mock definition of a portfolio.\n\n    Args:\n        otc_products_uuid: Uuid of the otc products.\n    \"\"\"\n    mock_preparation(\n        MockObject.PORTFOLIO,\n        portfolio_name=portfolio_name,\n        otc_products_uuid=otc_products_uuid,\n    )\n    portfolio_uuid = mock_object(MockObject.PORTFOLIO)\n    yield portfolio_uuid\n    mock_clean_up(portfolio_uuid)\n```\n:::\n\n\n### Analysis results\n\nNo stress or complexity here, to run the analysis we need to specify which analysis to run on which portfolio.\n\n::: {#be16d4ea .cell execution_count=4}\n``` {.python .cell-code}\nimport pandas as pd\n\ndef analysis_results(\n    *,\n    analysis_uuid: str,\n    portfolio_uuid: str,\n) -> pd.DataFrame:\n    \"\"\"Mock running the analysis on a given portfolio.\n\n    Returns empty dataframe.\n\n    Args:\n        analysis_uuid: Uuid of the analysis.\n        portfolio_uuid: Uuid of the portfolio.\n    \"\"\"\n    print(f\"Running analysis {analysis_uuid} on portfolio {portfolio_uuid}.\")\n    return pd.DataFrame()\n```\n:::\n\n\n## \n\nFinally, we can run some (mock) risk analysis!\n\n### Using contexts directly\n\nFirst, we use the managers directly through `with` clause, remembering the dependencies from our flow chart.\n\n::: {#7a23ac97 .cell execution_count=5}\n``` {.python .cell-code}\nPORTFOLIO = \"portfolio_1\"\n\ndef run_analysis() -> pd.DataFrame:\n    \"\"\"Mock running the analysis using with clauses.\"\"\"\n    with otc_products() as otc_uuid:\n        with benchmark() as benchmark_uuid:\n            with portfolio(\n                portfolio_name=PORTFOLIO,\n                otc_products_uuid=otc_uuid,\n            ) as portfolio_uuid:\n                with analysis(\n                    benchmark_uuid=benchmark_uuid,\n                ) as analysis_uuid:\n                    results = analysis_results(\n                        analysis_uuid=analysis_uuid,\n                        portfolio_uuid=portfolio_uuid,\n                    )\n    return results\n```\n:::\n\n\nThis is terrible! I am already getting lost, needed few tries to get it right. We ended up with **6** levels of indentation, the code is confusing, the flow is obtuse. Let's run it either way, to see if at least works.\n\n::: {#cf0b1144 .cell execution_count=6}\n``` {.python .cell-code}\ndef print_title(title: str) -> None:\n    \"\"\"Print a title padded, surrounded by dashes and empty lines.\"\"\"\n    print(\"\\n\" + title.center(60, \"-\") + \"\\n\")\n\nprint_title(\"Running analysis.\")\nrun_analysis()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n---------------------Running analysis.----------------------\n\nPreparing otc_products.\nPreparing benchmark.\nPreparing portfolio using {'portfolio_name': 'portfolio_1', 'otc_products_uuid': 'otc_products_efee9e27-df10-4b7a-b216-30eac8f23552'}\nPreparing analysis using {'benchmark_name': 'benchmark_97535feb-98ba-4743-89df-e557bb2ec4b2'}\nRunning analysis analysis_eb8d3739-aa80-40b8-8625-8b007ad8cf15 on portfolio portfolio_6a74190c-e653-4026-afa1-bcacab59be81.\nCleaning up after analysis_eb8d3739-aa80-40b8-8625-8b007ad8cf15.\nCleaning up after portfolio_6a74190c-e653-4026-afa1-bcacab59be81.\nCleaning up after benchmark_97535feb-98ba-4743-89df-e557bb2ec4b2.\nCleaning up after otc_products_efee9e27-df10-4b7a-b216-30eac8f23552.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nGreat, the behaviour is as expected, everything is cleaned after nicely. We achieved the goal but the code is unmaintainable. Looks like a subject of the joke *\"good code makes your job safe for a day, but terrible code in production makes it safe for a lifetime\"*. Being reckless and with no regard to job security as we are, we'll fix it.\n\n*I can clearly recall the most unamanagable and unreadable code I've seen in my career and the culprit was fired in the end. Different reasons, long time later, but still. So the joke is just a joke, don't rely on a bad code as your job insurance.*\n\n## The ExitStack\n\nHere comes in the MVP --- `ExitStack` from `contextlib`, made for streamlining complex context managment situationships. Conceptually it's just a First-In-Last-Out (FILO) stack. You put CMs on top, one by one. When CM is pushed to stack, its `__enter__` method is called and you can intercept the result. ExitStack is a CM itself, it's `__exit__` method is just calling the exits of CMs in reverse order.\n\n\n```{mermaid}\nflowchart LR\n    A(Enter CM A) ---> B(Enter CM B)\n    B ---> C(Enter CM C)\n    C ---> D[Do stuff]\n    D ---> E(Exit CM C)\n    E ---> F(Exit CM B)\n    F ---> G(Exit CM A)\n    A -.- G\n    B -.- F\n    C -.- E\n\n```\n\n\nSo the flow is exactly the same as in our first attempt. Let's try it!\n\n::: {#364e06c0 .cell execution_count=7}\n``` {.python .cell-code}\nfrom contextlib import ExitStack\n\ndef run_analysis_with_exit_stack() -> None:\n    \"\"\"Mock running the analysis using exit stack.\"\"\"\n    with ExitStack() as stack:\n        otc_uuid = stack.enter_context(otc_products())\n        benchmark_uuid = stack.enter_context(benchmark())\n        portfolio_uuid = stack.enter_context(\n            portfolio(\n                portfolio_name=PORTFOLIO,\n                otc_products_uuid=otc_uuid,\n            )\n        )\n        analysis_uuid = stack.enter_context(\n            analysis(\n                benchmark_uuid=benchmark_uuid,\n            )\n        )\n        results = analysis_results(\n            analysis_uuid=analysis_uuid,\n            portfolio_uuid=portfolio_uuid,\n        )\n```\n:::\n\n\nThat's amazing (if the approach works)! In our code we end up with only single `with` clause and the outputs of CMs are defined just like the regular variables. We just need to wrap the CM calls in `stack.enter_context` method that pushes each CM to the stack.\n\n::: {#ae14d46b .cell execution_count=8}\n``` {.python .cell-code}\nprint_title(\"Running analysis with exit stack.\")\nrun_analysis_with_exit_stack()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n-------------Running analysis with exit stack.--------------\n\nPreparing otc_products.\nPreparing benchmark.\nPreparing portfolio using {'portfolio_name': 'portfolio_1', 'otc_products_uuid': 'otc_products_a60a51c2-f781-4fcb-8519-45e7180d27b9'}\nPreparing analysis using {'benchmark_name': 'benchmark_a48e3d24-8c6d-4a23-9d17-84336834cde1'}\nRunning analysis analysis_67744945-e773-47d0-b53a-09067fa2ace7 on portfolio portfolio_26e809af-3f36-485a-954f-7873629ea000.\nCleaning up after analysis_67744945-e773-47d0-b53a-09067fa2ace7.\nCleaning up after portfolio_26e809af-3f36-485a-954f-7873629ea000.\nCleaning up after benchmark_a48e3d24-8c6d-4a23-9d17-84336834cde1.\nCleaning up after otc_products_a60a51c2-f781-4fcb-8519-45e7180d27b9.\n```\n:::\n:::\n\n\nIt works as well! We also get a package of benefits for free.\n\n### Disabling the clean up\n\nWorking with API is tricky and debugging could be a painful experience. If we notice something iffy with the results we are reciving, it could be due to a bug at any of the stages. In such case disabling the artifact clean up and examining them is a good way to investigate. How do we do that? Comment out the exit code in our resource CMs? Nope, now we know better. With exit stack approach we just need to clean up the stack before exiting its context.\n\n::: {#50de0a90 .cell execution_count=9}\n``` {.python .cell-code}\ndef run_analysis_with_exit_stack(\n    clean_up: bool = True,\n) -> None:\n    \"\"\"Mock running the analysis using exit stack.\n\n    Args:\n        clean_up: Whether to clean up after the objects.\n    \"\"\"\n\n    with ExitStack() as stack:\n        otc_uuid = stack.enter_context(otc_products())\n        benchmark_uuid = stack.enter_context(benchmark())\n        portfolio_uuid = stack.enter_context(\n            portfolio(\n                portfolio_name=PORTFOLIO,\n                otc_products_uuid=otc_uuid,\n            )\n        )\n        analysis_uuid = stack.enter_context(\n            analysis(\n                benchmark_uuid=benchmark_uuid,\n            )\n        )\n        results = analysis_results(\n            analysis_uuid=analysis_uuid,\n            portfolio_uuid=portfolio_uuid,\n        )\n\n        if not clean_up:\n            _ = stack.pop_all()\n    return results\n```\n:::\n\n\nThe `_ = some_function()` is a Pythonic way of disregarding outputs of `some_function`. Method `pop_all` actually moves the stack contents to a new stack, but we don't care about that. We just want to get rid of them from our current one.\n\n::: {#819d11f9 .cell execution_count=10}\n``` {.python .cell-code}\nprint_title(\"Running analysis with exit stack and no clean up.\")\nrun_analysis_with_exit_stack(clean_up=False)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n-----Running analysis with exit stack and no clean up.------\n\nPreparing otc_products.\nPreparing benchmark.\nPreparing portfolio using {'portfolio_name': 'portfolio_1', 'otc_products_uuid': 'otc_products_c75232c1-3926-40d5-a78d-3955cb30c636'}\nPreparing analysis using {'benchmark_name': 'benchmark_92a42f15-910d-416d-b5b5-635613b7e52d'}\nRunning analysis analysis_caa32677-722e-4899-9ea1-77896be0e45a on portfolio portfolio_ee4f418d-6e3c-46a8-922a-a024eb403d52.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Multiple portfolios\n\nBenefit #2 --- what do we do if we have multiple managers and many portfolios to re-run for? Or --- outside of the example scope --- we want to held multiple files open at the same time? Easy, we just push to the stack in a loop or a list comprehension.\n\n::: {#bf658f3c .cell execution_count=11}\n``` {.python .cell-code}\nPORTFOLIOS = [\"portfolio_1\", \"portfolio_2\", \"portfolio_3\"]\n\ndef run_analysis_with_exit_stack(clean_up: bool = True):\n    \"\"\"Mock running the analysis for multiple portfolios using exit stack.\n\n    Args:\n        clean_up: Whether to clean up after the objects.\n    \"\"\"\n    with ExitStack() as stack:\n        otc_uuid = stack.enter_context(otc_products())\n        benchmark_uuid = stack.enter_context(benchmark())\n        portfolio_uuids = [\n            stack.enter_context(\n                portfolio(\n                    portfolio_name=portfolio_name,\n                    otc_products_uuid=otc_uuid,\n                )\n            )\n            for portfolio_name in PORTFOLIOS\n        ]\n        analysis_uuid = stack.enter_context(\n            analysis(\n                benchmark_uuid=benchmark_uuid,\n            )\n        )\n        result_parts = [\n            analysis_results(\n                analysis_uuid=analysis_uuid,\n                portfolio_uuid=portfolio_uuid,\n            )\n            for portfolio_uuid in portfolio_uuids\n        ]\n        results = pd.concat(result_parts)\n\n        if not clean_up:\n            _ = stack.pop_all()\n    return results\n\nprint_title(\"Running analysis with exit stack on multiple portfolios.\")\nrun_analysis_with_exit_stack(clean_up=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n--Running analysis with exit stack on multiple portfolios.--\n\nPreparing otc_products.\nPreparing benchmark.\nPreparing portfolio using {'portfolio_name': 'portfolio_1', 'otc_products_uuid': 'otc_products_7af52ed6-6dec-4df1-a6f0-793bb238df4f'}\nPreparing portfolio using {'portfolio_name': 'portfolio_2', 'otc_products_uuid': 'otc_products_7af52ed6-6dec-4df1-a6f0-793bb238df4f'}\nPreparing portfolio using {'portfolio_name': 'portfolio_3', 'otc_products_uuid': 'otc_products_7af52ed6-6dec-4df1-a6f0-793bb238df4f'}\nPreparing analysis using {'benchmark_name': 'benchmark_c0c5e514-a2ba-46c9-874e-dcf2f26185d5'}\nRunning analysis analysis_5f57869b-acc5-4dad-9149-a81ad387c6e1 on portfolio portfolio_f75c0169-0836-481d-9d7a-0d81b2e2e40f.\nRunning analysis analysis_5f57869b-acc5-4dad-9149-a81ad387c6e1 on portfolio portfolio_bfc180f6-66bf-471d-9f3e-5724bc29869d.\nRunning analysis analysis_5f57869b-acc5-4dad-9149-a81ad387c6e1 on portfolio portfolio_7a0b68ba-e847-4c26-8861-a6ede738d4b2.\nCleaning up after analysis_5f57869b-acc5-4dad-9149-a81ad387c6e1.\nCleaning up after portfolio_7a0b68ba-e847-4c26-8861-a6ede738d4b2.\nCleaning up after portfolio_bfc180f6-66bf-471d-9f3e-5724bc29869d.\nCleaning up after portfolio_f75c0169-0836-481d-9d7a-0d81b2e2e40f.\nCleaning up after benchmark_c0c5e514-a2ba-46c9-874e-dcf2f26185d5.\nCleaning up after otc_products_7af52ed6-6dec-4df1-a6f0-793bb238df4f.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=33}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Conclusion\n\nToday we've learnt a new Python tool and seen an example of how quantitative developer might set up risk reporting job on vendor RMS. Sound like a very niche and unlikely situation for you? Maybe. But the moral here is to go and explore the Python standard library. Without using any additional packages we improved readability and flexibility of our initial attempt. Python really has *'batteries included'*, [see](https://docs.python.org/3/library/index.html) for yourself!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}