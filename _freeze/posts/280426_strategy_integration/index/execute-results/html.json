{
  "hash": "adbf3065e35a9883352b1f81038e9f7b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Strategies for Numerical Integration\"\ndescription: \"How to apply strategy design pattern to decouple integration problem from method it's solved with.\"\nauthor: \"bwrob\"\n\ndate: \"2024-04-28\"\n\ncategories: [Pythonic Distractions, Patterns]\n\ndraft: true\n---\n\n## Numerical integration\n\nCalculation of many financial methods or metrics rely on a mathematical tool called numerical integration. In simple terms, numerical integration takes a function that represents a continuous process (like the changing value of an investment over time) and approximates the area under its curve. This area can then be used to calculate important quantities, like the total return of the investment or price of a derivative instrument.\n\nFor quantitative analysts, the choice of the integration method matters. Different integration schemes offer varying levels of accuracy and efficiency. Unfortunatlelly there's no 'best technique'. Same algorithm can be perfect for problems with certain characteristics, but unusable for others. And then there is the old as time performance vs. accuracy trade-off.\n\nAs programmers working in finance, we need to be adaptable and leverage solutions that allow us to switch between these methods seamlessly.\n\n\n## Design patterns\n\nThis is where design patterns come in. Design patterns are reusable solutions to common programming problems. The widespread adoption of design patterns in software development is largely attributed to the publication of the book [Design Patterns: Elements of Reusable Object-Oriented Software](https://www.oreilly.com/library/view/design-patterns-elements/0201633612/) in 1994. Authored by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (often referred to as the \"Gang of Four\" or GoF), this book cataloged 23 essential software design patterns. These patterns provided solutions to common design problems in object-oriented programming, promoting code reusability, maintainability, and flexibility.\n\nSome design patterns can feel clunky or inelegant when implemented in Python. The language itself often has built-in features or idioms that achieve the same result in a more Pythonic way (meaning it follows Python's style and conventions). Sometimes, design patterns can be seen as overcomplicating simple problems. On the other hand, usage of well-known and understood patterns may enhance your engineering skills and imove code readability. \n\nUltimately, the decision of whether or not to use design patterns in Python depends on the specific context of your project and your coding style. There's no right or wrong answer. But you first need to know the classics to diss the classics.\n\n\n## Strategy pattern\n\nIn this blog post, we'll explore how the Strategy Design Pattern (*SDP*) can be used to create a flexible and maintainable numerical integrator that works with different integration schemes. We want to \n\nI will show you this patter through example, if you prefer more generic setup see Refactoring Guru's [implementation](https://refactoring.guru/design-patterns/strategy/python/example).\n\n\n## Abstract schema:\n\n::: {#a73b37c6 .cell execution_count=1}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\nfrom typing import Callable\n\nclass IntegrationSchema(ABC):\n    \"\"\"Abstract base class for integration schemas.\"\"\"\n\n    @abstractmethod\n    def integrate(\n        self,\n        integrand: Callable[[float], float],\n        *,\n        start: float,\n        end: float,\n    ) -> float:\n        \"\"\"Abstract method for integrating a function.\"\"\"\n```\n:::\n\n\n## Integrator\n\n::: {#6c266b94 .cell execution_count=2}\n``` {.python .cell-code}\n\"\"\"An integrator class that allows to perform integration using different schemas.\"\"\"\nfrom typing import Callable\n\nclass Integrator:\n    \"\"\"An integrator class that allows to perform integration using different\n    schemas as strategies.\"\"\"\n\n    def __init__(\n        self,\n        integrand: Callable[[float], float],\n        interval_start: float,\n        interval_end: float,\n    ) -> None:\n        \"\"\"Initializes the integrator class.\"\"\"\n        if interval_start >= interval_end:\n            raise ValueError(\"Start value must be less than end value.\")\n        self.__integrand = integrand\n        self.__interval_start = interval_start\n        self.__interval_end = interval_end\n\n    def __call__(\n        self,\n        schema: IntegrationSchema,\n    ) -> float:\n        \"\"\"\n        Calculates the definite integral value of a function.\n\n        Args:\n            schema: integration schema\n        \"\"\"\n        print(f\"Using {schema}.\")\n        return schema.integrate(\n            self.__integrand,\n            start=self.__interval_start,\n            end=self.__interval_end,\n        )\n```\n:::\n\n\n## Concrete schema implementations\n\n### Rectangle Rule\n\n::: {#b1874849 .cell execution_count=3}\n``` {.python .cell-code}\nfrom typing import Optional\n\nimport numpy as np\n\nclass RectangleSchema(IntegrationSchema):\n    \"\"\"Schema for rectangle integration.\"\"\"\n\n    def __init__(\n        self,\n        steps: int,\n    ) -> None:\n        \"\"\"Initializes the rectangle integration config.\"\"\"\n        if steps <= 0:\n            raise ValueError(\"Steps must be greater than 0.\")\n        self.__steps = steps\n\n    def __str__(self) -> str:\n        \"\"\"Returns the string representation of the schema.\"\"\"\n        return f\"Rectangle schema with {self.__steps} steps.\"\n\n    def integrate(\n        self,\n        integrand: Callable[[float], float],\n        *,\n        start: float,\n        end: float,\n    ) -> float:\n        \"\"\"Integrates a function using rectangle integration.\"\"\"\n        x_points = np.linspace(start, end, self.__steps)\n        values = integrand(x_points)\n        dx = (end - start) / np.float64(self.__steps)\n        return np.sum(values) * dx\n```\n:::\n\n\n### Simple Monte Carlo\n\n::: {#e0c6841d .cell execution_count=4}\n``` {.python .cell-code}\nclass MonteCarloSchema(IntegrationSchema):\n    \"\"\"Schema for Monte Carlo integration.\"\"\"\n\n    def __init__(\n        self,\n        random_points: int,\n        random_seed: Optional[int] = None,\n    ) -> None:\n        \"\"\"Initializes the rectangle integration config.\"\"\"\n        if random_points <= 0:\n            raise ValueError(\"Points must be greater than 0.\")\n        self.__random_points = random_points\n        self.__random_seed = random_seed\n\n    def __str__(self) -> str:\n        \"\"\"Returns the string representation of the schema.\"\"\"\n        points_msg = f\"Monte Carlo schema with {self.__random_points} random points\"\n        seed_msg = f\" and seed {self.__random_seed}\" if self.__random_seed else \"\"\n        return f\"{points_msg}{seed_msg}.\"\n\n    def integrate(\n        self,\n        integrand: Callable[[float], float],\n        *,\n        start: float,\n        end: float,\n    ) -> float:\n        \"\"\"Integrates a function using Monte Carlo integration.\"\"\"\n        np.random.seed(seed=self.__random_seed)\n        x_points = np.random.uniform(start, end, self.__random_points)\n        values = integrand(x_points)\n        average_dx = (end - start) / np.float64(self.__random_points)\n        return np.sum(values) * average_dx\n```\n:::\n\n\n## Let's integrate!\n\nOk, now to the integrating. Let's set up the scene.\n\n::: {#ba43c477 .cell execution_count=5}\n``` {.python .cell-code}\nstart, end = 0, np.pi / 2.0\n\ndef f(x: float) -> float:\n    return np.sin(x) + np.cos(x)\n```\n:::\n\n\nExcited? Don't be... The performance and convergence of those schemas is gonna be terrible. Like anything in Python, if you want robust and performant code you need to implement it with C or use any/all of the enhancement frameworks that Python provides (see Numba). Additionally, the simple methods we implemented are very na√Øve. The standard numerical packages use sophisticated algorithms honed for many decades.\n\nMaybe then we should get some benchmark value first. As none of us would bother to integrate this by hand, we'll use SciPy. Unexpectedly (SciPy uses C and Fortran underneath), we get the result in a breeze and it is very close to actual value of 2.0.\n\n::: {#8ded04a4 .cell execution_count=6}\n``` {.python .cell-code}\nfrom scipy.integrate import quad\n\nscipy_quad, err = quad(f, start, end)\nprint(scipy_quad)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.9999999999999998\n```\n:::\n:::\n\n\nNow, lets use our `Integrator` class and see\n\n::: {#1a3b4eb6 .cell execution_count=7}\n``` {.python .cell-code}\nintegrator = Integrator(\n    f,\n    interval_start=start,\n    interval_end=end,\n)\n\niterations = [2**i for i in range(0,21,5)]\nrectangle_results = [integrator(RectangleSchema(steps=i)) for i in iterations]\nmc_results = [integrator(MonteCarloSchema(random_points=i)) for i in iterations]\n\nprint(f\"Rectangle schema results:\\n{rectangle_results}.\")\nprint(f\"Monte Carlo schema results:\\n{mc_results}.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUsing Rectangle schema with 1 steps..\nUsing Rectangle schema with 32 steps..\nUsing Rectangle schema with 1024 steps..\nUsing Rectangle schema with 32768 steps..\nUsing Rectangle schema with 1048576 steps..\nUsing Monte Carlo schema with 1 random points..\nUsing Monte Carlo schema with 32 random points..\nUsing Monte Carlo schema with 1024 random points..\nUsing Monte Carlo schema with 32768 random points..\nUsing Monte Carlo schema with 1048576 random points..\nRectangle schema results:\n[1.5707963267948966, 1.986172817555692, 1.9995804632216618, 1.9999869013603688, 1.9999995906791057].\nMonte Carlo schema results:\n[2.115044415975735, 1.9752901067765187, 2.008650450563558, 2.0001172611040547, 2.0002601026808255].\n```\n:::\n:::\n\n\nBut I was wrong! You *should* be excited! We just learned new approach for setting up extensible and readable code! Look how cleanly the pproblem statement is separated form approaches to solve it.\n\nIf you are now wondering how much we could improve by using more advanced technique (like [stratified Monte Carlo](http://proceedings.mlr.press/v28/carpentier13.pdf) or [adaptive quadrature](https://www.wikiwand.com/en/Adaptive_quadrature)) you just need to implement new subclass of \\`IntegrationSchema' and you're done. No changes to the existing code are need, just simple extension. And that's the idea behind strategy pattern.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}