{
  "hash": "d0c5d88f7ec6c2296fdec17de45c9906",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \" Python Startup Script\"\ndescription: \"How to start your day with a cup of coffee, not opening the same apps all over again.\"\nauthor: \"bwrob\"\ndate: \"2024-05-21\"\ndate-modified: \"2024-08-30\"\n\ncategories: [Pythonic Distractions]\n\nimage: win_98.png\n\nformat-links: [html]\n---\n\n\n\n\n\n![](win_98.png){width=\"65%\" fig-align=\"center\"}\n\n## Why a startup script?\n\nConfession time. Pre-COVID I worked for a Swiss bank --- it was the whole corporate package. Working from a crowded office, open space, dedicated desks, dedicated desktop PCs, hundreds of people. And we never turned the PCs off, some of them were running constantly for months. Not very eco-friendly behaviour, either from the company side or from the employees. But there were legit reasons for this and the company had much [bigger sins](https://www.wikiwand.com/en/Credit_Suisse#Controversies) on their books.\n\nAs for the reasons for constantly turned on machines --- the proprietary frameworks and tooling we used were awfully heavy and slow. If you were occasionally forced to kill all the processes --- due to an update or system crash --- getting them all up again took an hour or more. Developer tools, pricing systems, connections to Monte Carlo farms, downloading trade data, analysis definitions --- you name it, we used it.\n\nOne tidbit to get this point across --- in 2019 we still used 32-bit Win7, which had a cap on single-process memory consumption to 4GB. We had a universally used hack to extend this to 8GB for Excel, since the default wasn't enough for many of our pricing sheets.\n\nWhen I parted ways with the company post-COVID, I got a corporate laptop from the new employer. The office was much sparser, quieter and with 'hot seats' approach. I worked mostly remotely either way. This meant switching off the company machine each day, as the VPN connections and certificates wouldn't last overnight. I was extremely annoyed with opening all of the daily tools again and again, after getting used to having it all waiting for me to jump right in.\n\nHence the need for a startup script to open all of the apps, tools and files programatically. It won't cover everything, like authorizations or connections but still a little helper to start the day.\n\nTo spice things up, we will overengineer the hell out of it and use generic typing, generators and decorators :D.\n\n## The startup script\n\n### Public interface\n\nLet's first think about the design and what we want to achieve. Imagine the code being split into two parts:\n\n-   the hidden logic layer, **the worker** that does stuff and\n-   the public interface that integrates with the rest of the codebase or is called at the top level, **the manager**.\n\nWe can start by creating the public interface, see what we want to achieve and later deal with filling in a working implementation. You can either define the logic functions as mocks, or just live with linting issues. This is what my desired usage is:\n\n::: {#e18a39ab .cell execution_count=1}\n``` {.python .cell-code}\ndef run_startup_script() -> None:\n    \"\"\"Run the startup script.\"\"\"\n    logger.info(f\" Welcome {os.getlogin()}! \".center(40, \"*\"))\n    start_programs(\n        [\n            Program.POWERSHELL,\n            Program.NOTEPAD,\n            (Program.FIREFOX, 8),\n        ],\n    )\n    start_work_files([Path.home() / \".temp\"])\n    run_commands(['Write-Output \"test\"'])\n```\n:::\n\n\nWe specify programs to be launched, open all files in a chosen temp folder and run a list of shell commands. After each step there should be some delay to avoid spamming system with process calls. Certain steps might be more time consuming, like cloud services authorization. Those need longer delay. On the other hand, specifying delay for each task would be cumbersome, most cases would be fine with some default value. We end up with a design that our soon-to-be workers `start_programs`, `start_work_files`, and `run_commands` expect lists of either `task` or `(task, delay_seconds)`. We can now start the implementation by figuring out how the delay time should be defaulted if not specified.\n\n### Decorator defaulting the time delays\n\nNow we can start the implementation. We want the workers to be called with a list of tasks, but a task can be either a command or a tuple including the delay. Let's not include some complicated conditionals in each of the workers --- that would be annoying and potentially get out of sync at some point.\n\nOther way to do this is to add a default delay to all non-tuple items. We can implement that as a separate defaulting function, which we would call in each worker. But --- being more clever! --- we could also use a decorator that changes the workers's signature.\n\n::: {#efedd1d5 .cell execution_count=2}\n``` {.python .cell-code}\nfrom functools import wraps\nfrom collections.abc import Callable\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\nTask = tuple[T, int]\nTaskList = list[Task[T]]\nTaskListOptionalDelay = list[Task[T] | T]\n\n\nDEFAULT_DELAY_SECONDS = 4\n\ndef with_optional_delay(\n    task_worker: Callable[[TaskList[T]], None],\n) -> Callable[[TaskListOptionalDelay[T]], None]:\n    \"\"\"Add default delay to all non-tuple items.\n\n    Args:\n    ----\n        task_worker: A function that takes a list of tasks.\n\n    \"\"\"\n\n    @wraps(task_worker)\n    def task_defaulted_worker(task_list: TaskListOptionalDelay[T]) -> None:\n        \"\"\"Add a default delay to tasks in a task list if no delay is specified.\n\n        Args:\n        ----\n            task_list: A list of tasks with optional delays.\n\n        \"\"\"\n        tasks_with_defaulted_delays: TaskList[T] = [\n            item if isinstance(item, tuple) else (item, DEFAULT_DELAY_SECONDS)\n            for item in task_list\n        ]\n        return task_worker(tasks_with_defaulted_delays)\n\n    return task_defaulted_worker\n```\n:::\n\n\nFirst, for convenience, let's define a template type annotation:\n\n-   The generic variable type is conventionally denoted by `T`.\n-   A `Task` is a tuple of a generic task `T` and an `int` delay.\n-   A `TaskList` is a list of `Task`s. Simple.\n-   A `TaskListOptionalDelay` is a list of `Task`s or `T`s. Those are the guys we are going to turn into `TaskLists`.\n\nThe decorator `with_optional_delay` adds a default delay of 4 seconds to all non-tuple items. Its input is a worker function that already expects a `TaskList`. It fills in the missing delay with the default value and passes it to the decorated function.\n\n### Main workers\n\nWith the preparation done, we can start with the workers. For the programs we will be launching, we need to look up the exact paths of the executables. Let's define a `Program` enum that would wrap those up in readable nice names. For working with system paths we will use `pathlib.Path` that provides high-level interface.\n\n::: {#d2f83529 .cell execution_count=3}\n``` {.python .cell-code}\nfrom enum import Enum\nfrom pathlib import Path\n\n\nclass Program(Enum):\n    \"\"\"Types of programs.\"\"\"\n\n    POWERSHELL = Path(r\"C:\\windows\\system32\\windowspowershell\\v1.0\\powershell.exe\")\n    NOTEPAD = Path(r\"C:\\Program Files\\Notepad++\\notepad++.exe\")\n    FIREFOX = Path(r\"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Firefox.lnk\")\n```\n:::\n\n\nOther than that, the main workers `start_programs`, `start_work_files`, and `run_commands` are simple. They just iterate over the provided `TaskList` and do the respective action for a given `Task`.\n\n::: {#bc6438b8 .cell execution_count=4}\n``` {.python .cell-code}\n@with_optional_delay\ndef start_programs(\n    programs: TaskList[Program],\n) -> None:\n    \"\"\"Start listed programs.\n\n    Args:\n    ----\n        programs: List of programs to start.\n            Can be a string or a tuple. If a tuple is given, the first\n            element is the name, the second is the delay.\n\n    \"\"\"\n    for program, delay in programs:\n        start_process(\n            name=program.name,\n            path=program.value,\n            delay=delay,\n        )\n\n\n@with_optional_delay\ndef start_work_files(\n    directory_tasks: TaskList[Path],\n) -> None:\n    \"\"\"Start all  files in the work folders.\n\n    Args:\n    ----\n        directory_tasks: List of tasks with paths to work folders.\n\n    \"\"\"\n    for path, delay in path_files(directory_tasks):\n        start_process(\n            name=path.name,\n            path=path,\n            delay=delay,\n        )\n\n\n@with_optional_delay\ndef run_commands(\n    commands: TaskList[str],\n) -> None:\n    \"\"\"Run all commands in the command list.\n\n    Args:\n    ----\n        commands: List of commands to run.\n\n    \"\"\"\n    for command, delay in commands:\n        run_command(command, delay)\n\n```\n:::\n\n\n### List all files in list of directories\n\nNotice the use of `path_files` generator above. When working with complex iterations, it's a good practice to create a generator that wraps the iteration details. It is beneficial for readability and maintainability, especially in cases where you need to:\n\n-   yield multiple values at once (ex. *yield path, delay for path in directory*),\n-   have nested iterators (ex. *for directory in list for path in directory*),\n-   filter the iteration (ex. *for path in directory if filter(path)*).\n\nHere we'll have all three of them combined!\n\n::: {#9dfdac14 .cell execution_count=5}\n``` {.python .cell-code}\nNAME_EXCLUDES = (\"$\", \"tmp\")\nEXT_EXCLUDES = (\"exe\",)\n\n\ndef filter_excluded(\n    path: Path,\n) -> bool:\n    \"\"\"Filter path based on name and extension exclude lists.\n\n    Args:\n    ----\n        path: Path to filter.\n\n    \"\"\"\n    return (path.stem not in NAME_EXCLUDES) and (path.suffix not in EXT_EXCLUDES)\n\n\n\ndef path_files(\n    directory_tasks: TaskList[Path],\n) -> Generator[tuple[Path, int], None, None]:\n    \"\"\"Generate all files in the work folder that are not excluded.\n\n    Yields the folder path at beginning of the generator.\n\n    Args:\n    ----\n        directory_tasks: List of tasks with paths to work folders.\n\n    \"\"\"\n    for folder, delay in directory_tasks:\n        yield folder, delay\n\n        all_files = folder.glob(FILES_IN_TREE_PATTERN)\n        filtered = filter(filter_excluded, all_files)\n\n        for file in filtered:\n            yield file, delay\n\n```\n:::\n\n\nThe `filter_excluded` function filters out files based on exclusions in name and extension lists. `Path.stem` and `Path.suffix` are used to check if the file name or extension is in the lists respectively.\n\n### Interacting with the OS\n\nWith all of the framework prepared, the next step is to interact with the OS. To open a file, folder or run an app, we can use the `os.startfile` function. All the rest of the `start_process` function is just utility logging. For running a shell command we can use the `subprocess` module, calling powershell with the `powershell.exe` and adding the command to run.\n\n::: {#3ae159dc .cell execution_count=6}\n``` {.python .cell-code}\nimport os\nimport subprocess\nimport time\n\n\ndef start_process(\n    *,\n    name: str,\n    path: Path,\n    delay: int = DEFAULT_DELAY_SECONDS,\n) -> None:\n    \"\"\"Given a path, starts the target.\n\n    Behavior:\n        * Minimizes all windows.\n        * Depending on the path target:\n            * executable files are run,\n            * content files are opened with system default program,\n            * folders are opened with system explorer.\n\n    Args:\n    ----\n        name: Name of the process to start.\n        path: Path to the target.\n        delay: Time to wait after starting the process.\n\n    \"\"\"\n    if path.is_dir():\n        logger.info(\"Opening folder %s\", name)\n\n    if path.suffix in (\".exe\", \".lnk\"):\n        logger.info(\"Running app %s\", name)\n    else:\n        logger.info(\"Opening file %s\", name)\n\n    os.startfile(path)\n    time.sleep(delay)\n\n\ndef run_command(\n    command: str,\n    delay: int,\n) -> None:\n    \"\"\"Run a powershell command.\n\n    Args:\n    ----\n        command: Command to run.\n        delay: Time to wait after starting the process.\n\n    \"\"\"\n    _ = subprocess.call(\n        f\"powershell.exe {command}\",\n        shell=False,\n    )\n    time.sleep(delay)\n```\n:::\n\n\n## The last bit of convenience\n\nWe got it, friends, the script works and the job is done. But... do you recall the last time you googled a shortcut for a semi-frequently used functionality? Do you still remember the shortcut, or use it each time you need the functionality? Convenience needs to be convenient (obviously). So let's make the usage of our script as seamless as possible.\n\nIn Windows OS the best way for me would be to have a shortcut that would run it with one click. We could pin it to the taskbar and start menu. To create one:\n\n-   Go to any folder, right-click and select `New > Shortcut`.\n-   In the guide that pops up paste in `%systemroot%\\System32\\cmd.exe /c \"python.exe $1\"` where `$1` should be replaced by the path to your script. You can also replace `python.exe` with interpreter path of any venv you wish.\n-   Optionally, you can later change the icon for the shortcut (needs to be `.ico` file). I like to roll with Win-98 style 'My Computer' icon.\n-   Copy the shortcut to start menu directory. For Win11 it's `C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs`. You should be able to see it in start menu already. Now you can pin it to the taskbar.\n\n![](startup_shortcut.png){width=\"100%\"}\n\nThat's a good enough reminder and convenience tool for me. You might need some different setup, especially for another OS. For Linux, you might try to leverage `activate` or `bashrc` scripts in your working setup.\n\n## Further extensions\n\nThere are a couple more things I wish this guy could do for me still:\n\n-   **Changing Teams status to green** - there's a MS Graph API that could do this but we would need to manage Azure authorizations through the script. I am not up to that, especially on a work account. Might experiment on personal one in the future.\n-   **Display placement of opened processes** --- I have 2 displays (which you could count as 4, due to the size format) and I am very particular about where each app should go. I would love the apps to open where they should. This is however OS specific, for Win it require to mingle with win32api. Yet another project for the future.\n\n::: callout-note\nDownload the startup [script](../../scripts/startup_script.py) and example Windows [shortcut](Startup!.lnk).\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}